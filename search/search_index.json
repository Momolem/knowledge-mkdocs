{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"","tags":["DigitalGarden"]},{"location":"#momolems-digital-garden","title":"Momolems Digital Garden","text":"<p>This is where my knowledge grows</p> <p>This far I managed to include some notes on the topics CleanCode, UI &amp; UX and Cooking I want to expand these topics with everything I know</p>","tags":["DigitalGarden"]},{"location":"#clean-code","title":"Clean Code","text":"<p>CleanCode</p> <ul> <li>Clean Code Developer</li> <li>Design Patterns</li> </ul>","tags":["DigitalGarden"]},{"location":"#ui-ux","title":"UI &amp; UX","text":"<p>Entwurfsmuster</p>","tags":["DigitalGarden"]},{"location":"#cooking","title":"Cooking","text":"<p>Baghali Polo</p>","tags":["DigitalGarden"]},{"location":"Cheat%20Sheets/Linux/","title":"Linux","text":""},{"location":"Cheat%20Sheets/Linux/#the-hierarchical-structure-of-the-linux-file-system","title":"The Hierarchical Structure of the Linux File System","text":"<p>The Linux file system is organized in a hierarchical tree-like structure, with the root directory (/) at the top. All other directories and files are contained within the root directory, which can be broken down into several subdirectories. Some of the key directories and their purposes include:</p> <p></p> <p>File Hierarchy Structure (FHS) in Linux</p> <p>It follows a standard naming convention for directories and files. Directories are often named after their function or content, while files are named after their purpose. Here are some common directories and their functions:</p> <ol> <li>/bin (Essential User Binaries): The /bin directory contains essential system binaries that are required for the basic operation of the system, such as ls, cp, mv, and cat.</li> <li>/boot (Boot Loader Files): The /boot directory contains the files required for the boot loader to load the operating system. These files include the kernel, initial RAM disk, and boot loader configuration files.</li> <li>/dev (Device Files): The /dev directory contains device files that represent hardware devices and drivers. These files can be used to interact with hardware devices directly, such as USB drives, CD-ROMs, and printers.</li> <li>/etc (Configuration Files): The /etc directory contains configuration files for the system and applications installed on the system. These files include network configuration, user accounts, and system-wide configuration settings.</li> <li>/home (User Home Directories): The /home directory contains the home directories for individual users on the system. Each user has a subdirectory in the /home directory that contains their personal files and settings.</li> <li>/lib (Essential Shared Libraries): The /lib directory contains essential shared libraries that are required by system binaries and other applications on the system.</li> <li>/media (Removable Media): The /media directory is used for mounting removable media, such as USB drives, CD-ROMs, and DVDs.</li> <li>/mnt (Mount Point for File Systems): The /mnt directory is used for mounting other file systems, such as network file systems or other hard drives.</li> <li>/opt (Optional Software): The /opt directory is used for optional software installed on the system. This directory can be used for installing software that is not included in the system\u2019s package manager.</li> <li>/proc (Process Information): The /proc directory contains virtual files that provide information about the system and running processes. These files can be used to monitor system performance and diagnose issues.</li> <li>/root (Home Directory for root User): The /root directory is the home directory for the root user, the system administrator. This directory contains the personal files and settings for the root user.</li> <li>/run (Runtime Data): The /run directory contains runtime data for the system and applications, such as system logs, process IDs, and other temporary files.</li> <li>/sbin (System Binaries): The /sbin directory contains system binaries that are required for system administration tasks, such as fdisk and iptables.</li> <li>/srv (Service Data): The /srv directory contains data for services provided by the system, such as websites and FTP servers.</li> <li>/tmp (Temporary Files): The /tmp directory is used for storing temporary files that are created and used by applications.</li> <li>/usr (User Binaries and Libraries): The /usr directory contains user binaries and libraries for the system, such as system administration tools and development libraries.</li> <li>/var (Variable Data): The /var directory contains variable data for the system, such as system logs, mailboxes, and spool files.</li> </ol>"},{"location":"Cheat%20Sheets/Linux/#oh-my-zsh","title":"Oh My Zsh","text":"<pre><code>dnf install zsh\n\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n</code></pre>"},{"location":"Cheat%20Sheets/Linux/#luks","title":"LUKS","text":""},{"location":"Cheat%20Sheets/Linux/#setup-automatic-unlock","title":"Setup automatic unlock:","text":"<pre><code>clevis luks bind -d /dev/mmcblkp3 tpm2 '{\"pcr_ids\":\"1,7\",\"key\":\"rsa\"}'\nsystemctl enable clevis-luks-askpass.path\ndracut --regenerate-all --force\n</code></pre>"},{"location":"Cheat%20Sheets/Linux/#regenerate","title":"Regenerate","text":"<p>If automatic unlock does not work anymore it needs to be regenerated. First list the used slots: <pre><code>clevis luks list -d /dev/nvme0n1p3\n</code></pre></p> <p>Then regenerate using slot <pre><code>clevis luks regen -d /dev/nvme0n1p3 -s 1\n</code></pre></p>"},{"location":"Cheat%20Sheets/Linux/#change-pcrs","title":"Change PCRs","text":"<p>To change PCRs you first need to delete the key and then re-add using the wanted PCRs. List the used slots:</p> <p><pre><code>clevis luks list -d /dev/nvme0n1p3\n</code></pre> Remove the slot: <pre><code>clevis luks unbind -d /dev/nvme0n1p3 -s 1 -f\n</code></pre></p> <p>Note:\u2003<code>-f</code>\u2003will not ask for confirmation but is needed if there is no other slot set up.</p> <p>After that re-add the key like above.</p>"},{"location":"Cheat%20Sheets/Linux/#obs-virtual-cam","title":"OBS Virtual Cam","text":"<p>Install v4l2loopback <pre><code>sudo dnf install https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm\nsudo dnf install v4l2loopback \n</code></pre></p> <pre><code>git clone https://github.com/umlaeute/v4l2loopback\n</code></pre>"},{"location":"Cheat%20Sheets/Rider%20Shortcuts%20%28IntelliJ%20IDEA%29/","title":"Rider Shortcuts (IntelliJ IDEA)","text":"","tags":["cheat","refactoring","rider","keymap","shortcuts"]},{"location":"Cheat%20Sheets/Rider%20Shortcuts%20%28IntelliJ%20IDEA%29/#refactoring","title":"Refactoring","text":"Name Shortcut Refactor This CTRL+ALT+SHIFT+T Rename SHIFT+F6 Inline CTRL+ALT+N Move F6 Extract Method CTRL+ALT+M Introduce Field CTRL+ALT+F Introduce Parameter CTRL+ALT+P Introduce Varialbe CTRL+ALT+V Safe Delete ALT+DELETE Change Signature CTRL+F6 Toggle Casing CTRL+SHIFT+U ##  Live Templates Name Description ---- ------------------ prop Generates Property","tags":["cheat","refactoring","rider","keymap","shortcuts"]},{"location":"Cheat%20Sheets/SSH/","title":"SSH","text":""},{"location":"Cheat%20Sheets/SSH/#ssh","title":"SSH","text":""},{"location":"Cheat%20Sheets/SSH/#autostart-ssh-agent-with-zsh","title":"Autostart SSH-Agent with Zsh","text":"<p>Add Plugin in <code>~/.zshrc</code>: <pre><code>plugins(git ssh-agent)\n</code></pre> And then reload the zsh session from the config file <pre><code>source ~/.zshrc\n</code></pre></p>"},{"location":"Cheat%20Sheets/SSH/#config-hierarchie","title":"Config-Hierarchie","text":"<ol> <li>CMD-Line Options</li> <li>User-Config (<code>~/.ssh/config</code>)</li> <li>Systemwide-Config (<code>/etc/ssh/ssh_config</code>)</li> </ol> <p>Warning</p> <p>For each parameter, the first obtained value will be used   So more specific config entries should be at the top of the configs  \\(\\rightarrow\\) Defaults at the end</p>"},{"location":"Cheat%20Sheets/SSH/#hostname-alias","title":"Hostname Alias","text":""},{"location":"Cheat%20Sheets/SSH/#simple","title":"Simple","text":"<pre><code>Host demo\n HostName ssh-server.example.com\n</code></pre>"},{"location":"Cheat%20Sheets/SSH/#multiple","title":"Multiple","text":"<pre><code>Host demo d1 popocatepetl\n HostName ssh-server.example.com\n</code></pre>"},{"location":"Cheat%20Sheets/SSH/#dynamic-hostname","title":"Dynamic Hostname","text":"<pre><code>Host smtp imap www\n HostName %h.example.com\n</code></pre>"},{"location":"Cheat%20Sheets/SSH/#ssh-public-key-authentication","title":"SSH Public Key authentication","text":""},{"location":"Cheat%20Sheets/SSH/#generate-key","title":"Generate Key","text":"<pre><code>ssh-keygen -t ed25519 \\\n -a 420 \\\n -f ~/.ssh/demo.ed25519 \\\n -C \"Sinnvoller Kommentar!\"\n</code></pre> <p>WICHTIG</p> <p>IMMER eine Passphrase definieren!</p>"},{"location":"Cheat%20Sheets/SSH/#result","title":"Result","text":"<pre><code>~/.ssh/demo.ed25519\n~/.ssh/demo.ed25519.pub\n</code></pre> <p>Warning</p> <p>Nur die .pub Datei darf \u00f6ffentlich gemacht werden</p>"},{"location":"Cheat%20Sheets/SSH/#best-practice","title":"Best Practice","text":"<p>Create one for each server, customer or service you connect to.</p>"},{"location":"Cheat%20Sheets/SSH/#get-key-to-server","title":"Get Key to Server","text":"<ul> <li> <p>Automatic</p> <pre><code>ssh-copy-id \\\n -i ~/.ssh/demo.ed25519.pub \\\n demo\n</code></pre> </li> <li> <p>Manual</p> <ul> <li>copy content of local <code>~/.ssh/demo.ed25519.pub</code></li> <li>paste it into <code>~/.ssh/authorized_keys</code> on servers</li> </ul> </li> </ul>"},{"location":"Cheat%20Sheets/SSH/#enable-key-auth-in-config","title":"Enable Key Auth in Config","text":"<pre><code>Host demo bastion\n PreferredAuthentications publickey\n IdentityFile ~/.ssh/demo.ed25519\n</code></pre>"},{"location":"Cheat%20Sheets/SSH/#full-config-example","title":"Full Config Example","text":"<pre><code>Host demo bastion\n\tHostName ssh.example.com\n\tUser demoUser\n\tPreferredAuthentications publickey\n\tIdentityFile ~/.ssh/demo.ed25519\n</code></pre>"},{"location":"Cheat%20Sheets/SSH/#enable-ssh-agent","title":"Enable ssh-agent","text":"<p>Why? Saves key Passphrase</p> <ul> <li>ssh-add<ul> <li>\u201c-c\u201d ask for permission before use</li> <li>\u201c-d\u201d removes key from ssh-agent</li> </ul> </li> </ul> <pre><code>ssh-add ~/.ssh/demo.ed25519\n</code></pre>"},{"location":"Cheat%20Sheets/SSH/#sane-defaults","title":"Sane Defaults","text":"<pre><code>Host *\n IdentitiesOnly yes\n UseRoaming no\n SendEnv LANG LC_*\n Compression yes\n</code></pre>"},{"location":"Cheat%20Sheets/SSH/#sshconfd","title":"~/.ssh/conf.d","text":"<p>Multiple files i.E for multiple Customers</p>"},{"location":"Cheat%20Sheets/SSH/#bastionjump-hosts","title":"Bastion/Jump Hosts","text":""},{"location":"Cheat%20Sheets/SSH/#manual","title":"Manual","text":"<pre><code>$ ssh bastion\nWelcome to demo.example.com\n\nleyrer@demo:~$ ssh target.local\nWelcome to target.local\n</code></pre>"},{"location":"Cheat%20Sheets/SSH/#explicit","title":"Explicit","text":"<pre><code>ssh -J bastion target.local\n</code></pre>"},{"location":"Cheat%20Sheets/SSH/#elegant","title":"Elegant","text":"<pre><code>Host demo bastion\n\tHostName ssh.example.com\n\tUser leyrer\n\tPreferredAuthentications publickey\n\tIdentityFile ~/.ssh/demo.ed25519\n\nHost internal\n\tHostName target.local\n\tProxyJump bastion\n\tUser leyrer\n\tPreferredAuthentications publickey\n\tIdentityFile ~/.ssh/demo.ed25519\n</code></pre>"},{"location":"Cheat%20Sheets/SSH/#fallback","title":"Fallback","text":"<pre><code>ssh \\\n -o ProxyCommand=\"ssh -W %h:%p bastion\" \\\n target.local\n</code></pre> <pre><code>.ssh/config:\n\tHost internal\n\tProxyCommand ssh -W %h:%p bastion\n</code></pre> <p>Warning</p> <p>Do not use Agent Forwarding (<code>ssh -A</code>)</p>"},{"location":"Cooking/Baghali%20Polo/","title":"Baghali Polo","text":"","tags":["cooking","persian"]},{"location":"Cooking/Baghali%20Polo/#baghali-polo-das-mit-den-bohnen","title":"Baghali Polo (Das mit den Bohnen)","text":"","tags":["cooking","persian"]},{"location":"Cooking/Baghali%20Polo/#zutaten","title":"Zutaten","text":"<ul> <li>Zwiebeln</li> <li>Gesch\u00e4hlte Bohnen</li> <li>Dill</li> <li>Tomatenmark</li> <li>Reis</li> <li>Safran</li> <li>Kurkuma</li> <li>Lammfleisch</li> </ul>","tags":["cooking","persian"]},{"location":"Cooking/Baghali%20Polo/#ablauf","title":"Ablauf","text":"<p>Zuerst die Zwiebeln in \u00d6l anbraten. Anschlie\u00dfen etwas Kurkuma hinzugeben und gut verr\u00fchren. Anschlie\u00dfend mit Wasser abl\u00f6schen und das Fleisch hinzugeben. Das Fleisch muss gerade so bedeckt sein, hierbei m\u00f6glichst wenig Wasser verwenden. Ca. 30-15 Minuten vor Schluss etwas gebratenes Tomatenmark und Safran zur Fl\u00fcssigkeit hinzugeben.</p> <p>Die Bohnen mit gekochtem Wasser \u00fcbergie\u00dfen und 5 Minuten kochen lassen. Anschlie\u00dfend 5 Minuten mit Deckel ziehen lassen. Das Wasser kann hierbei nur die H\u00e4lfte der Bohnen bedecken. Nicht zu viel R\u00fchren, sonst zerbrechen die Bohnen. Die Br\u00fche f\u00fcr den Reis verwenden und diesen zun\u00e4chst ganz normal kochen. </p> <p>Wenn das ganze Wasser aus dem Reis ist, ein Hohlraum f\u00fcr die Bohnen schaffen. Hierbei nicht bis ganz nach unten, damit die Kruste nicht kaputt geht. Bohnen, Dill und etwas Zimt hinzugeben. Drei kleine L\u00f6cher mit einem Kochl\u00f6ffelstiel formen und ein bisschen kochendes Wasser hineingeben um etwas Dampf zu erzeugen. Direkt den Deckel drauf.  </p> <p>Zum Schluss etwas geschmolzene Butter hinzugeben.</p>","tags":["cooking","persian"]},{"location":"Cooking/Chili%20Con%20Carne/","title":"Chili Con Carne","text":"","tags":["cooking","mexican"]},{"location":"Cooking/Chili%20Con%20Carne/#chili-con-carne-ala-koder","title":"Chili Con Carne (ala Koder)","text":"","tags":["cooking","mexican"]},{"location":"Cooking/Chili%20Con%20Carne/#zutaten","title":"Zutaten","text":"<ul> <li>600g Hackfleisch</li> <li>3x Dosen Tomaten \u201cgesteckt\u201d</li> <li>3x Dosen Kidneybohnen</li> <li>1x Glas Chili So\u00dfe</li> <li>1x Packung \u201cChili-Con-Carne\u201d-Gew\u00fcrz</li> <li>1x Dose Wei\u00dfe Bohnen</li> <li>Suppengem\u00fcse</li> <li>Salz</li> <li>Pfeffer</li> <li>Chiligew\u00fcrz und andere Gew\u00fcrze (je nach Bedarf)</li> <li>1x Zwiebel</li> <li>optional: K\u00e4se zum Reiben und Schmand</li> </ul>","tags":["cooking","mexican"]},{"location":"Cooking/Chili%20Con%20Carne/#ablauf","title":"Ablauf","text":"<ol> <li>Zwiebeln in einer Pfanne anbraten und Hackfleisch hinzugeben</li> <li>Dann alle anderen Zutaten in einen Topf geben und umr\u00fchren</li> <li>Hackfleisch ebenfalls in den Topf geben</li> </ol> <p>Optimaler Geschmack</p> <p>Am besten sollte das Gericht am Vortag zum Verzehr gekocht werden, da es die Nacht \u00fcber durchziehen muss.  Am n\u00e4chsten Tag kann das Gericht dann wieder erhitzt und serviert werden.</p>","tags":["cooking","mexican"]},{"location":"Cooking/Kichererbsen%20Wrap/","title":"Kichererbsen Wrap","text":"","tags":["cooking","mexican"]},{"location":"Cooking/Kichererbsen%20Wrap/#zutaten","title":"Zutaten","text":"","tags":["cooking","mexican"]},{"location":"Cooking/Kichererbsen%20Wrap/#gerostete-kichererbsen","title":"Ger\u00f6stete Kichererbsen","text":"<ul> <li>2 Dosen Kichererbsen</li> <li>1 TL Paprikapulver</li> <li>1 TL Salz</li> <li>1 EL \u00d6l</li> <li>2 EL Sambal Oelek</li> <li>3 EL Joghurt</li> <li>4 Tortilla Wraps</li> <li>1 Handvoll Eisbergsalat</li> </ul>","tags":["cooking","mexican"]},{"location":"Cooking/Kichererbsen%20Wrap/#dressing","title":"Dressing","text":"<ul> <li>6 EL Joghurt</li> <li>1 TL Dill</li> <li>1/2 Zitrone, Saft</li> <li>1/2 TL Senf</li> <li>1/2 TL Salz</li> <li>1/2 TL Agavendicksaft</li> </ul>","tags":["cooking","mexican"]},{"location":"Cooking/Kichererbsen%20Wrap/#zubereitung","title":"Zubereitung","text":"<ol> <li>Kichererbsen aus der Dose nehmen, waschen und auf einem Backblech getrennt voneinander platzieren.</li> <li>Ger\u00e4uchertes Paprikapulver, Salz sowie \u00d6l \u00fcber die Kichererbsen geben und alles gut miteinander vermischen.</li> <li>Das Ganze nun im 220 Grad vorgeheizten Ofen f\u00fcr 15 Minuten erhitzen</li> <li>In der Zwischenzeit das Dressing vorbereiten und hierf\u00fcr Joghurt, Dill, Zitronensaft, Senf, Salz sowie Agavendicksaft in einer Sch\u00fcssel miteinander vermischen und zur Seit stellen.</li> <li>Nun die Tortilla-Wraps kurz erw\u00e4rmen</li> <li>Sambal-Olek sowie Joghurt in eine Sch\u00fcssel geben und die gebackenen Kichererbsen aus dem Ofen darin w\u00e4lzen.</li> <li>Eisbergsalat klein schneiden und zusammen mit den Kichererbsen auf die Tortilla-Wraps geben, mit Dressing \u00fcbergie\u00dfen, einrollen und genie\u00dfen.</li> </ol>","tags":["cooking","mexican"]},{"location":"Cooking/Penne%20all%20arrabbiata/","title":"Penne all arrabbiata","text":"","tags":["cooking","italian"]},{"location":"Cooking/Penne%20all%20arrabbiata/#zutaten","title":"Zutaten","text":"<ul> <li>Penne</li> <li>Zwiebeln</li> <li>Ingwer</li> <li>Knoblauch</li> <li>Chili</li> <li>Gem\u00fcsebr\u00fche (am besten W\u00fcrfel)</li> <li>Petersilie (und andere Kr\u00e4uter nach belieben)</li> <li>Tomaten Gehackt</li> </ul>","tags":["cooking","italian"]},{"location":"Cooking/Penne%20all%20arrabbiata/#ablauf","title":"Ablauf","text":"<p>Nudeln normal in Salzwasser kochen.</p> <p>Erst Zwiebeln hacken und in \u00d6l and\u00fcnsten. Knoblauch, Ingwer und Chili klein Hacken. Chili und Knoblauch zu den Zwiebeln geben. Dann nach einer Minute zwei Gem\u00fcsebr\u00fche W\u00fcrfel hinzugeben und mit den Tomaten abl\u00f6schen. Dann Ingwer hinzugeben. Ca. 30 Minuten auf schwacher/mittlerer Hitze k\u00f6cheln lassen. W\u00e4hrenddessen die Kr\u00e4uter klein hacken und dazu geben.</p>","tags":["cooking","italian"]},{"location":"Cooking/Spinatnudeln/","title":"Spinatnudeln","text":"","tags":["Pasta","italian"]},{"location":"Cooking/Spinatnudeln/#zutaten","title":"Zutaten","text":"<ul> <li>Spaghetti</li> <li>Sahne</li> <li>Scharlotte</li> <li>Knoblauch</li> <li>Butter</li> <li>Oliven\u00f6l</li> <li>Salz</li> <li>Pfeffer</li> <li>Muskatnuss</li> </ul>","tags":["Pasta","italian"]},{"location":"Cooking/Spinatnudeln/#zubereitung","title":"Zubereitung","text":"<p>Salzwasser f\u00fcr die Nudeln aufsetzen. W\u00e4hrenddessen eine Scharlotte und ein/zwei Zehen Knoblauch fein w\u00fcrfeln. Butter und Oliven\u00f6l in der Pfanne auf mittlerer Hitze schmelzen und das geschnittene and\u00fcnsten.  </p> <p>Nudeln in den Topf und gleichzeitig die Sahne in die Pfanne und kurz aufkochen lassen. Den Tiefk\u00fchlspinat dazugeben und auftauen lassen. Die So\u00dfe mit Salz, schwarzen Pfeffer und Muskatnuss w\u00fcrzen. Die Nudeln zwei Minuten vor der Zeit von dem Top in die Pfanne dazugeben und eine Kelle Salzwasser zur Pfanne geben. Die Nudeln noch zwei Minuten fertig kochen lassen.</p>","tags":["Pasta","italian"]},{"location":"Methodical/T-Shaped%20Profile/","title":"T Shaped Profile","text":""},{"location":"Methodical/T-Shaped%20Profile/#definition","title":"Definition","text":"<p>The components of a T-Shaped personality profile are:</p> <ul> <li>Specialist Deep skills in one area of expertise. Know every deep details of the area.</li> <li>Generalist: Broad knowledge across domains and soft skills.</li> <li>Interdiciplinary thinking: Are able to make connections between different areas or subdivisions of a company / teams. Do not only see what they are doing by themselfs but have a broad understanding of what brings the whole project forward.</li> </ul>"},{"location":"Methodical/T-Shaped%20Profile/#benefits","title":"Benefits","text":"<ul> <li>T-Employees can be used everywhere because they can adapt quickly. They can take on almost any task.</li> <li>They always consider the problem as a whole not only in a small area by always thinking outside of the box</li> <li>They always have overview over the project as a whole. This helps to improve collaboration.</li> <li>They find solitions that are future prove</li> </ul>"},{"location":"Methodical/WTF%20Book/","title":"WTF Book","text":"<p>Source</p> <p>https://www.simplermachines.com/why-you-need-a-wtf-notebook/</p> <p>In the mentioned article a nice practice for handling issues in new projects is explained. </p>"},{"location":"Methodical/WTF%20Book/#what-is-a-wtf-book","title":"What is a WTF Book","text":"<p>A WTF Book can be a new page in a bullet journal, in which you write down all the annoying things where you think \u201cWTF is this. Why is it done like this?\u201d. You do not communicate the issues with the team you are new in. </p>"},{"location":"Methodical/WTF%20Book/#whats-the-use-of-a-wtf-book","title":"Whats the use of a WTF Book","text":"<p>Over the timespan of a month you might figure out that some of these issues have actually valid reasons why they are like they are, or they might already be known and being addressed somehow. If you would have mentioned all of the issues up front, you might establish an image of \u201cthats the person who always complains\u201d. If you wait what the real unknown issues are you can use this as an advantage and establish an image that you are a person who can help if problems arise.</p>"},{"location":"Software%20Engineering/Clean%20Code/","title":"Clean Code","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/#clean-code","title":"Clean Code","text":"<p>Clean Code sind Praktiken, welche die Qualit\u00e4t des Codes durch BestPractices verbessern sollen.</p> <p>Die Prinzipien basieren Haupts\u00e4chlich auf dem Buch Clean Code (Book) von Robert C. Martin.</p> <p>Ein Praktischer Ansatz um Clean Code zu meistern ist der Clean Code Developer</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Integration%20Tests/","title":"Integration Tests","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Integration%20Tests/#integration-tests","title":"Integration Tests","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Legacy%20Code/","title":"Legacy Code","text":"","tags":["cleancode_refactoring"]},{"location":"Software%20Engineering/Clean%20Code/Legacy%20Code/#legacy-code","title":"Legacy Code","text":"","tags":["cleancode_refactoring"]},{"location":"Software%20Engineering/Clean%20Code/Refaktorisieren/","title":"Refaktorisieren","text":"","tags":["cleancode_refactoring"]},{"location":"Software%20Engineering/Clean%20Code/Refaktorisieren/#refaktorisieren","title":"Refaktorisieren","text":"","tags":["cleancode_refactoring"]},{"location":"Software%20Engineering/Clean%20Code/Refaktorisieren/#what","title":"What?","text":"<p>Struktur\u00e4nderungen ohne beobachtbares Verhalten zu \u00e4ndern.</p>","tags":["cleancode_refactoring"]},{"location":"Software%20Engineering/Clean%20Code/Refaktorisieren/#functional","title":"Functional","text":"<p>Was tut die Software? =&gt; Features Beim Ausf\u00fchren beobachtbar</p>","tags":["cleancode_refactoring"]},{"location":"Software%20Engineering/Clean%20Code/Refaktorisieren/#operation","title":"Operation","text":"<p>Wie tut die Software Dinge? =&gt; Performance, Stabilit\u00e4t Beim Ausf\u00fchren bobachtbar.</p>","tags":["cleancode_refactoring"]},{"location":"Software%20Engineering/Clean%20Code/Refaktorisieren/#developmental","title":"Developmental","text":"<p>Wie einfach ist es, die Software zu \u00e4ndern? =&gt; Wartbarkeit Nicht beim Ausf\u00fchren beobachtbar</p>","tags":["cleancode_refactoring"]},{"location":"Software%20Engineering/Clean%20Code/Refaktorisieren/#arten-von-refactorings","title":"Arten von Refactorings","text":"<ul> <li>Rename</li> <li>Extract</li> <li>Inline</li> <li>Move</li> </ul>","tags":["cleancode_refactoring"]},{"location":"Software%20Engineering/Clean%20Code/SOLID/","title":"SOLID","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/SOLID/#solid","title":"SOLID","text":"<p>The SOLID Principles are a part of the Clean Code Principles. The letters stand for:</p> <ul> <li>Single Responsibility Principle</li> <li>Open Closed Principle</li> <li>Liskov Substitution Principle</li> <li>Interface Segragation Principle</li> <li>Dependency Inversion Principle</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Unit%20Test/","title":"Unit Test","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Unit%20Test/#unit-test","title":"Unit Test","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/","title":"Clean Code Developer","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#clean-code-developer","title":"Clean Code Developer","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#die-grade","title":"Die Grade","text":"<ul> <li>Roter Grad</li> <li>Orangener Grad</li> <li>Gelber Grad</li> <li>Gr\u00fcner Grad</li> <li>Blauer Grad</li> <li>Wei\u00dfer Grad</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#wertesystem","title":"Wertesystem","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#wandelbarkeit","title":"Wandelbarkeit","text":"<p>Wir m\u00f6chten diesen Abschnitt mit einer provokant anmutenden These beginnen:</p> <p>Es gibt keine Softwarewartung!</p> <p>Wartung ist ein pro-aktiver Vorgang. In Fertigungsanlagen werden regelm\u00e4\u00dfig Teile getauscht, bevor diese kaputt sind. Sie werden getauscht, weil Erfahrungswerte zeigen, dass die Zuverl\u00e4ssigkeit beim Weiterbetrieb unter einen kritischen Wert sinken w\u00fcrde. Bevor also die ganze Anlage zum Stillstand kommt, werden die kritischen Teile rechtzeitig vorher getauscht. Jeder Autobesitzer wei\u00df, dass er regelm\u00e4\u00dfig einen \u00d6lwechsel vornehmen lassen muss. Nicht etwa, weil das \u00d6l zu dem Zeitpunkt aufgebraucht w\u00e4re, nicht einmal deshalb, weil das \u00d6l zu dem Zeitpunkt bereits v\u00f6llig wirkungslos w\u00e4re. Nein, es wird getauscht, weil Erfahrungswerte des Herstellers zeigen, dass der Motor durch den rechtzeitigen \u00d6lwechsel geschont wird und somit l\u00e4nger h\u00e4lt.</p> <p>All das gibt es bei Software nicht. Software ist so, wie sie ist. Meist enth\u00e4lt sie Fehler. Doch auch diese Fehler sind so, wie sie sind. Man kann nichts pro-aktiv unternehmen, um den Zustand der Software zu verbessern.</p> <p>Nat\u00fcrlich gibt es beim Betrieb der Software pro-aktive Handlungen. So sollte vielleicht regelm\u00e4\u00dfig gepr\u00fcft werden, ob die Logdateien noch ausreichend freien Platz auf der Festplatte lassen, ob eine Datenbank \u00fcberl\u00e4uft oder der Speicher sich zunehmend f\u00fcllt. Aber die Software an sich kann nicht pro-aktiv gewartet werden. Jegliche \u00c4nderung oder Erweiterung findet statt, um einen Fehler zu beseitigen oder neue bzw. ge\u00e4nderte Anforderungen umzusetzen.</p> <p>Damit \u00c4nderungen m\u00f6glich sind, muss die Software eine innere Struktur haben, die solche \u00c4nderungen beg\u00fcnstigt. Dies bezeichnen wir als Wandelbarkeit. Software wird in der Regel \u00fcber lange Zeitr\u00e4ume betrieben. W\u00e4hrend dieser Zeit \u00e4ndern sich die Rahmenbedingungen, m\u00fcssen Features erg\u00e4nzt werden. Im Idealfall kostet die Implementierung eines Features einen festen Betrag, der unabh\u00e4ngig davon ist, wann das Feature realisiert wird.</p> <p>In der Praxis steigt der Preis allerdings f\u00fcr ein Feature, je sp\u00e4ter es realisiert wird. Am Anfang sind Features preiswert, am Ende ist es gar nicht mehr m\u00f6glich Features zu erg\u00e4nzen, weil niemand mehr durchblickt. Die Software wird weggeworfen und neu entwickelt. Bis man an diesem Punkt ankommt, steigen die Kosten exponentiell. Das gemeine an exponentiellem Wachstum sind zwei Dinge: 1.) Anfangs erkennt man kaum, dass die Kosten anwachsen. Die Steigerungen sind moderat. 2.) Wenn man dann erkennt, dass die Kosten steigen, ist es zu sp\u00e4t. Die Steigerung schreitet dann pl\u00f6tzlich so schnell voran, dass ein Gegensteuern nicht mehr m\u00f6glich ist.</p> <p>Je einfacher die Software an ge\u00e4nderte Rahmenbedingungen angepasst werden kann, desto h\u00f6her ist ihre Wandelbarkeit. Doch Wandelbarkeit erh\u00e4lt man nicht nachtr\u00e4glich. Sie muss von vorneherein ber\u00fccksichtigt werden. Die Software muss darauf ausgelegt sein.</p> <p>Dazu ein Beispiel: Klassen sollten genau eine Verantwortlichkeit haben. Ist eine Klasse f\u00fcr mehr als eine Sache zust\u00e4ndig, ist es schwerer sie zu \u00fcberblicken. Das behindert \u00c4nderungen, denn diese bedingen, dass man den Quellcode versteht, der ge\u00e4ndert werden soll. Des weiteren steigt die Kopplung zwischen den Klassen. Pl\u00f6tzlich h\u00e4ngt alles mit allem zusammen. Dies kann nur verhindert werden, indem Funktionseinheiten eine klar definierte Verantwortlichkeit haben und man die Kopplung im Blick beh\u00e4lt. Hat man in einem Softwaresystem eine Reihe von Klassen angesammelt, die jeweils f\u00fcr mehrere Dinge verantwortlich sind, ist es im Nachhinein nur schwer m\u00f6glich, diesen Zustand zu beseitigen. Die Kopplung ist so gro\u00df, dass es schwer f\u00e4llt, einzelne Funktionseinheiten heraus zu l\u00f6sen. Sollen in diesem Dickicht neue Features realisiert werden, ist das sehr aufw\u00e4ndig. Wenn nicht rechtzeitig begonnen wird, das Dickicht zu lichten, wird die Situation mit jedem mal schlimmer. Ab einem gewissen Punkt ist es dann kaum noch m\u00f6glich, neue Features zu erg\u00e4nzen. Der Super-GAU der Softwareentwicklung.</p> <p>Wir meinen, dass es soweit nicht kommen muss. Ber\u00fccksichtigt man Wandelbarkeit von vorne herein, kann Software \u00fcber lange Zeitr\u00e4ume weiter entwickelt werden. Die Kosten pro Feature m\u00f6gen dabei im Laufe der Zeit leicht ansteigen. Aber keinesfalls exponentiell!</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#korrektheit","title":"Korrektheit","text":"<p>Software muss funktional korrekt sein. Ein Buchhaltungsprogramm muss die Buchungen ordnungsgem\u00e4\u00df verbuchen, eine Tabellenkalkulation muss richtig rechnen. Und auch die nicht-funktionalen Anforderungen m\u00fcssen erf\u00fcllt sein. Das Programm muss schonend mit Ressourcen wie Speicher, Prozessorzeit, Plattenplatz, etc. umgehen, die Antwortzeiten m\u00fcssen in einem definierten Rahmen liegen. Erst wenn alle Anforderungen erf\u00fcllt sind, ist die erstellte Software korrekt.</p> <p>Dass Korrektheit erforderlich ist, wird niemand bestreiten. Doch die Frage ist, was konkret daf\u00fcr getan wird. Es reicht unserer Ansicht nach nicht aus, Software nach deren Erstellung durch eine Testabteilung zu leiten, deren Aufgabe es ist, Fehler zu finden. Wir meinen, Korrektheit muss bereits w\u00e4hrend der Entwicklung ber\u00fccksichtigt werden. Bereits die Entwickler m\u00fcssen sich mit der Frage der Korrektheit auseinandersetzen. Und damit sie das \u00fcberhaupt k\u00f6nnen, muss ihnen klar sein, was die Anforderungen sind. Schon daran mangelt es zu oft. Entwickler werden beauftragt, ein Feature zu implementieren, ohne ihnen pr\u00e4zise zu sagen, was die Abnahmekriterien f\u00fcr das Feature sind. Doch hier geht es nicht darum, Schwarzer Peter zu spielen und einen Schuldigen au\u00dferhalb der Entwicklungsabteilungen zu suchen. Schlie\u00dflich ist es die Aufgabe der Entwickler, bei unklaren Anforderungen nachzufragen, statt in ihre Glaskugel zu schauen.</p> <p>Verglichen mit dem Automobilbau steht die Softwareentwicklung beim Thema Korrektheit schlecht da. Ein Auto besteht aus vielen Teilen, deren Korrektheit jeweils einzeln nachgewiesen und \u00fcberpr\u00fcft werden kann. Stellen Sie sich vor, Sie m\u00fcssten zur Fehlersuche mit einem Me\u00dfger\u00e4t in der Hand auf der Motorhaube des Autos sitzen, um dort verfolgen zu k\u00f6nnen, was sich in der Maschine abspielt. Mit Tempo 200 auf der Autobahn. Kommt Ihnen komisch vor? Ein Debugger wird in vielen F\u00e4llen genau so eingesetzt. Das halten wir f\u00fcr falsch.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#produktionseffizienz","title":"Produktionseffizienz","text":"<p>Am Ende spielen nat\u00fcrlich auch die Entwicklungszeit und der Preis der Software eine Rolle. Und der ist h\u00f6her, wenn die Produktion der Software nicht effizient erfolgt. Das beginnt bei manuellen Arbeitsschritten, die nicht automatisiert werden und endet bei hohen Fehlerraten die mehrmaliges Nachbessern erfordern. In letzter Konsequenz bedeutet Produktionseffizienz, dass die Software \u00fcber Jahre oder gar Jahrzehnte weiterentwickelt werden kann, statt irgendwann wieder von vorne beginnen zu m\u00fcssen. Gleichzeitig reduziert eine hohe Produktionseffizienz die Anf\u00e4lligkeit f\u00fcr Fehler.</p> <p>Die Produktionseffizienz als Wert ist ferner wichtig, um die anderen Werte in ein ma\u00dfvolles Verh\u00e4ltnis zu setzen. Wer unendlich viel Aufwand f\u00fcr die Korrektheit treibt, macht am Ende auch etwas falsch.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#kontinuierliche-verbesserung","title":"Kontinuierliche Verbesserung","text":"<p>Ohne R\u00fcckschau ist keine Weiterentwicklung m\u00f6glich. Nur wer reflektiert, wie er eine Aufgabenstellung gel\u00f6st hat, kann feststellen, ob der gew\u00e4hlte Weg einfach oder beschwerlich war. Lernen basiert auf Reflexion.</p> <p>In einer jungen Wissenschaft wie der Informatik ist es wichtig, stets neue Erkenntnisse zu ber\u00fccksichtigen. Dazu ist Reflexion auf allen Ebenen erforderlich. Angefangen beim Reflektieren \u00fcber die Implementation beim Pair Programming oder Code Review, das t\u00e4gliche Reflektieren des Teams, die Reflexion nach jeder Iteration, bis hin zur Reflexion der gesamten Branche \u00fcber ihr Tun. Ohne Reflexion keine Weiterentwicklung.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#prinzipien-und-praktiken","title":"Prinzipien und Praktiken","text":"<p>Das Wertesystem leitet Clean Code Developer in ihrer t\u00e4glichen Arbeit. Es enth\u00e4lt keine Probleml\u00f6sungen, sondern definiert Rahmenbedingungen f\u00fcr Probleml\u00f6sungen. Die vier Werte sind f\u00fcr eine konkrete allt\u00e4gliche Umsetzung jedoch zu abstrakt. Daher haben wir Bausteine zusammengetragen, die jeweils mindestens einen der Werte bef\u00f6rdern. Diese konkreten Bausteine teilen wir in zwei Kategorien: Prinzipien und Praktiken.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#prinzipien","title":"Prinzipien","text":"<p>Die Clean Code Developer Prinzipien sind die grundlegenden Gesetzm\u00e4\u00dfigkeiten f\u00fcr die Strukturierung von Software. Sie sind entweder zu anderen Rahmenbedingungen orthogonal oder ihnen \u00fcbergeordnet. Code sollte immer im Einklang mit einer maximalen Zahl von Prinzipien sein. Nat\u00fcrlich haben sie nicht \u201edie Macht\u201c von Naturgesetzen, denen niemand zuwiderhandeln kann. Aber sie sind mit ihnen in Bezug auf die Softwareentwicklung gleichauf in ihrer Fundamentalit\u00e4t. Wo ein Prinzip nicht eingehalten wird, tritt also nicht unbedingt sofort ein negativer Effekt ein, aber kurz- bis mittelfristig bleiben Zuwiderhandlungen nicht ohne Schmerz. Der dr\u00fcckt sich in M\u00fche beim Codeverst\u00e4ndnis aus oder im hohen Aufwand, um \u00c4nderungen einzubringen. Ultimativ ist er, wenn Software nicht mehr evolvierbar ist. Ob ein Prinzip eingehalten wurde, kann man dem Code immer ansehen.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#praktiken","title":"Praktiken","text":"<p>Praktiken sind Techniken und Methoden, die st\u00e4ndig zum Einsatz kommen. Sie beschreiben, was Clean Code Developer praktisch tun. Motto der Praktiken: \u201eTue es immer so. Jeden Tag, jederzeit.\u201c Es sind handfeste Handlungsanweisungen, die manchmal des Einsatzes von Werkzeugen bed\u00fcrfen. Ob einer Praktik gefolgt wird, kann man dem Code nicht immer ansehen.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#die-tugenden","title":"Die Tugenden","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#prinzipielles","title":"Prinzipielles","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#1-schatze-variation-value-variation-vv","title":"1. Sch\u00e4tze Variation (Value Variation (VV))","text":"<p>Werte: Wandelbarkeit, Kontinuierliche Verbesserung</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#2-tue-nur-das-notigste-do-only-what-s-neccessary-down","title":"2. Tue nur das N\u00f6tigste (Do Only What\u00b4s Neccessary (DOWN))","text":"<p>Werte: Produktionseffizienz, Wandelbarkeit</p> <ul> <li>Vorsicht vor Optimierungen! (Prinzip des\u2003roten Grades)</li> <li>YAGNI (Prinzip des\u2003blauen Grades)</li> <li>KISS (Prinzip des\u2003roten Grades)</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#3-isoliere-aspekte-isolate-aspects-ia","title":"3. Isoliere Aspekte (Isolate Aspects (IA))","text":"<p>Werte: </p> <ul> <li>Wandelbarkeit</li> <li>DRY</li> <li>Separation of Concerns</li> <li>Single Level of Abstraction</li> <li>Single Responsibility Principle</li> <li>Interface Segragation Principle</li> <li>Design and Implementation do not Overlapp</li> <li>Integration Operation Segregation Principle (IOSP)</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#4-minimiere-abhangigkeiten-minimize-dependencies-md","title":"4. Minimiere Abh\u00e4ngigkeiten (Minimize Dependencies (MD))","text":"<p>Werte:</p> <ul> <li>Wandelbarkeit</li> <li>Dependency Inversion Principle</li> <li>Information Hiding Principle</li> <li>Law of Demeter</li> <li>Tell do not ask</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#5-halte-versprechen-ein-honor-pledges-hp","title":"5. Halte Versprechen ein (Honor Pledges (HP))","text":"<p>Werte: </p> <ul> <li>Wandelbarkeit oder auch: Minimize Surprises</li> <li>Liskov Substitution Principle</li> <li>Principle of Least Astonishment</li> <li>Implementation spiegelt Entwurf</li> <li>Favour Composition over Inheritance (FCoI)</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#praktisches","title":"Praktisches","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#1-umarme-unsicherheit-embrace-uncertainty-eu","title":"1. Umarme Unsicherheit (Embrace Uncertainty (EU))","text":"<p>Werte: Wandelbarkeit, Kontinuierliche Verbesserung</p> <p>Ein Versionskontrollsystem einsetzenAutomatisierte IntegrationstestsAutomatisierte Unit TestsMockups (Testattrappen)Continuous IntegrationInversion of Control Container</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#2-fokussiere-focus-f","title":"2. Fokussiere (Focus (F))","text":"<p>Werte: Produktionseffizienz</p> <p>KomponentenorientierungTest firstLimit WIP // neu</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#3-wertschatze-qualitat-value-quality-vq","title":"3. Wertsch\u00e4tze Qualit\u00e4t (Value Quality (VQ))","text":"<p>Werte: Produktionseffizienz</p> <p>Akzeptiere nur hohe Qualit\u00e4t // neuAutomatisierte Unit TestsReviews</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#4-mach-fertig-get-things-done-gtd","title":"4. Mach fertig (Get Things Done (GTD))","text":"<p>Werte: Produktionseffizienz</p> <p>Iterative EntwicklungContinuous DeliveryLimit WIP</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#5-halte-ordnung-stay-clean-sc","title":"5. Halte Ordnung (Stay Clean (SC))","text":"<p>Werte: Wandelbarkeit, Korrektheit, Produktionseffizienz</p> <p>Die Pfadfinderregel beachtenKomplexe RefaktorisierungenEinfache Refaktorisierungsmuster anwendenStatische Codeanalyse (Metriken)Code Coverage AnalyseSource Code Konventionen // ehemals Prinzip</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#6-bleib-am-ball-keep-moving-km","title":"6. Bleib am Ball (Keep Moving (KM))","text":"<p>Werte: Kontinuierliche Verbesserung</p> <p>Lesen, Lesen, LesenTeilnahme an FachveranstaltungenErfahrung weitergebenT\u00e4glich reflektierenRoot Cause AnalysisMessen von FehlernIssue TrackingRegelm\u00e4\u00dfige Retrospektiven // neu</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/#source","title":"Source","text":"<p>Clean Code Developer</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Blauer%20Grad/","title":"Blauer Grad","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Blauer%20Grad/#blauer-grad","title":"Blauer Grad","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Blauer%20Grad/#prinzipien","title":"Prinzipien","text":"<ul> <li>Design and Implementation do not Overlapp</li> <li>Implementation Reflects Design</li> <li>YAGNI</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Blauer%20Grad/#praktiken","title":"Praktiken","text":"<ul> <li>Design before Implementation</li> <li>Continuous Delivery</li> <li>Iterative Development</li> <li>Incremental Development</li> <li>Component Orientation</li> <li>Test First</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Gelber%20Grad/","title":"Gelber Grad","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Gelber%20Grad/#gelber-grad","title":"Gelber Grad","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Gelber%20Grad/#prinzipien","title":"Prinzipien","text":"<ul> <li>Interface Segragation Principle</li> <li>Dependency Inversion Principle</li> <li>Liskov Substitution Principle</li> <li>Principle of Least Astonishment</li> <li>Information Hiding Principle</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Gelber%20Grad/#praktiken","title":"Praktiken","text":"<ul> <li>Automated Unit Tests</li> <li>Mockups</li> <li>Code Coverage Analysis</li> <li>Partizipation in Professional Events</li> <li>Complex Refactorings</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Gr%C3%BCner%20Grad/","title":"Gr\u00fcner Grad","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Gr%C3%BCner%20Grad/#gruner-grad","title":"Gr\u00fcner Grad","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Gr%C3%BCner%20Grad/#prinzipien","title":"Prinzipien","text":"<ul> <li>Open Closed Principle</li> <li>Tell do not ask</li> <li>Law of Demeter</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Gr%C3%BCner%20Grad/#praktiken","title":"Praktiken","text":"<ul> <li>Continuous Integration</li> <li>Statical Code Analysis</li> <li>Inversion of Control Container</li> <li>Share Experience</li> <li>Error Measurement</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Orangener%20Grad/","title":"Orangener Grad","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Orangener%20Grad/#orangener-grad","title":"Orangener Grad","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Orangener%20Grad/#prinzipien","title":"Prinzipien","text":"<ul> <li>Single Level of Abstraction</li> <li>Single Responsibility Principle</li> <li>Separation of Concerns</li> <li>Source Code Conventions</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Orangener%20Grad/#praktiken","title":"Praktiken","text":"<ul> <li>Issue Tracking</li> <li>Automated Integrationtests</li> <li>Read, Read, Read</li> <li>Code Reviews</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Roter%20Grad/","title":"Roter Grad","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Roter%20Grad/#roter-grad","title":"Roter Grad","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Roter%20Grad/#prinzipien","title":"Prinzipien","text":"<ul> <li>DRY</li> <li>KISS</li> <li>Beware of Premature Optimization</li> <li>Favour Composition over Inheritance</li> <li>Integration Operation Segregation Principle (IOSP)</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Roter%20Grad/#praktiken","title":"Praktiken","text":"<ul> <li>Boy Scout Rule</li> <li>Root Cause Analysis</li> <li>Version Control System</li> <li>Simple Refactorings</li> <li>Daily Reflection</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Wei%C3%9Fer%20Grad/","title":"Wei\u00dfer Grad","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Grade/Wei%C3%9Fer%20Grad/#weier-grad","title":"Wei\u00dfer Grad","text":"<p>Vereinigung aller Prinzipien und Praktiken</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Automated%20Integrationtests/","title":"Automated Integrationtests","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Automated%20Integrationtests/#automated-integrationtests","title":"Automated Integrationtests","text":"<p>Warum? Integrationstests stellen sicher dass der Code tut was er soll. Diese wiederkehrende T\u00e4tigkeit nicht zu automatisieren w\u00e4re Zeitverschwendung.</p> <p>Die fundamentale Voraussetzung f\u00fcr jegliche \u00c4nderungen am Code haben wir bereits im\u2003Roten Grad\u2003durch den Einsatz eines Versionskontrollsystems gelegt. Wir k\u00f6nnen ohne Sorge \u00c4nderungen am Code vornehmen, ganze Dateien und Verzeichnisse l\u00f6schen, durch das Versionskontrollsystem ist alles wieder abrufbar.</p> <p>Wenn wir nun \u00c4nderungen am Code vornehmen, sollten wir uns sicher sein, dass wir dabei nichts kaputt machen. Und diese Sicherheit k\u00f6nnen wir nur erlangen, wenn wir nach der \u00c4nderung testen, ob die Anwendung sich noch so verh\u00e4lt wie zuvor. Diese Tests nach jeder \u00c4nderung per Hand durchzuf\u00fchren w\u00e4re nicht praktikabel, wir m\u00fcssen sie automatisieren. Ein gro\u00dfes \u00dcbel der Softwareentwicklung ist die Angst, bei \u00c4nderungen am Code etwas zu \u00fcbersehen, ein Detail nicht zu ber\u00fccksichtigen, und dadurch einen Fehler zu verursachen in Code der vorher funktionierte. Dabei spielt es in der Regel sogar nicht mal eine Rolle, ob die \u00c4nderungen dazu f\u00fchren sollen, dass der Code verbessert wird (Refaktorisieren) oder zus\u00e4tzliche Anforderungen umgesetzt werden sollen. Solange wir nach Durchf\u00fchren einer \u00c4nderung nicht sicher sind, dass alles noch so funktioniert wie zuvor, bleibt die Angst. Diese f\u00fchrt dazu, dass wir Code im Zweifelsfall so belassen, wie er ist, denn er funktioniert ja. Notwendige Refaktorisierungen werden unterlassen, aus Angst Fehler zu machen.</p> <p>Damit wir uns auch in schon laufenden Projekten (sogenannte\u2003Brownfield\u2003Projekte, im Gegensatz zu\u2003Greenfield\u2003\u201eauf der gr\u00fcnen Wiese\u201c) dieses Sicherheitsnetz schaffen k\u00f6nnen, ben\u00f6tigen wir Verfahren, die auf vorhandenen Code angewendet werden k\u00f6nnen. Dazu eignen sich automatisierte Integrationstests. Sie setzen entweder ganz oben auf der Benutzerschnittstelle auf und testen die Anwendung durch alle Layer oder setzen weiter unten auf. In jedem Fall werden mehrere Funktionseinheiten im Zusammenspiel getestet.</p> <p>Bevor wir also \u00c4nderungen oder Erweiterungen am Code vornehmen, erstellen wir f\u00fcr die betroffenen Codebereiche Integrationstests. Dabei k\u00f6nnen Tools und Techniken wie WatiN, UI Automation, etc. verwendet werden. W\u00fcnschenswert sind nat\u00fcrlich auch Unit Tests, welche einzelne Funktionseinheiten isoliert testen. Dazu muss der Code allerdings Voraussetzungen erf\u00fcllen, die vermutlich nicht immer gegeben sind: der Code muss bereits das\u2003 Single Responsibility Principle\u2003ber\u00fccksichtigen. Andernfalls sind die Abh\u00e4ngigkeiten zwischen den Funktionseinheiten (Komponenten, Klassen oder Methoden) so gro\u00df, dass sie nicht isoliert getestet werden k\u00f6nnen. Das Fernziel ist nat\u00fcrlich eine Codebasis, bei der Unit Tests m\u00f6glich sind. Mehr noch: wir werden in Zukunft die Tests vor der Implementierung erstellen (Test first). Aber um durch Refaktorisierungen dorthin zu gelangen, bedarf es erst der Integrationstests, um sicherzustellen, dass die Anwendung sich noch so verh\u00e4lt wie vor der Refaktorisierung.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Automated%20Unit%20Tests/","title":"Automated Unit Tests","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Automated%20Unit%20Tests/#automated-unit-tests","title":"Automated Unit Tests","text":"<p>Warum? Nur automatisierte Tests werden auch wirklich konsequent ausgef\u00fchrt. Je punktgenauer sie Code testen, desto besser.</p> <p>Im\u2003Orangenen Grad\u2003haben wir Integration Tests eingef\u00fchrt, nun geht es um Unit Tests. Im Gegensatz zu Integrationstests wird bei Unit Tests eine einzelne Funktionseinheit (vor allem Klassen, aber auch Methoden oder Komponenten) isoliert getestet. Dazu ist es erforderlich, diese Funktionseinheit von ihren Abh\u00e4ngigkeiten befreien zu k\u00f6nnen. Sollen Unit Tests im Nachhinein f\u00fcr bestehenden Code erg\u00e4nzt werden, sind h\u00e4ufig Refaktorisierungen erforderlich. Wir haben durch die Integrationstests die Sicherheit, dass wir dabei keine Fehler einbauen.</p> <p>Automatisierte Tests bieten zweifachen Nutzen:</p> <ul> <li>Sie sparen Zeit</li> <li>Sie nehmen Angst</li> </ul> <p>Je st\u00e4rker eine Codebasis in Ver\u00e4nderung begriffen ist, desto eher ist die Zeitersparnis zu sp\u00fcren. Denn wo Code sich ver\u00e4ndert, muss immer wieder Neues und auch Altes (Regressionstests) getestet werden. Da spart Automatisation einfach Zeit. Und je komplexer der Code, desto gr\u00f6\u00dfer ist die Angstreduktion. Denn wenn komplexer Code ver\u00e4ndert werden soll \u2013 um Funktionalit\u00e4t hinzuzuf\u00fcgen, ihn zu optimieren oder schlicht zu korrigieren \u2013, da besteht hohe Gefahr, ungewollt Fehler einzuf\u00fchren. Kleinschrittige automatisierte Tests decken diese jedoch auf, sodass kein Grund zur Angst besteht, zu \u201everschlimmbessern\u201c.</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Boy%20Scout%20Rule/","title":"Boy Scout Rule","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Boy%20Scout%20Rule/#boy-scout-rule","title":"Boy Scout Rule","text":"<p>Warum? Jede Besch\u00e4ftigung mit einem Gegenstand macht ihn zumindest ein klein wenig besser. Ganz ohne b\u00fcrokratische Planung. Fundament und Graswurzelansatz f\u00fcr mehr Qualit\u00e4t.</p> <p>Das Clean Code Developer Wertesystem l\u00e4sst sich nicht mit einem Mal etablieren. Daf\u00fcr braucht es Zeit. Vor allem, da ein Clean Code Developer selten auf einer gr\u00fcnen Wiese und auch noch allein arbeitet, ist es schwer, die Prinzipien auf eine gesamte Codebasis anzuwenden. Wir glauben daher, dass es wichtig ist, sich nicht zu hohe Ziele zu setzen. Viel realistischer und motivierender ist es, nur kleine Fortschritte anzustreben \u2013 daf\u00fcr aber kontinuierliche.</p> <p>Zum Fundament des Clean Code Development geh\u00f6rt deshalb f\u00fcr uns die Pfadfinderregel. Sie findet sich auch in\u2003Clean Code\u2003und lautet:\u2003</p> <p>Hinterlasse einen Ort immer in einem besseren Zustand als du ihn vorgefunden hast.</p> <p>Auf die Softwareentwicklung angewandt bedeutet das: Clean Code Developer hinterlassen Code immer in einem \u201ebesseren Zustand\u201c als sie ihn vorgefunden haben. Nach getaner Arbeit stimmt der Code also mit dem Clean Code Development Wertesystem mehr \u00fcberein als vorher.</p> <p>Was ein Clean Code Developer an ihm daf\u00fcr getan hat, ist situations-/codeabh\u00e4ngig \u2013 und wird nat\u00fcrlich auch durch den Grad bestimmt, an dem er arbeitet. Im Roter Grad achtet ein Clean Code Developer z.B. darauf, dass Code, der noch nicht im Repository der Versionsverwaltung war, nun auch dort abgelegt ist. Und er achtet darauf, dass Wiederholungen jeder Art \u2013 also Verletzungen des DRY-Prinzips \u2013 \u201eausgeb\u00fcgelt\u201c werden.</p> <p>Wo ein Clean Code Developer Suboptimalit\u00e4ten im Sinne des CCD-Wertesystems feststellt, bem\u00fcht er sich also stetig darum, sie zu verbessern. In kleinen Schritten. Und nat\u00fcrlich bem\u00fcht er sich, Suboptimalit\u00e4ten von vornherein zu vermeiden. Wie gesagt: immer auf der Stufe seiner Entwicklung.</p> <p>Diese Maxime steht am Anfang der Entwicklung des Clean Code Developers eingedenk der\u2003Broken Windows Theorie. Nach ihr beginnt der Verfall von Qualit\u00e4t im allgemeinen Sinn mit Kleinigkeiten, die nur lange genug unbeachtet bleiben.</p> <p>Wenn Clean Code Developer jedoch nach der Pfadfinderregel arbeiten, kommt es gar nicht erst zu \u201eBroken Windows\u201c \u2013 vorhandene werden eines nach dem anderen repariert. \u201eRisse und Unebenheiten\u201c im Code schlie\u00dft die Pfadfinderregel konsequent auf der Basis des CCD-Wertesystems, sodass sich keine weiteren \u201eAblagerungen\u201c ansammeln k\u00f6nnen. Sie wirkt damit proaktiv einer Code-Erosion entgegen. Das halten wir f\u00fcr so fundamental, dass wir sie in den roten Grad aufgenommen haben.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Code%20Coverage%20Analysis/","title":"Code Coverage Analysis","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Code%20Coverage%20Analysis/#code-coverage-analysis","title":"Code Coverage Analysis","text":"<p>Warum? Traue nur Tests, von denen du wei\u00dft, dass sie auch wirklich das Testareal abdecken.</p> <p>Unit Tests sollten nach M\u00f6glichkeit alle Pfade durch unseren Code abdecken. Nur so gewinnen wir das Vertrauen, dass der Code korrekt arbeitet. Um in Erfahrung zu bringen, welche Codebereiche bislang nicht durch Tests abgedeckt sind, bedienen wir uns der\u2003Code Coverage Analyse. Diese dient dazu, Bereiche im Code aufzudecken, die noch nicht w\u00e4hrend der automatisierten Tests ausgef\u00fchrt werden.</p> <p>Unit Tests sollten eigentlich 100% des zu testenden Codes abdecken. Zwar bedeutet das nicht automatisch, dass gen\u00fcgend Tests existieren, doch weniger als 100% Code Coverage zeigen an, dass es noch Taschen von Code gibt, \u00fcber die \u00fcberhaupt noch keine Korrektheitsaussage gemacht werden kann. 100% Codeabdeckung sind deshalb immer anzustreben.</p> <p>In der Praxis zeigt es sich jedoch, dass 100% Codeabdeckung nicht immer mit unmittelbar vertretbarem Aufwand erreicht werden k\u00f6nnen. Wie auch sonst im Leben kann die M\u00fche f\u00fcr die letzten 2,3,4 Prozent \u00fcberproportional wachsen. Deshalb kann es nach genauer Analyse der Abdeckungslage akzeptabel sein, mit weniger als 100% zufrieden zu sein.</p> <p>Unterhalb von 90% ist die Abdeckung dann allerdings so l\u00f6chrig, dass sie als unprofessionell anzusehen ist. Wer also mit automatischen Tests beginnt, sollte immer auch gleichzeitig die Codeabdeckung messen. Sonst l\u00e4sst sich keine Aussage \u00fcber die Qualit\u00e4t der Tests machen.</p> <p>F\u00fcr die Messung der Code\u00fcberdeckung gibt es zwei einfache Kennzahlen, die als C0- und C1-Kennzahlen bezeichnet werden. Die C0-Kennzahl misst die Anweisungs\u00fcberdeckung, wogegen die C1-Kennzahl die Entscheidungs\u00fcberdeckung bzw. die Zweig\u00fcberdeckung misst.</p> <pre><code>C0 = (Anzahl der getesteten Anweisungen / Anzahl der gesamten Anweisungen) * 100%\n</code></pre> <pre><code>C1 = (Anzahl der getesteten Entscheidungen bzw. Zweige / Anzahl der gesamten Entscheidungen bzw. Zweige) * 100%\n</code></pre> <p>C1 ist dabei die st\u00e4rkere Kennzahl, da 100% Entscheidungs\u00fcberdeckung bzw. Zweig\u00fcberdeckung 100% Anweisungs\u00fcberdeckung impliziert. Der Umkehrschluss gilt nicht.</p> <p>Der Anweisungs\u00fcberdeckungstest sowie der Zweig\u00fcberdeckungstest arbeiten auf Basis eines Kontrollflussgraphen w\u00e4hrend der Entscheidungs\u00fcberdeckungstest direkt auf dem Quellcode basiert. Die Testverfahren Anweisungs\u00fcberdeckungstest und Zweig\u00fcberdeckungstest sind sehr gut unter\u2003http://de.wikipedia.org/wiki/Kontrollflussorientierte_Testverfahren\u2003beschrieben.</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Code%20Reviews/","title":"Code Reviews","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Code%20Reviews/#code-reviews","title":"Code Reviews","text":"<p>Warum? Vier Augen sehen mehr als zwei. Wenn der eine Entwickler dem anderen seinen Code erkl\u00e4rt, tauchen meist Details auf, die bislang nicht bedacht wurden.</p> <p>Reviews kommen vereinfacht in zwei Spielarten daher: als kontinuierlicher Prozess beim Pair Programming, als eigenst\u00e4ndiger Prozessschritt beim Code Review. Das Ziel ist in beiden F\u00e4llen das gleiche: der Code soll von einem zweiten Entwickler begutachtet werden. Dies beugt der \u201eBetriebsblindheit\u201c vor. Schon die Tatsache dass ein Entwickler seinen Code einem anderen Entwickler vorstellt und beschreibt, f\u00fchrt zu Aha Erlebnissen.</p> <p>In der Regel wird erst durch die Diskussion mit anderen Entwicklern deutlich, wo die St\u00e4rken und Schw\u00e4chen einer Codebasis liegen. Gerade der Prozess der st\u00e4ndigen Verbesserung bedingt es, sich mit der Sichtweise anderer Entwickler auseinander zu setzen.</p> <p>Selbstverst\u00e4ndlich ist nicht nur der Quellcode eine geeignete Basis f\u00fcr Reviews. Sie bieten eine g\u00fcnstige M\u00f6glichkeit, die Ergebnisse jeder Entwicklungst\u00e4tigkeit zu \u00fcberpr\u00fcfen, sofern sie in einem \u201elesbaren\u201c Ergebnis m\u00fcnden. Neben rein informellen Reviews, wie dem Pair Programming oder der Begutachtung durch eine zweite Person gibt es auch das formale Review mit einem Reviewprozess sowie entsprechenden Rollen. Weitere bekannte Arten des Review sind z.B. Walkthrough, Technisches Review, Peer Review und Inspektion.</p> <p>Reviews erg\u00e4nzen dynamische Tests, wie z.B. den automatischen Unit Test oder den automatischen Integrationstest aus dem\u2003Gelben Grad\u2003bzw.\u2003Orangenen Grad Im Gegensatz zu diesen Tests, sind Reviews auch sehr gut geeignet, Fehler in den Anforderungen zu finden. Auch k\u00f6nnen sie bereits sehr fr\u00fch im Entwicklungsprozess eingesetzt und Fehler dadurch auch sehr fr\u00fch gefunden werden. Und um so fr\u00fcher Fehler gefunden werden, um so g\u00fcnstiger ist auch deren Beseitigung.</p> <p>An den orangen Grad schlie\u00dft sich der\u2003Gelbe Grad an.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Complex%20Refactorings/","title":"Complex Refactorings","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Complex%20Refactorings/#complex-refactorings","title":"Complex Refactorings","text":"<p>Warum? Es ist nicht m\u00f6glich, Code direkt in der ultimativen Form zu schreiben.</p> <p>Bereits imroten Grad sind einfache Refaktorisierungen eingef\u00fchrt worden. Doch\u2003Umbenennen\u2003und\u2003Methode extrahieren\u2003reichen nicht aus, um den Code zu verbessern \u2013 oft sind gr\u00f6\u00dfere Eingriffe erforderlich. Die Einteilung in einfache und komplexe Refaktorisierungen ist sinnvoll, weil komplexe Refaktorisierungen nur mit vorhandenen automatisierten Tests effizient und risikolos zu bewerkstelligen sind. Ohne Tests w\u00e4re nach dem Refaktorisierungen nicht bekannt, ob der Code immer noch korrekt ist.</p> <p>Siehe auch unter\u2003refactoring-legacy-code.net\u2003sowie unter\u2003Tools.</p> <p>Weiter geht es beim\u2003gr\u00fcnen Grad</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Component%20Orientation/","title":"Component Orientation","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Component%20Orientation/#component-orientation","title":"Component Orientation","text":"<p>Warum? Software braucht Black-Box-Bausteine, die sich parallel entwickeln und testen lassen. Das f\u00f6rdert Wandelbarkeit, Produktivit\u00e4t und Korrektheit.</p> <p>Die Prinzipien des\u2003CCD-Wertesystems\u2003haben sich bisher vor allem auf kleinere Codeausschnitte bezogen. Was sollte in einer Methode stehen, was sollte \u00fcber mehrere verteilt werden? Welche Methoden sollte eine Klasse ver\u00f6ffentlichen? Woher sollte ein Client-Objekt zu einem Service-Objekt kommen? Bisher ging es um Prinzipien f\u00fcr die Softwareentwicklung im Kleinen.</p> <p>Hat das CCD-Wertesystem denn aber nichts zu gr\u00f6\u00dferen Strukturen, zur Softwareentwicklung im Gro\u00dfen zu sagen? Wie steht es mit der Softwarearchitektur? Genau hier setzt das Prinzip der Komponentenorientierung an. Bisher haben wir zwar auch schon das Wort \u201eKomponente\u201c gebraucht, doch eher lax und in einem umgangssprachlichen Sinn. Von nun an jedoch soll\u2003Komponente\u2003etwas sehr spezifisches beschreiben, das wir f\u00fcr grundlegend f\u00fcr evolvierbare Software halten.</p> <p>Solange wir Software letztlich nur aus Klassen mit Methoden aufgebaut denken, versuchen wir sozusagen Computer auf Transistorebene zu beschreiben. Das funktioniert letztlich aber nicht, weil wir im Detailreichtum ersticken. Selbst die Klassen in Schichten zusammenzufassen hilft da nicht viel. Wir brauchen vielmehr sowohl ein Beschreibungsmittel f\u00fcr gr\u00f6\u00dfere Softwarestrukturen. Aber nicht nur das: das Beschreibungsmittel sollte auch ein Implementationsmittel sein \u2013 so wie Klassen -, damit das Modell, der Plan, die Beschreibung sich im Code widerspiegelt.</p> <p>Betriebssystemprozesse sind zwar solche architektonischen Mittel, letztlich sind auch sie jedoch zu gro\u00df. Solange die EXE eines Prozesses einer Applikation aus mehreren Hundert oder Tausend Klassen besteht, gewinnen wir nichts.</p> <p>Hilfe bringt allerdings das Prinzip der Komponentenorientierung. Es besagt, dass ein Anwendungsprozess zun\u00e4chst einmal aus Komponenten besteht und nicht aus Klassen. Erst die Bausteine der Komponenten sind dann Klassen. Und was ist eine Komponente? Es gibt einige Definitionen f\u00fcr Komponenten, von denen im Kern zwei Kriterien unverbr\u00fcchlich erscheinen:</p> <ul> <li>Komponenten sind bin\u00e4re Funktionseinheiten. (Eine Klasse hingegen ist eine Funktionseinheit auf Quellcodeebene.)</li> <li>Die Leistung von Komponenten wird durch einen separaten (!) Kontrakt beschrieben. (Die Leistungsbeschreibung einer Klasse liegt hingegen in ihr. Es ist die Summe ihrer Methodensignaturen.)</li> </ul> <p>Ein CCD sucht beim Entwurf einer Software nach der Definition der Prozesse also zun\u00e4chst nach den Komponenten, aus denen die Prozesse bestehen sollten. Er fragt sich, welche \u201eDienstleistungsbl\u00f6cke\u201c machen die Anwendung aus? Und diese Bl\u00f6cke sieht der CCD als Black Boxes in Bezug auf ihren Aufbau aus Klassen an. Diese Bl\u00f6cke sind Assemblies mit wohldefinierter Dienstleistung, aber unbekannter Struktur.</p> <p>Eine Client-Komponente C wei\u00df daher nichts \u00fcber die Klassenstruktur ihrer Service-Komponente S. C kennt nur den Kontrakt von S, der unabh\u00e4ngig von der Implementation von S ist. Kontrakte sind insofern f\u00fcr Komponenten das, was Interfaces f\u00fcr Klassen sind. Nicht zuf\u00e4llig bestehen Kontrakte zu einem guten Teil oder gar vollst\u00e4ndig aus Interfaces.</p> <p>Komponenten sind also Elemente der Planung wie auch der Implementation. Um das zu unterstreichen, werden Komponenten physisch unabh\u00e4ngig voneinander implementiert; ein probates Mittel daf\u00fcr sind\u2003Komponentenwerkb\u00e4nke, d.h. separate Visual Studio Solutions je Komponentenimplementation. Das f\u00f6rdert nicht nur die Konzentration auf eine Aufgabe, weil man w\u00e4hrend der Arbeit an einer Komponente in der IDE nur deren Code sieht. Dar\u00fcber hinaus f\u00f6rdert es auch konsequente Unit Tests unter Einsatz von Attrappen, da Quellcode anderer Komponenten nicht sichtbar ist. Au\u00dferdem steigert solche Codeorganisation die Produktivit\u00e4t, weil Komponenten dank ihrer separaten Kontrakte parallel implementiert werden k\u00f6nnen. Und schlie\u00dflich stellt sich eine physische Isolation gegen den schleichenden Zuwachs an Entropie im Code. Denn wo Bindungen zwischen Komponenten nur via Kontrakt aufgebaut werden k\u00f6nnen, ist die Kopplung lose und kontrolliert.</p> <p>Zur Komponentenorientierung geh\u00f6ren deshalb nicht nur bin\u00e4re, gr\u00f6\u00dfere Codeeinheiten mit separaten Kontrakten, sondern auch die Entwicklung der Kontrakte vor der Implementation (Contract-first Design). Denn sobald die Kontrakte definiert sind, die eine Komponente importiert und exportiert, kann die Arbeit an der Komponente unabh\u00e4ngig von allen anderen beginnen.</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Continuous%20Delivery/","title":"Continuous Delivery","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Continuous%20Delivery/#continuous-delivery","title":"Continuous Delivery","text":"<p>Warum? Als Clean Code Developer m\u00f6chte ich sicher sein, dass ein Setup das Produkt korrekt installiert. Wenn ich das erst beim Kunden herausfinde, ist es zu sp\u00e4t.</p> <p>Im\u2003gr\u00fcnen Grad\u2003haben wir den Continuous Integration Prozess f\u00fcr Build und Test aufgesetzt. Damit sorgt der Continuous Integration Prozess daf\u00fcr, dass Fehler w\u00e4hrend der Build- und Testphase schnell entdeckt werden. Wenn z.B. eine \u00c4nderung am Code dazu f\u00fchrt, dass eine andere Komponente nicht mehr \u00fcbersetzt werden kann, weist der Continuous Integration Prozess kurze Zeit nach dem Commit der \u00c4nderung auf den Fehler hin. Wenn am Ende jedoch ein Setup Programm produziert wird, welches sich aufgrund von Fehlern nicht installieren l\u00e4sst, haben wir unser Ziel trotzdem nicht erreicht: funktionierende Software die bei unseren Kunden installiert werden kann.</p> <p>Folglich m\u00fcssen wir auch die Phasen Setup und Deployment automatisieren, um sie per Knopfdruck ausf\u00fchren zu k\u00f6nnen. Nur so k\u00f6nnen wir sicher sein, dass wir installierbare Software produzieren. Und durch die Automatisierung ist sichergestellt, dass niemand einen wichtigen Schritt, der \u201ezu Fu\u00df\u201c ausgef\u00fchrt werden muss, vergisst. So kann jeder im Team zu jedem Zeitpunkt den aktuellen Stand des Produktes installationsfertig produzieren und installieren.</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Continuous%20Integration/","title":"Continuous Integration","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Continuous%20Integration/#continuous-integration","title":"Continuous Integration","text":"<p>Warum? Automatisierung und Zentralisierung der Softwareproduktion machen produktiver und reduzieren das Risiko von Fehlern bei der Auslieferung.</p> <p>Oft wird die Integration der Softwarekomponenten zeitlich nach hinten geschoben und erfolgt aufwendig und fehleranf\u00e4llig \u201eper Hand\u201c. Eigentlich sollte die Software aber zu jedem Zeitpunkt vollst\u00e4ndig lauff\u00e4hig sein. Mit Continuous Integration bezeichnet man einen Prozess, der daf\u00fcr sorgt dass der gesamte Code nach der \u00dcbermittlung von \u00c4nderungen \u00fcbersetzt und getestet wird.</p> <p>Der Continuous Integration Prozess ist vor allem f\u00fcr Teams wichtig, denn er sorgt daf\u00fcr, dass nach der \u00dcbermittlung von \u00c4nderungen der gesamte Code \u00fcbersetzt und getestet wird, nicht nur der Teil an dem ein Entwickler gerade gearbeitet hat. Die automatisierten Tests sollten von jedem Entwickler ausgef\u00fchrt werden bevor er \u00c4nderungen in die zentrale Versionskontrolle \u00fcbermittelt. Daran \u00e4ndert sich durch Continuous Integration nichts. Um sicherzustellen, dass die Tests tats\u00e4chlich ausgef\u00fchrt werden und Fehler fr\u00fchzeitig erkannt werden, laufen sie in jedem Fall auf dem Continuous Integration Server. Dies entbindet den Entwickler nicht davon die Tests vor dem Commit auszuf\u00fchren, schlie\u00dflich behindert fehlerhafter Code der in die Versionskontrolle eingecheckt wurde das gesamte Team, m\u00f6glicherweise sogar weitere Teams. So sorgt der Continuous Integration Prozess daf\u00fcr dass team\u00fcbergreifend sichergestellt wird dass Fehler so fr\u00fch wie m\u00f6glich erkannt werden.</p> <p>F\u00fcr den Continuous Integration Prozess stehen zahlreiche\u2003Softwaretools\u2003zur Verf\u00fcgung. Neben dem kontinuierlichen Build und Test, der sofort erfolgt, wenn \u00c4nderungen in die Versionskontrolle \u00fcbertragen werden, k\u00f6nnen durch Continuous Integration auch l\u00e4nger laufende Prozesse, wie z.B. Datenbanktests, automatisiert werden. Diese werden dann z.B. nur nachts ausgef\u00fchrt. Im gr\u00fcnen Grad wird lediglich der Build- und Testprozess ber\u00fccksichtigt. Das kontinuierliche Setup und Deployment der Software folgt erst sp\u00e4ter im\u2003blauen Grad.</p> <p>Martin Fowler hat einen sehr guten Artikel zu diesem Thema verfasst, nachzulesen unter\u2003http://www.martinfowler.com/articles/continuousIntegration.html</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Daily%20Reflection/","title":"Daily Reflection","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Daily%20Reflection/#daily-reflection","title":"Daily Reflection","text":"<p>Warum? Keine Verbesserung, kein Fortschritt, kein Lernen ohne Reflexion. Aber nur, wenn Reflexion auch eingeplant wird, findet sie unter dem Druck des Tagesgesch\u00e4ftes auch statt.</p> <p>Im Zentrum von CCD steht die pers\u00f6nliche Entwicklung. Es geht also um Ver\u00e4nderung: Mit jedem Tag soll sich das CCD-Wertesysten ein klein wenig mehr im Projektalltag des Clean Code Developers manifestieren. Das ist die Pfadfinderregel des CCDs auf sich selbst angewandt.</p> <p>So ein Ver\u00e4nderungsweg geht sich allerdings gerade allein nicht leicht. Wie also auf Kurs bleiben? Wie Fortschritt messen?</p> <p>Ohne ein \u201eKontrollsystem\u201c etablieren zu wollen, glauben wir, dass dazu zweierlei geh\u00f6rt:</p> <ol> <li>Kleinschrittige Planung</li> <li>Reflexion nach jedem Schritt</li> </ol> <p>Unabh\u00e4ngig von Vorgaben durch eine Projektleitung sollten Clean Code Developer ihre Arbeit so einteilen, dass sie aus Aufgaben besteht, die an einem Arbeitstag zu bew\u00e4ltigen sind. Nur so kann am Abend jedes Tages eine Bilanz gezogen werden. Das halten wir f\u00fcr wichtig, um jeden Tag die Arbeit nicht mit in den Feierabend zu tragen. Da hat sie nichts zu suchen; der dient der Entspannung.</p> <p>Durch solche kleinen Planungsschritte wird der Arbeitsalltag allerdings nicht nur befriedigender, weil sich jeden Tag \u00fcber Erfolg oder Misserfolg entscheiden l\u00e4sst. Die schiere M\u00f6glichkeit der Entscheidung am Abend \u2013\u2003Habe ich alle meine Aufgaben erledigt? Wie habe ich meine Aufgaben erledigt?\u2003\u2013 erlaubt auch die Reflexion \u00fcber die Einhaltung des CCD-Wertesystems.</p> <p>Um sich konsequent zu einem CCD zu entwickeln, soll der Entwickler sich auf jedem Grad nach jedem Arbeitstag dar\u00fcber Rechenschaft ablegen, ob er alle f\u00fcr ihn nach Grad relevanten Aspekte des Wertesystems ber\u00fccksichtigt hat. F\u00fcr den roten Grad bedeutet das z.B. Fragen wie: Verwalte ich wirklich alle Codefragmente im Versionskontrollsystem? Habe ich das DRY-Prinzip konsequent angewandt? Habe ich ganz allgemein Code in einem besseren Zustand hinterlassen als vorgefunden?</p> <p>Wenn er auf eine dieser Fragen nur z\u00f6gerlich mit Ja oder gar mit einem Nein antworten muss, dann ist das nat\u00fcrlich kein Beinbruch. Bei allem Bem\u00fchen klappt es eben nicht immer, dass man den guten Willen auch in die Tat umsetzen kann.</p> <p>Dennoch oder gerade deshalb ist dann allerdings Folgendes zu tun:</p> <ul> <li>Entweder bessert der CCD jetzt solange nach, bis er in Bezug auf seines Tages Arbeit keine Prinzipienverletzung mehr wahrnimmt.</li> <li>Oder er nimmt die erkannten Prinzipienverletzungen f\u00fcr den n\u00e4chsten Tag auf seinen Aufgabenzettel.</li> </ul> <p>Eine Hilfe bei der Reflexion kann das CCD Armband\u2003sein. Uns ist bewusst, dass es nicht jedermanns Sache ist, ein buntes Silikonarmband zu tragen. Wer damit kein Problem hat, kann das Armband im Rahmen der pers\u00f6nlichen Reflexion nutzen. Kann oder will der CCD die Prinzipienverletzung nicht bereinigen oder auf seinen Arbeitszettel nehmen, sollte er das Armband, das er tr\u00e4gt, vom einen auf den anderen Arm wechseln. So macht er deutlich, dass er eine Differenz zwischen dem Soll seines Grades und dem Geschafften anerkennt. Das ist nicht als Niederlage misszuverstehen oder gar als \u201eBu\u00dfe\u201c. Es geht vielmehr um eine haptische Unterst\u00fctzung des Lernvorgangs.</p> <p>Wenn ein CCD 21 Tage lang nach getaner Arbeit das Armband nicht mehr wechseln musste, kann er zur Arbeit am n\u00e4chsten Grad \u00fcbergehen. F\u00fcr den roten Grad ist das der\u2003orange Grad.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Design%20before%20Implementation/","title":"Design before Implementation","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Design%20before%20Implementation/#design-before-implementation","title":"Design before Implementation","text":"<p>Warum? Vor der Umsetzung muss eine L\u00f6sung entworfen werden. Andernfalls findet kein konsequentes Nachdenken \u00fcber die L\u00f6sung statt.</p> <p>Die Aufgabe eines Entwicklers besteht darin, Anforderungen in Code zu \u00fcbersetzen. Dazu ist es erforderlich, eine L\u00f6sung f\u00fcr die Anforderungen zu entwickeln. Es muss nachgedacht werden. Wie kann das aber auf gute Weise geschehen, wenn Entwickler direkt ins Codieren springen?</p> <p>In trivialen F\u00e4llen mag es m\u00f6glich sein, direkt Code zu schreiben. Dennoch wird auch beim unmittelbaren Sprung ins Codieren \u00fcber die L\u00f6sung nachgedacht. Allerdings geschieht dies eher unbewusst, vor allem aber\u2003w\u00e4hrend\u2003der Umsetzung. Der Entwickler denkt ein wenig nach, codiert, denk nach, codiert, usw. Es fehlt hier ein konsequentes Durchdenken der L\u00f6sung, getrennt von der Umsetzung.</p> <p>Sp\u00e4testens, wenn eine Gruppe von Entwicklern gemeinsam als Team arbeiten m\u00f6chte, muss der Entwurf zeitlich getrennt von der Umsetzung stattfinden. Andernfalls ist keine fl\u00fcssige arbeitsteilige Vorgehensweise m\u00f6glich.</p> <p>Der Entwurf erm\u00f6glicht es dem Team bzw. einem einzelnen Entwickler, bereits vor der Codierung \u00fcber wichtige Prinzipien nachzudenken. Es entstehen bspw. erst gar keine Methoden oder Klassen mit mehreren Verantwortlichkeiten, da schon auf der Ebene des Entwurfs \u00fcber das\u2003Single Responsibility Principle\u2003nachgedacht werden kann. Damit erspart sich das Team den Refaktorisierungsaufwand der entsteht, wenn \u201edrauf los\u201c codiert wird.</p> <p>Siehe auch\u2003https://flow-design.info.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Error%20Measurement/","title":"Error Measurement","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Error%20Measurement/#error-measurement","title":"Error Measurement","text":"<p>Warum? Nur wer wei\u00df, wie viele Fehler auftreten, kann sein Vorgehen so ver\u00e4ndern, dass die Fehlerrate sinkt.</p> <p>W\u00e4hrend der Softwareentwicklung passieren Fehler. Die passieren in allen Phasen: falsch verstandene oder unklar formulierte Anforderungen f\u00fchren zu Fehlern genauso wie fehlerhafte Implementierungen. Am Ende ist alles ein Fehler, was dazu f\u00fchrt, dass der Kunde eine Software erh\u00e4lt, die nicht seinen Anforderungen entspricht. Iteratives Vorgehen und Reflexion sind zwei Bausteine, die dazu dienen, den Prozess zu verbessern. Um jedoch zu erkennen, ob tats\u00e4chlich eine Verbesserung eintritt, muss eine Messgr\u00f6\u00dfe vorliegen, an der man eine Entwicklung zum Besseren \u00fcberhaupt ablesen kann.</p> <p>Das Messen der Fehler kann durch Z\u00e4hlen oder durch Zeitnahme erfolgen. Dabei steht nicht die Pr\u00e4zision im Vordergrund, solange die Messmethode vergleichbare Daten liefert. Die Entwicklungstendenz \u00fcber mehrere Iterationen hinweg soll ersichtlich werden. Ferner geht es nicht darum, die Verantwortlichkeit f\u00fcr einen Fehler zu kl\u00e4ren. Am Ende ist es egal, wer den Fehler verursacht hat, so lange das Team daraus lernt und seinen Prozess verbessert.</p> <p>Welche Fehler sind zu messen? Es sind nicht die Fehler, die w\u00e4hrend der Entwicklung auftreten. Die sind nicht zu vermeiden und f\u00fchren hoffentlich dahin, dass am Ende einer Iteration ein fehlerfreies Produkt ausgeliefert wird. Vielmehr geht es um die Fehler, die nach einer Iteration zur\u00fcckgemeldet werden vom Kunden bzw. seinem Stellvertreter (z.B. Product Owner oder Support). Das sind Fehler, die die Umsetzung neuer Anforderungen behindern. Zu messende Fehler sind also die, die auftreten, wenn man glaubt, dass es sie nicht geben d\u00fcrfte ;-) Wann im Prozess ein Team diesen Punkt erreicht und flucht, weil da wieder so ein Fehler der sonstigen Arbeit dazwischenfunkt, ist teamindividuell zu bestimmen.</p> <p>Weiter geht es beim\u2003blauen Grad.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Incremental%20Development/","title":"Incremental Development","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Incremental%20Development/#incremental-development","title":"Incremental Development","text":"<p>Warum? Nur die Arbeit in Inkrementen erm\u00f6glicht es dem Product Owner, Feedback zu geben.</p> <p>Ein Inkrement stellt einen vertikalen Schnitt durch die verschiedenen Aspekte eines Softwaresystems dar. Somit ist ein Inkrement ein St\u00fcck ausf\u00fchrbare Software. Das Inkrement kann einem Product Owner auf einer Testmaschine zur Verf\u00fcgung gestellt werden, um Feedback einzuholen.</p> <p>Regelm\u00e4\u00dfiges Feedback in kurzen Abst\u00e4nden, jeweils am Ende einer Iteration, ist die Definition von Agilit\u00e4t.</p> <p>Wird dagegen horizontal statt vertikal vorgegangen, entstehen Module, die nicht eigenst\u00e4ndig ausf\u00fchrbar sind. Zu solchen Modulen kann ein Product Owner kein Feedback geben. Somit ist kein echtes agiles Vorgehen m\u00f6glich.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Inversion%20of%20Control%20Container/","title":"Inversion of Control Container","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Inversion%20of%20Control%20Container/#inversion-of-control-container","title":"Inversion of Control Container","text":"<p>Warum? Nur, was nicht fest verdrahtet ist, kann leichter umkonfiguriert werden.</p> <p>Bereits im gelben Grad\u2003hat der CCD das Dependency Inversion Principle kennengelernt. Dabei wurden die Abh\u00e4ngigkeiten noch \u201evon Hand\u201c aufgel\u00f6st. Der n\u00e4chste logische Schritt besteht nun darin, das Aufl\u00f6sen der Abh\u00e4ngigkeiten zu automatisieren. Dazu stehen zwei Verfahren zur Verf\u00fcgung:</p> <ul> <li>Locator</li> <li>Container</li> </ul> <p>Beide verwenden einen sogenannten\u2003Inversion of Control Container\u2003(IoC Container). Vor der Verwendung des Containers m\u00fcssen die verwendeten Klassen im Container hinterlegt werden. Anschlie\u00dfend kann der Container Instanzen der hinterlegten Klassen liefern. Beim\u2003Locator\u2003geschieht dies explizit. Dies hat den Vorteil, dass die Abh\u00e4ngigkeiten nicht alle im Konstruktor der Klasse aufgef\u00fchrt werden m\u00fcssen. Bei Querschnittsaufgaben wie beispielsweise\u2003Logging\u2003ist dies ein \u00fcbliches Vorgehen. In der Regel werden die Abh\u00e4ngigkeiten jedoch als Parameter des Konstruktors aufgef\u00fchrt. Dies hat den Vorteil dass alle Abh\u00e4ngigkeiten sichtbar sind. Der Container ist damit in der Lage die Abh\u00e4ngigkeiten implizit aufzul\u00f6sen in dem er rekursiv alle ben\u00f6tigten Objekte \u00fcber den Container instanziert.</p> <p>IoC Container werden wichtig, sobald die Anzahl der Klassen w\u00e4chst. Wenn man\u2003Separation of Concerns\u2003beherzigt, entstehen viele kleine Klassen mit \u00fcberschaubaren Aufgaben. Das Zusammensetzen von Instanzen dieser Klassen wird entsprechend aufwendiger. Genau hier setzt der IoC Container an, er hilft beim Instanziieren und Verbinden der vielen kleinen Objekte.</p> <p>Ein weiterer Vorteil von IoC Containern ist die Tatsache, dass der\u2003Lebenszyklus\u2003eines Objektes per Konfiguration bestimmt werden kann. Soll es zur Laufzeit nur eine einzige Instanz eines Objektes geben (Singleton) kann der Container angewiesen werden, immer ein und dieselbe Instanz zu liefern. Auch andere Lebenszyklen wie z.B.\u2003eine Instanz pro Session\u2003werden unterst\u00fctzt.</p> <p>Um bei Verwendung eines Locators nicht in Abh\u00e4ngigkeit zu einem bestimmten IoC Container zu geraten, kann der\u2003Microsoft Common Service Locator\u2003(siehe Tools) verwendet werden. Dieser bietet eine vereinheitlichte Schnittstelle zu den g\u00e4ngigen IoC Containern.</p> <p>Zum Verst\u00e4ndnis der Mechanik die hinter einem IoC Container steckt, ist es n\u00fctzlich die Funktionalit\u00e4t einmal selber zu implementieren. Dabei soll kein vollst\u00e4ndiger Container implementiert werden sondern lediglich die Grundfunktionen.</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Issue%20Tracking/","title":"Issue Tracking","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Issue%20Tracking/#issue-tracking","title":"Issue Tracking","text":"<p>Warum? Nur, was man aufschreibt, vergisst man nicht und kann man effektiv delegieren und verfolgen.</p> <p>Eine strukturierte Verwaltung aller \u201eIssues\u201c ist schon deshalb erforderlich, damit nichts verloren geht. Und nur wenn ein \u00dcberblick \u00fcber alle offenen Punkte m\u00f6glich ist, k\u00f6nnen die Punkte priorisiert und in eine Reihenfolge gebracht werden. Dazu bedarf es nicht zwangsl\u00e4ufig ausgekl\u00fcgelter Tools, ein Board mit Pappkarten kann den Zweck auch erf\u00fcllen. Vor allem sollte hier nicht das Tool im Vordergrund stehen, sondern die T\u00e4tigkeit.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Iterative%20Development/","title":"Iterative Development","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Iterative%20Development/#iterative-development","title":"Iterative Development","text":"<p>Warum? Frei nach von Clausewitz: Kein Entwurf, keine Implementation \u00fcberlebt den Kontakt mit dem Kunden. Softwareentwicklung tut daher gut daran, ihren Kurs korrigieren zu k\u00f6nnen.</p> <p>Nat\u00fcrlich schreitet Softwareentwicklung immer von einer Planung \u00fcber die Implementation zu einem Test durch den Kunden voran. Irrig ist allerdings die Annahme, ein Projekt k\u00e4me mit einer Planungsphase und einer Implementationsphase und einer Kundentestphase aus. Das funktioniert \u2013 wenn \u00fcberhaupt \u2013 nur in trivialen Szenarien, wo in der Planungsphase alle Anforderungen bekannt sind. In realen Projekten jedoch liefert jede Phase Erkenntnisse f\u00fcr vorhergehende Phasen. Allemal durch den Kundentest ergeben sich Konsequenzen f\u00fcr die Planung und Implementation.</p> <p>Solche Erkenntnisse k\u00f6nnen allerdings nur Einfluss auf ein Projekt nehmen, wenn das Vorgehen nicht linear ist. Wenn es von einer sp\u00e4teren Phase keinen Weg zur\u00fcck zu einer fr\u00fcheren Phase gibt, ist Feedback nutzlos.</p> <p>Um Feedback in ein Softwareprodukt einflie\u00dfen lassen zu k\u00f6nnen, muss der Entwicklungsprozess Schleifen enthalten. Allemal die Schleife von der Kundentestphase zur\u00fcck zur Planung ist n\u00f6tig. Das hei\u00dft, Softwareentwicklung kann nur iterativ, also in mehreren Durchl\u00e4ufen, \u00fcber den Anforderungskatalog des Kunden stattfinden. Wer versucht, \u201emit einem Mal\u201c (big bang) auszuliefern, handelt dieser Erkenntnis zuwider. Der Softwareentwicklungsprozes ist vielmehr so zu planen, dass er sich durch die Anforderungen \u201ein kleinen Happen durchbei\u00dft\u201c. Jeder dieser Happen sollte nicht gr\u00f6\u00dfer sein, als dass der Durchlauf von Planung bis Kundentest mehr als 2-4 Wochen dauert. Nur dann kommt das Feedback vom Kunden h\u00e4ufig genug, um nicht allzu lange in der Umsetzung in die Irre zu laufen.</p> <p>Softwareentwicklung ist damit ein Lernprozess. In seinem Verlauf lernt das Projektteam etwas \u00fcber die Anforderungen des Kunden. Es h\u00f6rt ihm zu, plant, implementiert, und h\u00e4ndigt eine Softwareversion aus, die das Verst\u00e4ndnis des Geh\u00f6rten widerspiegelt. Dann h\u00f6rt das Team wieder zu, plant weiter/erneut nach den aktuellen Erkenntnissen usw. usf. immer im Kreis. Iteration f\u00fcr Iteration. Manchmal wird etwas aus einer fr\u00fcheren Iteration verfeinert, manchmal Neues hinzugef\u00fcgt.</p> <p>Doch nicht nur die Entwicklung einer Software ist ein Lernprozess. Lernen sollte auch auf organisatorischer Ebene stattfinden. Das Team sollte nicht nur \u00fcber den Kunden etwas lernen, sondern auch \u00fcber sich selbst. Deshalb sollte es auch immer wieder \u201eHaltepunkte\u201c geben, an denen das Team \u00fcber sein Vorgehen reflektiert. Die Erkenntnisse aus solcher Retrospektive flie\u00dfen dann ein in die n\u00e4chste Iteration der organisatorischen Entwicklung. Hier schlie\u00dft der blaue Grad an den roten Grad an, zu dem die t\u00e4gliche pers\u00f6nliche Reflexion geh\u00f6rt.</p> <p>Nat\u00fcrlich muss jede Iteration auch ein Ende haben. Und damit man wei\u00df ob man fertig ist, muss vorher klar definiert sein, was in der Iteration erreicht werden soll. Die Erreichbarkeit von Zielen kann immer nur gesch\u00e4tzt werden, auch dabei hilft die Reflexion, um die Sch\u00e4tzungen schrittweise soweit zu verbessern, dass sie f\u00fcr die Planung ausreichend genau sind. Doch wann ist das vorher definierte Ziel erreicht?\u2003\u201aWhat is done?\u2018\u2003Oberstes Ziel ist die Lieferung funktionsf\u00e4higer Software an unsere Kunden. Folglich kann das Ziel nur erreicht sein wenn wir auslieferungsfertige Software produziert haben. Das bedeutet insbesondere, dass die Software getestet ist und dass sie per Setup installiert werden kann. Durch Continuous Integration stellen wir dies kontinuierlich sicher. Keinesfalls d\u00fcrfen wir kurz vor Ende einer Iteration entscheiden, dass ein Ziel erreicht ist, obwohl noch nicht alle Tests abgeschlossen sind.</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Mockups/","title":"Mockups","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Mockups/#mockups","title":"Mockups","text":"<p>Warum? Ohne Attrappen keine einfach kontrollierbaren Tests.</p> <p>In der Regel verwenden Komponenten andere Komponenten. Will man eine Komponente isoliert testen, m\u00fcssen diese Abh\u00e4ngigkeiten abgetrennt werden. Dabei interessiert uns nun ausschlie\u00dflich die Funktionalit\u00e4t der zu testenden Komponente (System Under Test (SUT)). Und es interessiert uns, wie die Komponente mit den anderen interagiert.</p> <p>Beim Isolieren verwenden wir sogenannte Mockups. Diese werden anstelle der echten Komponenten verwendet. So interagiert das System Under Test w\u00e4hrend der Tests mit gut kontrollierbaren Attrappen statt mit realen Komponenten.</p> <p>Die Literatur kennt noch andere Bezeichnungen f\u00fcr Attrappen wie\u2003Stub,\u2003Dummy\u2003oder\u2003Fake, die teilweise synonym zu Mockup benutzt werden, aber durchaus f\u00fcr\u2003unterschiedliche Funktionsweisen\u2003stehen. Bevor man ein Mock Framework wie z.B.\u2003Rhino Mocks\u2003verwendet, sollte man ein Mockup zun\u00e4chst \u201eper Hand\u201c implementieren. Dies hilft, den Mechanismus zu verstehen.</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Partizipation%20in%20Professional%20Events/","title":"Partizipation in Professional Events","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Partizipation%20in%20Professional%20Events/#partizipation-in-professional-events","title":"Partizipation in Professional Events","text":"<p>Warum? Am besten lernen wir von anderen und in Gemeinschaft.</p> <p>Um nicht nur \u201eim eigenen Saft zu schmoren\u201c, ist es wichtig, regelm\u00e4\u00dfig mit anderen Softwareentwicklern zu diskutieren und Erfahrungen auszutauschen. Um dabei auch \u00fcber den Tellerrand zu blicken, sollte der Austausch mit Entwicklern au\u00dferhalb des eigenen Teams, der t\u00e4glichen Routine, erfolgen. Gut geeignet sind User Groups, die sich in allen Regionen Deutschlands finden lassen.</p> <p>Bei den regionalen User Groups steht der Erfahrungsaustausch im Vordergrund. Der ist wichtig. Je l\u00e4nger der aber innerhalb derselben Gruppe stattfindet, je besser man die Gespr\u00e4chspartner kennt, desto mehr gleichen sich die Meinungen auch in einer User Group wieder an. Deshalb ist es wichtig, immer wieder auch \u00fcber diesen Tellerrand hinaus zu schauen. Neues Gedankenfutter und Diskussionen mit ganz anderen Entwicklern bieten daf\u00fcr \u00fcberregionale Entwicklerkonferenzen.</p> <p>F\u00fcr Gedankenaustausch und Inspiration sollte ein CCD also drei Ebenen im Blick behalten: das eigene Entwicklerteam, die regionale User Group und die \u00fcberregionale Konferenz. Jede Ebene hat dabei ihren eigenen Rhythmus: t\u00e4glich, monatlich, j\u00e4hrlich.</p> <p>Links:</p> <ul> <li>.Net User Groups in Deutschlands</li> <li>Python User Groups in Deutschland</li> <li>Einige deutsche Java User Groups</li> <li>IT-Termine in Karlsruhe</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Read%2C%20Read%2C%20Read/","title":"Read, Read, Read","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Read%2C%20Read%2C%20Read/#read-read-read","title":"Read, Read, Read","text":"<p>Warum? Lesen bildet!</p> <p>Lesen bildet \u2013 wir sind jedenfalls fest davon \u00fcberzeugt, dass dies auch f\u00fcr Software-Entwickler gilt. Die Softwaretechnik entwickelt sich nach wie vor weiter. Neben den gro\u00dfen Entwicklungsschritten wie Prozedurale Programmierung, Objektorientierte Programmierung, Funktionale Programmierung, Aspektorientierte Programmierung, etc. gibt es st\u00e4ndig Entwicklungen im Kleinen mit denen sich ein professioneller Software-Entwickler auseinandersetzen muss. Da w\u00e4ren zum einen Techniken wie etwa\u2003Dependency Injection\u2003oder\u2003Object Relational Mapper. Aber auch innerhalb dieser Techniken gibt es Entwicklungsschritte wie etwa\u2003Domain Specific Languages (DSLs)\u2003zur Konfiguration vs. XML basierende Konfiguration. Neben den technischen Aspekten der Softwareentwicklung wird auch der Prozess st\u00e4ndig weiterentwickelt. So hat sich die Erkenntnis durchgesetzt, dass Wasserfallmodelle nicht funktionieren, verschiedene agile Prozesse werden entwickelt. All dies muss der Clean Code Developer im Blick haben.</p> <p>Wir schlagen daher vor, pro Jahr wenigstens 6 Fachb\u00fccher zu lesen. Ferner sollten Periodika regelm\u00e4\u00dfig gelesen werden und darunter verstehen wir neben Fachzeitschriften auch Blogs.</p> <p>Anregungen finden Sie in der\u2003Literaturliste.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Root%20Cause%20Analysis/","title":"Root Cause Anaysis","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Root%20Cause%20Analysis/#root-cause-anaysis","title":"Root Cause Anaysis","text":"<p>Warum? Symptome behandeln bringt vielleicht schnell eine Linderung \u2013 langfristig kostet es aber mehr Aufwand. Wer stattdessen unter die Oberfl\u00e4che von Problemen schaut, arbeitet am Ende effizienter.</p> <p>Regel vom ersten Tag als Clean Code Developer an sollte sein, bei Problemen immer intensiv nach der wahren Wurzel des \u00dcbels zu suchen. Clean Code Developer geben sich nicht mit einer Symptomkur zufrieden. Beispiel: Die Sortierung von Daten im Speicher ist zu langsam. Eine oberfl\u00e4chliche Kur w\u00fcrde jetzt daran gehen, einzelne Anweisungen oder Anweisungsbl\u00f6cke zu beschleunigen. Vielleicht wird der Einsatz von unsafe Code probiert, vielleicht eine Parallelisierung. Eine n\u00e4here Problemanalyse jedoch h\u00e4tte ergeben, dass ein suboptimaler Algorithmus die Wurzel des \u00dcbels ist. Schwer verst\u00e4ndliche Optimierungen auf niedriger Abstraktionsebene k\u00f6nnen also vermieden werden. Ein besserer Algorithmus ist die saubere L\u00f6sung.</p> <p>Wurzelproblemanalyse ist also ein Dienst an der Verst\u00e4ndlichkeit und am Aufwand. Denn bei Kenntnis des Wurzelproblems ist die Bereinigung meist weniger aufw\u00e4ndig als eine Symptomkur. St\u00f6\u00dft der Clean Code Developer auf ein Problem, so h\u00e4lt er also als erstes inne, um sich eine Chance zu geben, hinter die Symptome zu schauen.</p> <p>Die Root Cause Analysis ist auch unter dem Begriff Five Why\u2019s bekannt. Dieser Begriff stammt aus der Terminologie des Toyota Produktions SystemsToyota Produktions Systems (TPS). Die Grundidee: frage mindestens f\u00fcnf mal \u201eWarum?\u201c.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Share%20Experience/","title":"Share Experience","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Share%20Experience/#share-experience","title":"Share Experience","text":"<p>Warum? Wer sein Wissen weitergibt, hilft nicht nur anderen, sondern auch sich selbst.</p> <p>Zu professioneller Arbeit geh\u00f6rt selbstverst\u00e4ndlich ein st\u00e4ndig akuelles Wissen. Das bedeutet nat\u00fcrlich nicht, dass irgendjemand alles zum Thema Softwareentwicklung und sei es auch nur auf der .NET-Plattform wissen kann und soll. Aktuelles Wissen bezieht sich auf die eigenen Spezialgebiete \u2013 welche das auch immer sein m\u00f6gen. Bestandteil anderer Grade ist deshalb die Praktik der regelm\u00e4\u00dfigen Informationsaufnahme \u00fcber verschiedene Medien.</p> <p>Aus mehreren Gr\u00fcnden sollte solche Informationssammlung jedoch nur eine von zwei Seiten der Medaille \u201eLernen\u201c sein. Die andere ist die Informationsweitergabe, die Wissensvermittlung. Zur wahren Professionalit\u00e4t geh\u00f6rt unserer Ansicht nach nicht nur \u201eForschung\u201c, sonder auch \u201eLehre\u201c. Denn erst mit der \u201eLehre\u201c findet wahre Reflektion und Durchdringung eines Gegenstandes statt.</p> <p>Etwas Geh\u00f6rtes/Gelesenes anwenden, ist eine Sache. Nat\u00fcrlich bemerkt man dabei auch Verst\u00e4ndnisl\u00fccken. Die \u201eErforschung\u201c eines Gegenstandes ist dabei jedoch durch den Einsatzzweck nat\u00fcrlich begrenzt. Wer nur soweit forscht, wie er eine Technologie/Konzept gerade braucht, der taucht nicht unbedingt tief ein.</p> <p>Ganz anders ist das hingegen, wenn das Lernen mit dem Vorzeichen des Weitersagens stattfindet. Wer nicht nur f\u00fcr sich, sondern auch immer f\u00fcr andere lernt, der lernt tiefer. Das wird klar, wenn man versucht, (angeblich) Gelerntes anderen zu vermitteln. Wenn man das nicht beim Lernen im Blick hat, tauchen schnell Fragen auf, die man sich selbst nie gestellt hat. Andere haben eben immer ganz andere Blickwinkel.</p> <p>Deshalb meinen wir, dass wirklich solide nur lernt, wer sich auch immer wieder dem Lehren, dem Weitersagen, der Wissensvermittlung aussetzt. Nur wer Gelerntes nicht nur anwendet, sondern es mit eigenen Worten f\u00fcr ein Publikum formuliert, bemerkt in dem Prozess, wie tief sein Wissen wirklich ist. Denn wenn sich die Fragezeichen bei den \u201eSch\u00fclern\u201c h\u00e4ufen, dann stimmt irgendetwas noch nicht.</p> <p>Ein reales Publikum ist daf\u00fcr nat\u00fcrlich am besten. Jeder CCD sollte also m\u00f6glichst regelm\u00e4\u00dfig Gelegenheiten suchen, um sein Wissen m\u00fcndlich weiterzugeben (z.B. bei Veranstaltungen im Kollegenkreis oder User Group Treffen). Unmittelbares Feedback ist ihm dabei gewiss. Alternativ bzw. in Erg\u00e4nzung taugen aber auch schriftliche Kompetenz\u00e4u\u00dferungen. Ein Blog ist in 5 Minuten aufgesetzt und Fachzeitschriften suchen st\u00e4ndig nach neuen Autoren. Feedback kommt hier zwar nicht so direkt zur\u00fcck, dennoch ist die textuelle Ausformulierung von Kenntnissen eine sehr gute \u00dcbung.</p> <p>CCD ab dem gr\u00fcnen Grad lernen daher nicht nur \u201epassiv\u201c durch Informationsaufnahme, sondern \u201eaktiv\u201c durch Weitergabe ihres Wissens mittels Pr\u00e4sentationen oder Texten. Das mag ungewohnt sein \u2013 ungewohnt ist aber auch wom\u00f6glich Continuous Integration. In jedem Fall ist aktive Wissensvermittlung eine gute \u00dcbung zur Vertiefung der eigenen Kompetenzen frei nach dem Motto: \u201eTue Gutes und sprich dar\u00fcber\u201c ;-)</p> <p>Dass das \u201eLehren\u201c auch noch einen Nutzen f\u00fcr die Zuh\u00f6rer/Leser hat, ist selbstverst\u00e4ndlich. Vorteile f\u00fcr andere sind aber nicht so motivierend wie eigene Vorteile. Deshalb betonen wir hier vor allem den Nutzen der Wissensvermittlung f\u00fcr den CCD.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Simple%20Refactorings/","title":"Simple Refactorings","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Simple%20Refactorings/#simple-refactorings","title":"Simple Refactorings","text":"<p>Warum? Code verbessern ist leichter, wenn man typische Verbesserungshandgriffe kennt. Ihre Anwendungsszenarien machen sensibel f\u00fcr Schwachpunkte im eigenen Code. Als anerkannte Muster st\u00e4rken sie den Mut, sie anzuwenden.</p> <p>Um Code immer ein wenig besser zu hinterlassen, als man ihn vorgefunden hat, sind mehr oder weniger gro\u00dfe Eingriffe n\u00f6tig. Die kann ein Clean Code Developer dank des Versionskontrollsystems angstfrei vornehmen. Doch wie macht er sich die Arbeit m\u00f6glichst einfach?</p> <p>Das Schl\u00fcsselwort lautet \u201eRefaktorisierung\u201c.\u2003Martin Fowler\u2003hat das\u2003Refaktorisieren/Refactoring\u2003in seinem gleichnamigen Buch als grundlegende Technik zur Erh\u00f6hung der Codequalit\u00e4t beschrieben. Er definiert darin eine Anzahl von Codever\u00e4nderungsmustern, um \u201ecode smells\u201c, d.h. suboptimale Strukturen oder allgemeiner Missachtungen von Prinzipien, zu bereinigen.</p> <p>F\u00fcr den roten Grad ist darin vor allem die Refaktorisierung\u2003Methode extrahieren\u2003relevant, um dem DRY-Prinzip zu gen\u00fcgen. Die wenden Clean Code Developer an, um mehrfach vorkommenden Code in eine Methode zu extrahieren, die statt seiner an den Wiederholungsorten aufgerufen wird.</p> <p>Als zweite Refaktorisierung sollte bei der Arbeit am roten Grad das\u2003Umbenennen\u2003wo n\u00f6tig eingesetzt werden. Sie passt zur Pfadfinderregel, denn eine oft anzutreffende \u201eUnsauberkeit\u201c im Quellcode sind kryptische Namen.</p> <p>Refaktorisierungen k\u00f6nnen von Hand angewandt werden, doch es gibt auch Werkzeugunterst\u00fctzung. Moderne IDEs wie Visual Studio bieten einige Refactoringmuster, weitere Tools listet unsere\u2003Werkzeugliste.</p> <p>\u201eRefactoring\u201c wie \u201eClean Code\u201c geh\u00f6ren zur\u2003Pflichtlekt\u00fcre\u2003jedes Clean Code Developers ab dem roten Grad.</p> <p>F\u00fcr weitere Informationen siehe auch unter\u2003refactoring-legacy-code.net.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Statical%20Code%20Analysis/","title":"Statical Code Analysis","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Statical%20Code%20Analysis/#statical-code-analysis","title":"Statical Code Analysis","text":"<p>Warum? Vertrauen ist gut, Kontrolle ist besser \u2013 und je automatischer, desto leichter ist sie.</p> <p>Wie definiert sich eigentlich die Qualit\u00e4t einer Codeeinheit, z.B. einer Klasse oder Komponente? Reicht es, dass sie funktional die Anforderungen des Kunden erf\u00fcllt? Reicht es, dass er schnell genug und skalierbar genug ist? Automatische Tests und schlie\u00dflich Tests durch den Kunden geben dar\u00fcber ja Auskunft. Ohne solche Anforderungskonformit\u00e4t hat Software nat\u00fcrlich keine relevante Qualit\u00e4t. Wenn sie dem Kunden nicht n\u00fctzt, er\u00fcbrigt sich jede weitere Frage.</p> <p>Auf der anderen Seite reicht es, entgegen immer noch weit verbreiteter Annahme, allerdings auch nicht, anforderungskonform zu sein. Hohe Qualit\u00e4t ergibt sich nicht allein aus Funktionalit\u00e4t und z.B. Performance. Denn neben den funktionalen und nicht funktionalen Anforderungen gibt es auch noch eine meist unausgesprochene verborgene Anforderung: Kunden wollen auch immer, dass Software nicht nur heute ihre Anforderungen erf\u00fcllt, sondern auch noch morgen und \u00fcbermorgen. Kunden wollen Investitionsschutz durch Wandelbarkeit.</p> <p>F\u00fcr Kunden ist diese Anforderung meist implizit. Sie glauben, es sei selbstverst\u00e4ndlich, dass ein immaterielles Produkt wie Software sich quasi unendlich und auf Knopfdruck an neue Anforderungen anpassen lie\u00dfe. Auch F\u00fchrungskr\u00e4fte, die nicht aus der Softwareentwicklung stammen, glauben das oft. Und sogar Softwareentwickler selbst!</p> <p>Gr\u00f6\u00dfer k\u00f6nnte das Missverst\u00e4ndnis \u00fcber Software jedoch kaum sein. Wandelbarkeit ist weder selbstverst\u00e4ndlich im Sinne eines von jedem Softwareentwickler ohnehin verfolgten Zieles, noch ergibt sie sich durch irgendetwas quasi von selbst. Wandelbarkeit ist vielmehr harte Arbeit und muss st\u00e4ndig gegen andere Werte abgewogen werden.</p> <p>Wenn sonstige Anforderungskonformit\u00e4t sich nun durch (automatisierte) Tests feststellen l\u00e4sst, wie steht es dann mit der Wandelbarkeit? L\u00e4sst sich die Qualit\u00e4t von Code im Hinblick auf seine (\u00dcber)Lebensf\u00e4higkeit auch automatisch messen? Zum Teil. Nicht alle Aspekte, die Software evolvierbar machen, sind automatisch pr\u00fcfbar. Ob zum Beispiel Software offen f\u00fcr Erweiterungen durch ein Add-In-Konzept gehalten wird, ist nicht automatisiert erkennbar.</p> <p>Dennoch gibt es\u2003Metriken, deren Wert f\u00fcr eine Software sich \u201eausrechnen\u201c l\u00e4sst.\u2003Tools\u2003helfen dabei. Diese Tools sollten daher in jedem Softwareprojekt zum Einsatz kommen.</p> <ul> <li>F\u00fcr Legacy Code k\u00f6nnen die Tools den Status Quo erheben und somit eine Grundlinie definieren, mit der die weitere Entwicklung des Codes (zum Besseren) verglichen werden kann.</li> <li>F\u00fcr neuen Code, der mit Wandelbarkeit im Blick geplant wurde, zeigt solch statische Codeanalyse, ob er das Ideal der Planung erf\u00fcllt.</li> </ul> <p>CCD sind nicht damit zufrieden, Code nur automatisiert zu testen. Sie haben auch immer ein Auge auf seine Wandelbarkeit, denn sie wissen, dass Kunden daran genauso interessiert sind \u2013 egal, ob sie es explizit gesagt haben oder nicht.</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Tell%20do%20not%20ask/","title":"Tell, don\u2019t ask","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Tell%20do%20not%20ask/#tell-dont-ask","title":"Tell, don\u2019t ask","text":"<p>Warum? Hohe Koh\u00e4sion und lose Kopplung sind Tugenden. \u00d6ffentliche Zustandsdetails einer Klasse widersprechen dem.</p> <p>Etwas provokant formuliert, sollten Klassen keine Property Getter haben. Diese verf\u00fchren den Verwender einer Klasse dazu, anhand von Werten, die ein Objekt liefert, Entscheidungen zu treffen. Statt also dem Objekt mitzuteilen, was es tun soll, wird es befragt, um dann von au\u00dfen Betrachtungen \u00fcber den internen Zustand des Objektes anzustellen.</p> <p>Eines der Kernprinzipien der OOP lautet\u2003Information Hiding Principle\u2003(siehe dazu auch im\u2003gelben Grad). Keine Klasse soll Details nach au\u00dfen tragen, aus denen hervorgeht, wie sie intern implementiert ist. Ben\u00f6tigt eine Klasse f\u00fcr ihre Arbeit einen internen Zustand, wird dieser typischerweise in einem internen Feld abgelegt. Wenn nun dieser Wert auch nach au\u00dfen sichtbar ist, werden Verwender verleitet, diesen eigentlich internen Zustand des Objektes f\u00fcr eigene Entscheidungen heranzuziehen. Dadurch wird die Klasse schnell zur reinen Datenhaltung degradiert. Eine Implementierung, bei der einem Objekt mitgeteilt wird, was es tun soll, ist in jedem Fall vorzuziehen. Dadurch muss es den Verwender nicht mehr interessieren, wie die Klasse die Aufgabe intern bewerkstelligt.</p> <p>Als Ergebnis des\u2003Tell don\u2019t ask\u2003Prinzips entstehen Objekte mit Verhalten statt \u201edummer\u201c Datenhaltungsobjekte. Das Zusammenspiel der Objekte ist lose gekoppelt, da die Objekte keine Annahmen \u00fcber die kollaborierenden Objekte machen m\u00fcssen. Aber nicht nur das! Wenn Objekte ihren Zustand nicht ver\u00f6ffentlichen, behalten sie die Entscheidungshoheit. Die Koh\u00e4sion des entscheidenden Codes w\u00e4chst damit, weil er an einem Ort zusammengelegt wird.</p> <p>Ein typisches Codebeispiel ist im folgenden zu sehen. Statt hier zun\u00e4chst zu fragen, ob im Logging die Tracemeldungen aktiviert sind (Ask), sollte die Logging Bibliothek direkt angewiesen werden, die Tracemeldung auszugeben (Tell). Die Bibliothek soll dann intern selbst entscheiden, ob die Meldung geloggt wird oder nicht. <pre><code>if (_logger.Trace()) {\n\t_logger.TraceMsg(\u201e\u2026 eine Meldung\u2026 \u201e);\n}\n</code></pre></p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Test%20First/","title":"Test First","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Test%20First/#test-first","title":"Test First","text":"<p>Warum?</p> <p>Der Kunde ist K\u00f6nig und bestimmt die Form einer Dienstleistung. Service-Implementationen sind also nur passgenau, wenn sie durch einen Client getrieben werden.</p> <p>Wenn Komponentenorientierung fordert, die Kontrakte f\u00fcr Komponenten unabh\u00e4ngig von ihrer Implementation zu definieren, stellt sich die Frage, wie das denn geschehen soll. Durch Diskussion am runden Tisch? Das ist sicherlich ein Weg. Ein besserer ist jedoch, Kontrakte nicht erst lange an einer Tafel zu entwerfen, sondern sie sofort in Code zu gie\u00dfen. Komponentenkontrakte \u2013 oder allgemeiner: jede Codeschnittstelle \u2013 dient letztlich anderem Code als API. Es ist daher konsequent und effektiv, von diesem Code ausgehend Schnittstellen zu spezifizieren.</p> <p>Das ist das Anliegen von\u2003Test First. Test first basiert auf dem Gedanken, dass Funktionseinheiten (Methoden, Klassen, usw.) durch Client-Service-Verh\u00e4ltnisse charakterisiert sind. Diese Verh\u00e4ltnisse drehen sich um die Schnittstelle zwischen Client und Service. Und diese Schnittstelle sollte durch den Client bestimmt werden. Der Client ist als Kunde des Service K\u00f6nig. Ihm soll der Service dienen, nach ihm soll sich deshalb die Schnittstelle des Service richten.</p> <p>Die Definition der Schnittstellen der Codeeinheiten einer Software erfolgt aus diesem Grund von au\u00dfen nach innen. Au\u00dfen, an der Benutzeroberfl\u00e4che, sitzt der ultimative Client, der Anwender. Er definiert die visuelle/haptische Schnittstelle der UI-Codeeinheiten. Die wiederum sind die Clients von darunterliegenden Codeschichten. Die sind dann Clients von tieferliegenden Schichten usw. Die Leistungen und Schnittstellen der tiefsten Codeschichten kann somit nur bestimmt werden, wenn die der dar\u00fcberliegenden schon bestimmt sind usw.</p> <p>Das widerspricht dem h\u00e4ufigen Ansatz der bottom-up Definition von Codeeinheiten. Gern fangen Projekte an, eine Datenzugriffsschicht zu definieren und zu implementieren. Das ist verst\u00e4ndlich, weil solch fundamentale Funktionalit\u00e4t doch scheinbar die Voraussetzung f\u00fcr alles weitere ist. Aber dieses Vorgehen ist problematisch, wie viele gescheiterte Projekte zeigen:</p> <ul> <li>Wer von unten nach oben, von innen nach au\u00dfen spezifiziert und implementiert, bietet dem Kunden erst sehr sp\u00e4t einen Wert an. Das ist zumindest frustrierend, wenn nicht gar kontraproduktiv.</li> <li>Wer bottom-up in der Spezifikation vorgeht, der spezifiziert ohne genaue Anforderungen des ultimativen Clients, des Benutzers. Was er also spezifiziert l\u00e4uft Gefahr, am Ende zu allgemein und damit unhandlich zu sein \u2013 oder schlicht nicht gebraucht zu werden (eine Verletzung des YAGNI-Prinzips, s.o. und im\u2003roten Grad</li> <li>Wer von unten nach oben implementiert, l\u00e4uft Gefahr, nicht wirklich zu entkoppeln. Denn wenn tiefere Schichten n\u00f6tig sind, um dar\u00fcberliegende zu implementieren, dann werden wahrscheinlich keine wirklich isolierten Unit Tests mit Attrappen eingesetzt und auch keine Inversion of Control.</li> </ul> <p>Clean Code Developer vermeiden diese Probleme jedoch. Sie spezifizieren Schnittstelle nicht nur vor den Implementationen (Contract-first, s.o. Komponentenorientierung), sondern auch von au\u00dfen nach innen und ganz praktisch durch Codierung. Mit den Mitteln des automatisierten Testens ist es n\u00e4mlich sehr einfach, Schnittstellen in kleinen Schritten in Form von Tests zu definieren.</p> <p>Test first f\u00fcgt dadurch syntaktischen Kontrakten (z.B. Interfaces) eine semantische Seite hinzu. In Ermangelung anderer, formaler Methoden, um Semantik zu spezifizieren, sind Tests der einzige Weg, um Anforderungen zu formalisieren. Wer einem Entwickler eine Komponente zur Implementierung zuweisen will, der tut daher gut daran, nicht nur ihre \u201eOberfl\u00e4che\u201c (API) syntaktisch vorzugeben, sondern auch das gew\u00fcnschte Verhalten in Form von Tests.</p> <p>Das hat viele Vorteile:</p> <ul> <li>Die Form einer Schnittstelle ist unmittelbar Client-getrieben und damit maximal relevant. YAGNI hat keine Chance.</li> <li>Die Tests sind nicht nur Tests, sondern auch Spezifikationsdokumentation. Nutzer einer Schnittstelle und Implementierer k\u00f6nnen sie gleicherma\u00dfen studieren. Eine separate Dokumentation er\u00fcbrigt sich weitgehend. Das tut dem DRY-Prinzip gen\u00fcge.</li> <li>Die Spezifikationen sind nicht nur passive Texte, sondern ausf\u00fchrbarer Code. Wenn dann eine Implementation vorliegt, kann sie gegen diese Tests gepr\u00fcft werden. Spezifikation und Test sind damit nicht zeitraubend aufeinanderfolgende Phasen. Das erh\u00f6ht die Produktivit\u00e4t. Qualit\u00e4tssicherung ist so der Implementation schon vorgeschaltet.</li> </ul> <p>Siehe auch unter\u2003Tools.</p> <p>Weiter geht\u2019s mit dem\u2003wei\u00dfen Grad.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Version%20Control%20System/","title":"Version Control System","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Praktiken/Version%20Control%20System/#version-control-system","title":"Version Control System","text":"<p>Warum? Symptome behandeln bringt vielleicht schnell eine Linderung \u2013 langfristig kostet es aber mehr Aufwand. Wer stattdessen unter die Oberfl\u00e4che von Problemen schaut, arbeitet am Ende effizienter.</p> <p>Unabdingbare Voraussetzung f\u00fcr jeden Clean Code Developer ist es, seinen Code unter den Schutz eines Versionskontrollsystems zu stellen. Ob das Mercurial, Git, Subversion, VSS, TFS oder Vault ist, spielt dabei keine Rolle. Wir meinen nur, dass heute keine Arbeit an Code mehr durchgef\u00fchrt werden sollte, ohne ihn in einem Versionskontrollsystem zu pflegen. Der Grund daf\u00fcr ist ganz simpel: Ein Versionskontrollsystem befreit von Angst. Und Angstfreiheit ist n\u00f6tig, um mutig die Prinzipien und Praktiken des CCD-Wertesystems umzusetzen.</p> <p>Ein Versionskontrollsystem nimmt die Angst, etwas falsch und damit kaputt zu machen. Wenn Code in ihm gehalten wird, kann jeder CCD den Code nach Belieben ver\u00e4ndern, ohne bef\u00fcrchten zu m\u00fcssen, einen erreichten Stand zu zerst\u00f6ren. Nichts geht verloren. Das Versionskontrollsystem ist wie eine Zeitmaschine f\u00fcr Code.</p> <p>Damit ist ein Versionskontrollsystem die allerbeste Grundlage f\u00fcr alles Lernen. Denn Lernen bedeutet Fehler machen. Mit einem Versionskontrollsystem als Sicherheitsnetz k\u00f6nnen wir uns alle Fehler erlauben. Deshalb: Erste Voraussetzung f\u00fcr den Einstieg ins Clean Code Development ist der st\u00e4ndige Gebrauch eines Versionskontrollsystems.</p> <p>Wo das im Projekt nicht m\u00f6glich ist, sehen wir das Fundament f\u00fcr Clean Code Development abwesend. Wir w\u00fcrden auch nicht verstehen, warum der Einsatz eines Versionskontrollwerkzeuges nicht m\u00f6glich sein sollte. Kosten m\u00fcssen daf\u00fcr nicht anfallen und der Einarbeitungsaufwand in die einfachsten Funktionen ist minimal. CCD schreibt ja keine bestimmte Nutzung eines Versionskontrollsystems vor, sondern nur, dass eines benutzt werden muss.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Beware%20of%20Premature%20Optimization/","title":"Beware of Premature Optimization","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Beware%20of%20Premature%20Optimization/#beware-of-premature-optimization","title":"Beware of Premature Optimization","text":"<p>Warum? Optimierungen kosten immer viel Aufwand. Wer Vorsicht walten l\u00e4sst, spart oft wertvolle Ressourcen f\u00fcr das, was dem Kunden wirklich n\u00fctzt.</p> <p>Rules of Optimization:</p> <p>Rule 1: Don\u2019t do it.</p> <p>Rule 2 (for experts only): Don\u2019t do it yet.</p> <p>~ M.A. Jackson</p> <p>More computing sins are committed in the name of efficiency (without necessarily achieving it) than for any other single reason \u2013 including blind stupidity. ~ W.A. Wulf</p> <p>Im Vordergrund steht immer die Verst\u00e4ndlichkeit von Code. Optimierter Code ist aber oft alles andere als lesbar. Indem er auf das absolut Notwendige in k\u00fcrzester Form reduziert ist, mag er zwar die funktionalen und nicht funktionalen Anforderungen des Kunden erf\u00fcllen \u2013 doch er spiegelt sie meist nicht mehr verst\u00e4ndlich wider. Das ist kontraproduktiv im Sinne der meist gew\u00fcnschten Langlebigkeit einer Software. Donald Knuth schrieb bereits 1974: </p> <p>\u201eWe should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.\u201c </p> <p>(Knuth, Donald.\u2003Structured Programming with go to Statements, ACM Journal Computing Surveys, Vol 6, No. 4, Dec. 1974. p.268.)</p> <p>Die Pfadfinderregel ist also nicht so gemeint, dass immer weiter nach Codeoptimierungen gestrebt werden sollte. Sie bezieht sich vielmehr auf deren Gegenteil: Verst\u00e4ndlichkeit und Wandelbarkeit.</p> <p>Wenn es dem Clean Code Developer also in den Fingern zuckt, weil er denkt, er k\u00f6nne doch noch ein Qu\u00e4ntchen Performance durch eine Optimierung herausholen, dann sollte er mindestens zweimal \u00fcberlegen. Zum einen w\u00fcrde er dadurch die Verst\u00e4ndlichkeit verschlechtern, zum anderen aber ist es wahrscheinlich, dass solche Optimierung aus mehreren Gr\u00fcnden gar nicht n\u00f6tig ist. Ist die Performanceschw\u00e4che nicht nur punktuell und ein Sonderfall, wird sich die n\u00e4chste gr\u00f6\u00dfere Refaktorisierung ihrer wahrscheinlich ohnehin annehmen, denn dann liegt ihr ein grunds\u00e4tzliches Strukturproblem zugrunde. Oder die n\u00e4chste Hardwaregeneration b\u00fcgelt den Performanceknick aus. Oder der Kunde f\u00fchlt sich durch ihn gar nicht gest\u00f6rt. Ohnehin muss der Kunde die Forderung nach der Optimierung gestellt haben. Keine Codever\u00e4nderung ohne vom Kunden erwarteten Nutzen. Denn nur f\u00fcr ihn ist er bereit zu zahlen.</p> <p>Der Regel, sich im Zweifelsfall gegen Optimierungen zu entscheiden, liegt somit eine noch fundamentalere zugrunde: YAGNI \u2013\u2003You ain\u2019t gonna need it. Sie ist in ihrer vollen Auspr\u00e4gung allerdings erst Bestandteil des\u2003Blauer Grad</p> <p>PS: Wenn denn entgegen allen Warnungen und Bedenken gerade eine Performanceoptimierung unumg\u00e4nglich ist, dann sollte sie immer nur aufgrund einer detaillierten Analyse mit einem Profiler begonnen werden. Denn nur wer mit einem Profiler nachvollziehbar Performance-Engp\u00e4sse lokalisiert hat, kann w\u00e4hrend und nach der Optimierung pr\u00fcfen, ob und inwiefern er sie geweitet hat.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/DRY/","title":"Don\u2019t Repeat Yourself (DRY)","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/DRY/#dont-repeat-yourself-dry","title":"Don\u2019t Repeat Yourself (DRY)","text":"<p>Warum? Jede Doppelung von Code oder Handgriffen leistet Inkonsistenzen und Fehlern Vorschub.</p> <p>Das DRY-Prinzip lautet:\u2003Don\u2019t Repeat Yourself\u2003\u2013 Wiederhole dich nicht. Es gilt seit den Anf\u00e4ngen der Softwareentwicklung \u2013 sonst g\u00e4be es keine Unterprogramme und keine Datennormalisierung. Dennoch ist es wahrscheinlich das am meisten missachtete Prinzip. Denn nichts ist einfacher, als Code durch Copy&amp;Paste zu wiederholen. Gerade dann, wenn es mal schnell gehen soll, passiert das allzuoft.</p> <p>Clean Code Developer \u00fcben sich im roten Grad daher darin, dieses Prinzip stets zu beachten. Sie sind sich bewusst, wann sie Code oder andere Artefakte wiederholen. Sie erkennen solche Wiederholungen, die sie selbst oder andere erzeugt haben. Sie bereinigen Wiederholungen durch Refaktorisierungen \u2013 wenn keine anderen Prinzipien oder Beschr\u00e4nkungen dagegen sprechen.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Dependency%20Inversion%20Principle/","title":"Dependency Inversion Principle (DIP)","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Dependency%20Inversion%20Principle/#dependency-inversion-principle-dip","title":"Dependency Inversion Principle (DIP)","text":"<p>Warum?</p> <p>Punktgenaues Testen setzt Isolation von Klassen voraus. Isolation entsteht, wenn Klassen keine Abh\u00e4ngigkeiten von Implementationen mehr enthalten \u2013 weder zur Laufzeit, noch zur \u00dcbersetzungszeit. Konkrete Abh\u00e4ngigkeiten sollten deshalb so sp\u00e4t wie m\u00f6glich entschieden werden. Am besten zur Laufzeit.</p> <p>Auch das Dependency Inversion Principle (DIP) ist ein\u2003SOLID\u2003Prinzip. Es besagt folgendes:</p> <ul> <li>High-Level Klassen sollen nicht von Low-Level Klassen abh\u00e4ngig sein, sondern beide von Interfaces.</li> <li>Interfaces sollen nicht von Details abh\u00e4ngig sein, sondern Details von Interfaces.</li> </ul> <p>Verwendet eine High-Level Klasse eine Low-Level Klasse unmittelbar, so ergibt sich eine starke Kopplung zwischen beiden. Sp\u00e4testens beim Versuch, die High-Level Klasse isoliert zu testen, wird man auf Schwierigkeiten sto\u00dfen. Aus diesem Grund sollte die High-Level Klasse von einem Interface abh\u00e4ngig sein, das wiederum von der Low-Level Klasse implementiert wird. So kann die Low-Level Klasse im Unit Test durch ein\u2003Mockup\u2003ersetzt werden.</p> <p>Um zur Laufzeit die invertierte, abstrakte Abh\u00e4ngigkeit mit einem konkreten Objekt aufzul\u00f6sen, bieten sich im Prinzip drei M\u00f6glichkeiten:</p> <ul> <li>mittels Konstruktorparameter \u201eper Hand\u201c</li> <li>Einsatz eines Inversion of Control Containers (IoC Container) wie etwa Castle Windsor</li> <li>Dependency Lookup</li> </ul> <p>Im\u2003gelben Grad\u2003injizieren wir die Abh\u00e4ngigkeiten zun\u00e4chst nur \u00fcber die Parameter der Konstruktoren. Dies ist anfangs die einfachste L\u00f6sung und funktioniert mit einer handvoll Klassen ganz gut. Sp\u00e4ter im\u2003gr\u00fcnen Grad\u2003nutzen wir einen IoC Container und Dependency Lookup.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Design%20and%20Implementation%20do%20not%20Overlapp/","title":"Design and Implementation Don\u2019t Overlapp","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Design%20and%20Implementation%20do%20not%20Overlapp/#design-and-implementation-dont-overlapp","title":"Design and Implementation Don\u2019t Overlapp","text":"<p>Warum? Planungsunterlagen, die mit der Umsetzung nichts mehr gemein haben, schaden mehr, als dass sie n\u00fctzen. Deshalb nicht die Planung aufgeben, sondern die Chance auf Inkonsistenz minimieren.</p> <p>Eines der grundlegenden Probleme der Softwareentwicklung sind Implementationen, denen eine vorausgegangene Planung nicht mehr anzusehen ist. Da h\u00e4ngen dann Entwurfsdiagramme an der Wand, die kaum noch etwas mit der Coderealit\u00e4t zu tun haben. Die Ursache daf\u00fcr ist eine Verletzung des fundamentalen DRY-Prinzips: Entwurf und Implementation sind Wiederholungen desselben, der Struktur einer Software. Da Implementation auf Entwurf folgt und den L\u00f6wenanteil der Arbeit ausmacht, geraten beide schnell aus dem Tritt, wenn Struktur\u00e4nderungen w\u00e4hrend der Implementation nicht immer wieder in den Entwurf eingearbeitet werden. Entwurfsdiagramme sind nach Beginn der Implementation sonst bald nichts mehr wert.</p> <p>Wie kann die Situation verbessert werden? Sollte vielleicht auf Entwurf verzichtet werden, wenn letztlich in der Implementation die \u201eStrukturwahrheit\u201c liegt? Nein, sicher nicht. Entwurf muss sein. Ohne Planung gibt es keine Zielvorstellung. Aber Entwurf und Implementation m\u00fcssen dem DRY-Prinzip gerecht werden. Deshalb sollten Entwurf und Implementation sich so wenig \u00fcberlappen wie m\u00f6glich. Ihre Schnittstelle sollte d\u00fcnn sein. Wenn das der Fall ist, stellen sie keine Wiederholungen mehr dar, sondern beschreiben unterschiedliches. Das bedeutet: Entwurf/Architektur k\u00fcmmert sich nicht um die Implementation und Implementation k\u00fcmmert sich nicht um Architektur.</p> <p>Und wo verl\u00e4uft diese Trennlinie? Bei den so genannten Komponenten (s.u. Praktiken). Architekten k\u00fcmmern sich nicht um den internen Aufbau von Komponenten. F\u00fcr sie sind es Black Boxes, deren Klassenstruktur nicht architekturrelevant ist. Umgekehrt ist f\u00fcr einen Komponentenimplementierer die Architektur irrelevant. Was er zu implementieren hat, ergibt sich aus den Komponentenkontrakten, die seine Komponente importiert und exportiert. Einen gr\u00f6\u00dferen Zusammenhang muss er nicht kennen.</p> <p>Die Aufgabe der Architektur ist es mithin, Software in Komponenten zu zerlegen, deren Abh\u00e4ngigkeiten zu definieren und Leistungen in Kontrakten zu beschreiben. Diese Strukturen werden dann auch einzig durch Architekten gepflegt. Und die Aufgabe der Implementation ist es, die von der Architektur definierten Komponenten zu realisieren. Wie sie das tun, ist nicht architekturrelevant. Ihre innere Struktur ist f\u00fcr die Architektur unsichtbar.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Favour%20Composition%20over%20Inheritance/","title":"Favour Composition over Inheritance (FCoI)","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Favour%20Composition%20over%20Inheritance/#favour-composition-over-inheritance-fcoi","title":"Favour Composition over Inheritance (FCoI)","text":"<p>Warum? Komposition f\u00f6rdert die lose Kopplung und die Testbarkeit eines Systems und ist oft flexibler.</p> <p>F\u00fcr die Wiederverwendung von Funktionalit\u00e4t kennt die Objektorientierte Programmierung (OOP) zwei sehr bekannte Kandidaten: Die Vererbung (whitebox \u2013 reuse) und die Komposition (blackbox \u2013 reuse). Verwendet man Funktionalit\u00e4t wieder durch das Ableiten von einer Klasse, so ist die Subklasse abh\u00e4ngig von der Elternklasse. Dies macht ein System in vielen F\u00e4llen unn\u00f6tig komplex, schlechter testbar und erschwert das Austauschen von Funktionalit\u00e4t zur Laufzeit. Clean Code Developer hat f\u00fcr das korrekte Ableiten das Liskov Substitution Principle bereit, das es dabei zu befolgen gilt.</p> <p>Bei der Komposition verwendet eine Klasse eine andere. Verwendet man dazu eine klar definierte Schnittstelle, f\u00f6rdert das die Entkopplung. Auch k\u00f6nnen verschiedene Implementationen einfach ausgetauscht werden. Bevor man sich also der  stellt, fordert Favour Composition over Inheritance, sich die Frage zu stellen, ob man der Komposition nicht Vorrang geben kann.</p> <p>\u201eBecause inheritance exposes a subclass to details of its parent\u2019s implementation, it\u2019s often said that \u201ainheritance breaks encapsulation\u201e. (Gang of Four 1995:19)</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Implementation%20Reflects%20Design/","title":"Implementation Reflects Design","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Implementation%20Reflects%20Design/#implementation-reflects-design","title":"Implementation Reflects Design","text":"<p>Warum? Umsetzung, die von der Planung beliebig abweichen kann, f\u00fchrt direkt in die Unwartbarkeit. Umsetzung braucht daher einen durch die Planung vorgegebenen physischen Rahmen.</p> <p>Architektur und Implementation sollen nicht \u00fcberlappen, damit sie das DRY-Prinzip nicht verletzten. So werden Inkonsistenzen vermieden, die dadurch entstehen k\u00f6nnen, dass auf der einen Seite etwas ge\u00e4ndert wird, ohne diese \u00c4nderung auf der anderen Seite nachzuf\u00fchren.</p> <p>Nichtsdestotrotz macht die Architektur aber ja Aussagen \u00fcber die Implementation. Nicht ihre Details, aber ihre grunds\u00e4tzliche Form. Architektur definiert die Strukturelemente und deren Beziehungen innerhalb eines Codesystems. Implementation existiert also auch bei Abwesenheit von \u00dcberlappungen nicht unabh\u00e4ngig von Architektur, sondern sozusagen in ihr.</p> <p>Genau das sollte sich dann aber auch in der Implementation ausdr\u00fccken. So wird die leichter verst\u00e4ndlich, so kann besser sichergestellt werden, dass die Implementation tats\u00e4chlich der Architektur folgt. Die von der Architektur auf verschiedenen Abstraktionsebenen definierten Strukturelemente sollten deshalb nicht in einem gro\u00dfen \u201eCodetopf\u201c (z.b. eine gro\u00dfe Visual Studio Solution) \u201ezusammenger\u00fchrt werden\u201c. Viel besser auch im Sinne hoher Produktivit\u00e4t und einfacher Testbarkeit ist es, die logischen Strukturen der Architektur so physisch wie m\u00f6glich zu manifestieren.</p> <ol> <li>Die von der Architektur geplanten Strukturen auf verschiedenen Abstraktionsebenen sollten sich so weitgehend wie m\u00f6glich in der Codeorganisation widerspiegeln. Das bedeutet zum einen, dass die Architektur als Strukturelemente vor allem physische Codeeinheiten benutzt. Und zum anderen sollen diese Strukturelemente dann aber auch im Quellcode bzw. in der Codeorganisation im Repository klar sichtbar sein.</li> <li>Bei der Arbeit an der Implementation der Strukturelemente und insbesondere innerhalb von Komponenten sollen Architektur\u00e4nderungen \u201eim Vorbeigehen\u201c unm\u00f6glich sein. Wer in bzw. an einem Strukturelement arbeitet, also an einem Teil, darf nicht ad hoc die umliegende Struktur, d.h. das Ganze, \u00e4ndern k\u00f6nnen. Nur wenn das gew\u00e4hrleistet ist, w\u00e4chst die Entropie einer Software nicht unkontrolliert. Das ist wichtig, da das Hauptziel von Architektur ist, die Entropie und damit die Komplexit\u00e4t von Software zu minimieren.</li> </ol> <p>Planung muss sein. Implementation darf Planung nicht torpedieren. (Wenn auch Erkenntnisse w\u00e4hrend der Implementation nat\u00fcrlich auf die Planung zur\u00fcckwirken d\u00fcrfen.) Deshalb sind Planung und Implementation zu entkoppeln. Und wo das nicht m\u00f6glich ist, da sollte die Planung mit Mitteln der Implementation arbeiten und die Implementation physisch die Planung widerspiegeln.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Information%20Hiding%20Principle/","title":"Information Hiding Principle","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Information%20Hiding%20Principle/#information-hiding-principle","title":"Information Hiding Principle","text":"<p>Warum? Durch das Verbergen von Details in einer Schnittstelle werden die Abh\u00e4ngigkeiten reduziert.</p> <p>Beim Design einer Schnittstelle sollte man sich fragen, welche Details au\u00dfen unbedingt sichtbar sein m\u00fcssen. Mit Schnittstelle sind hier nicht nur Interfaces im objektorientierten Sinne gemeint, sondern auch implizite Schnittstellen. Jede Klasse hat zwangsl\u00e4ufig eine implizite Schnittstelle \u2013 sie enth\u00e4lt alle nach au\u00dfen sichtbaren Details. Je mehr Details von au\u00dfen sichtbar sind, desto h\u00f6her ist die Kopplung zwischen der Klasse und ihren Verwendern. Benutzen die Verwender einer Klasse erstmal ein Detail, wird es schwerer, dieses Detail zu ver\u00e4ndern. Dies steht der Wandelbarkeit der Software entgegen.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Integration%20Operation%20Segregation%20Principle%20%28IOSP%29/","title":"Integration Operation Segregation Principle (IOSP)","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Integration%20Operation%20Segregation%20Principle%20%28IOSP%29/#integration-operation-segregation-principle-iosp","title":"Integration Operation Segregation Principle (IOSP)","text":"<p>Warum? Ein deutliches Symptom schlecht wandelbaren Codes sind tiefe Hierarchien funktionaler Abh\u00e4ngigkeit. Sie reduzieren die Verst\u00e4ndlichkeit und erschweren automatisierte Tests wie Refactoring.</p> <p>Indem in Methoden verhaltenserzeugende Anweisungen (Logik) gemischt mit Aufrufen anderer Methoden derselben Codebasis steht, ist nicht mehr klar erkennbar, wie Gesamtverhalten\u2003entsteht; die Anweisungen sind ja verschmiert\u2003\u00fcber eine u.U. sehr tiefe Hierarchie. Zudem tendieren Methoden mit solcher Mischung dazu, unbegrenzt zu wachsen.</p> <p>Dem stellt sich das IOSP mit einer klaren Trennung entgegen:</p> <ul> <li>Entweder enth\u00e4lt eine Methode nur Logik, d.h. Transformationen, Kontrollstrukturen oder I/O- bzw. allgemeiner: API-Aufrufe. Dann wird sie\u2003Operation\u2003genannt.</li> <li>Oder eine Methode enth\u00e4lt keinerlei Logik, sondern nur Aufrufe von anderen Methoden derselben Codebasis. Dann wird sie\u2003Integration\u2003genannt.</li> </ul> <p>Diese strikte Unterscheidung f\u00fchrt zu mehrerlei positiven Effekten:</p> <ol> <li>Methoden tendieren dazu, sehr kurz zu bleiben. Denn mehr als 10, 20 oder 30 Zeilen reine Logik oder ausschlie\u00dflich Methodenaufrufe \u201ef\u00fchlen sich nicht gut an\u201c. Da eine Mischung nicht erlaubt ist, werden weitere kleine Methoden extrahiert.</li> <li>Kurze Methoden, die nur Logik enthalten, sind leicht zu testen, da sie keine Abh\u00e4ngigkeiten haben.</li> <li>Kurze Methoden, die nur Logik enthalten, sind vergleichsweise leicht zu verstehen. Der Methodenname kann wirklich bedeutungsstiftend wirken.</li> <li>Kurze Methoden, die ausschlie\u00dflich integrieren, sind sehr gut zu verstehen und beschreiben \u201eauf einen Blick\u201c, was geschieht.</li> <li>Die Korrektheit von Integrationen l\u00e4sst sich sehr leicht durch Augenscheinnahme pr\u00fcfen. Es ist lediglich festzustellen, ob Verarbeitungsschritte grunds\u00e4tzlich in der korrekten Reihenfolge angeordnet sind. Den Rest \u00fcbernimmt der Compiler \u2013 bzw. die Testabdeckung der Operationen.</li> <li>Integrationen lassen sich leicht durch \u201eZwischenschieben\u201c weiterer Methoden erweitern, um neue Anforderungen zu erf\u00fcllen. Die Verst\u00e4ndlichkeit bleibt dabei erhalten.</li> </ol> <p>Das IOSP l\u00e4sst sich \u201eaus dem Stand\u201c von jedem Entwickler guten Willens anwenden. Seine Einhaltung ist durch jedermann leicht zu \u00fcberpr\u00fcfen. Integrationen und Operationen unterscheiden sich in der Form deutlich. Weitere Details, insbesondere zur Abgrenzung zum\u2003Dependency Inversion Principle,\u2003findest du bspw. hier.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Interface%20Segragation%20Principle/","title":"Interface Segregation Principle (ISP)","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Interface%20Segragation%20Principle/#interface-segregation-principle-isp","title":"Interface Segregation Principle (ISP)","text":"<p>Warum?</p> <p>Leistungsbeschreibungen, die unabh\u00e4ngig von einer konkreten Erf\u00fcllung sind, machen unabh\u00e4ngig.</p> <p>Das Interface Segregation Principle (ISP) ist ein weiteres\u2003SOLID\u2003Prinzip.\u2003Segregation\u2003bedeutet\u2003Abtrennung. Das Prinzip besagt, dass ein Client nicht von Details eines Service abh\u00e4ngig sein soll, die er gar nicht ben\u00f6tigt. Je weniger in dessen Interface enthalten ist, desto geringer ist die Kopplung zwischen den beiden Komponenten.</p> <p>Stellen wir uns vor, wir m\u00fcssten einen Stecker planen, mit dem ein Monitor an einen Computer angeschlossen werden soll. Wir entscheiden uns, einfach alle Signale die in einem Computer so anfallen, per Stecker zur Verf\u00fcgung zu stellen. Der hat dann zwar einige Hundert Pins, aber daf\u00fcr ist er maximal flexibel. Dummerweise ist damit die Kopplung ebenfalls maximal.</p> <p>Beim Beispiel des Steckers ist es offensichtlich, dass eine Monitorverbindung nur jene Signale enthalten soll, die zur Darstellung eines Bildes auf dem Monitor erforderlich sind. Genauso verh\u00e4lt es sich mit Software Interfaces. Auch sie sollten so klein wie m\u00f6glich sein, um unn\u00f6tige Kopplung zu vermeiden. Und genau wie beim Monitorstecker sollte das Interface eine hohe Koh\u00e4sion haben: Es sollte nur Dinge enthalten, die wirklich eng zusammen geh\u00f6ren.</p> <p>Um das Interface Segregation Principle anzuwenden, stehen die beiden Refaktorisierungen\u2003Extract Interface\u2003und\u2003Extract Superclass\u2003zur Verf\u00fcgung.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/KISS/","title":"Keep it simple, stupid (KISS)","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/KISS/#keep-it-simple-stupid-kiss","title":"Keep it simple, stupid (KISS)","text":"<p>Warum? Wer mehr tut als das Einfachste, l\u00e4sst den Kunden warten und macht die L\u00f6sung unn\u00f6tig kompliziert.</p> <p>Oder um es mit Albert Einsteins Worten zu sagen: </p> <p>\u201eAlles sollte so einfach wie m\u00f6glich gemacht werden, aber nicht einfacher.\u201c</p> <p>F\u00fcr die Wandelbarkeit des Codes ist zwingende Voraussetzung, dass der Code verst\u00e4ndlich ist. Eine einfache, klare und leicht verst\u00e4ndliche L\u00f6sung sollte daher immer bevorzugt werden. Wenn man seinen eigenen Code nach kurzer Zeit schon nicht mehr versteht, sollten die Alarmglocken klingen. Noch wichtiger aber ist, dass auch andere Entwickler den Code schnell verstehen k\u00f6nnen. Dabei helfen regelm\u00e4\u00dfige Code Reviews und Pair Programming. Sie dienen der Kontrolle, ob tats\u00e4chlich die einfachste L\u00f6sung verwendet wurde.</p> <p>Gerade in technischen Details steckt die Versuchung, eine komplizierte L\u00f6sung anzustreben. Das Bekannte, naheliegende ist manchmal zu \u201elangweilig\u201c \u2013 und schon hat sich eine komplizierte L\u00f6sung eingeschlichen. Wenn die einfache L\u00f6sung auch funktioniert, sollte ihr Vorrang gew\u00e4hrt werden. Das gleiche gilt f\u00fcr Datenstrukturen. Wenn ein IEnumerable reicht, sollte keine ICollection oder sogar IList verwendet werden.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Law%20of%20Demeter/","title":"Law of Demeter","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Law%20of%20Demeter/#law-of-demeter","title":"Law of Demeter","text":"<p>Warum? Abh\u00e4ngigkeiten von Objekten \u00fcber mehrere Glieder einer Dienstleistungskette hinweg f\u00fchren zu unsch\u00f6n enger Kopplung.</p> <p>Beim\u2003Law of Demeter\u2003geht es darum, das Zusammenspiel von Objekten auf ein gesundes Ma\u00df zu beschr\u00e4nken. Man kann es vereinfacht umschreiben mit \u201eDon\u2019t talk to strangers\u201c. Nach dem Law of Demeter soll eine Methode nur folgende andere Methoden verwenden:</p> <ul> <li>Methoden der eigenen Klasse</li> <li>Methoden der Parameter</li> <li>Methoden assoziierter Klassen</li> <li>Methoden selbst erzeugter Objekte</li> </ul> <p>Allerdings: Es ist zu ber\u00fccksichtigen, dass ab und zu auch reine Datenhaltungsklassen Sinn ergeben. Auf diese muss man das Law of Demeter nat\u00fcrlich nicht anwenden. Es kann z.B. durchaus sinnvoll sein, die Konfigurationsdaten in mehrere Klassen hierarchisch zu verteilen, so dass sich am Ende folgender Zugriff auf einen Wert ergeben k\u00f6nnte:</p> <pre><code>int margin = config.Pages.Margins.Left;\n</code></pre> <p>W\u00fcrde man hier das Law of Demeter anwenden, w\u00e4re nur der Zugriff auf config.Pages gestattet.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Liskov%20Substitution%20Principle/","title":"Liskov Substitution Principle","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Liskov%20Substitution%20Principle/#liskov-substitution-principle","title":"Liskov Substitution Principle","text":"<p>Warum?</p> <p>Wer mit Erben zu tun hat, m\u00f6chte keine \u00dcberraschungen erleben, wenn er mit Erblassern vertraut ist.</p> <p>Auch das Liskov Substitution Principle (LSP) ist ein\u2003SOLID\u2003Prinzip. Es besagt, dass Subtypen sich so verhalten m\u00fcssen wie ihr Basistyp. Dies klingt zun\u00e4chst banal. Am Beispiel von Exceptions wird deutlich, welche Probleme entstehen, wenn das Prinzip verletzt wird: L\u00f6st der Basistyp bei der Ausf\u00fchrung einer Methode keine Exception aus, m\u00fcssen alle Subtypen sich an diese Regel halten. L\u00f6st die Methode eines Subtyps dennoch eine Exception aus, w\u00fcrde dies bei Verwendern, die ein Objekt vom Basistyp erwarten, Probleme verursachen, weil sie nicht darauf vorbereitet sind. Wenn der Basistyp an der Stelle keine Exception ausl\u00f6st, ist der Verwender nicht darauf eingestellt, Exceptions behandeln zu m\u00fcssen.</p> <p>Allgemeiner kann man das Prinzip auch so ausdr\u00fccken, dass ein Subtyp die Funktionalit\u00e4t eines Basistyps lediglich erweitern, aber nicht einschr\u00e4nken darf. Wenn eine Methode im Basistyp auf einem bestimmten Wertebereich definiert ist, darf der Subtyp diesen Wertebereich \u00fcbernehmen oder auch erweitern, er darf ihn jedoch keinesfall einschr\u00e4nken.</p> <p>Aus dem Liskov Substitution Principle ergibt sich ferner die Empfehlung, \u00fcber Vererbung sehr genau nachzudenken. In den allermeisten F\u00e4llen ist die Komposition der Vererbung vorzuziehen (Favour Composition over Inheritance). Bei der Vererbung sollte man in jedem Fall \u00fcber das Verhalten nachdenken, nicht nur \u00fcber die Struktur. Statt Vererbung als_is-a_\u2003Relation zu betrachten und dabei nur die (Daten-)Struktur zu bedenken, sollte man besser von einer\u2003behaves-as\u2003Relation ausgehen und das Verhalten der Klasse ber\u00fccksichtigen.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Open%20Closed%20Principle/","title":"Open Closed Principle (OCP)","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Open%20Closed%20Principle/#open-closed-principle-ocp","title":"Open Closed Principle (OCP)","text":"<p>Warum?</p> <p>Weil das Risiko, durch neue Features ein bisher fehlerfreies System zu instabilisieren, so gering wie m\u00f6glich gehalten werden sollte.</p> <p>Das\u2003Open Closed Principle (OCP) besagt, dass eine Klasse offen f\u00fcr Erweiterungen sein muss, jedoch geschlossen gegen\u00fcber Modifikationen. Es ist ein weiteres der SOLID-Prinzipien</p> <p>Prinzipien. Folgendes Codebeispiel soll verdeutlichen, wo das Problem liegt, wenn das Prinzip nicht befolgt wird:</p> <pre><code>public double Preis() {\n\n&amp;emsp; &amp;emsp; const decimal StammkundenRabatt = 0.95m;\n\n&amp;emsp; &amp;emsp; switch(kundenart) {\n\n&amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; case Kundenart.Einmalkunde:\n\n&amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; return menge * einzelpreis;\n\n&amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; case Kundenart.Stammkunde:\n\n&amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; return menge * einzelpreis * StammkundenRabatt;\n\n&amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; default:\n\n&amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; throw new ArgumentOutOfRangeException();\n\n&amp;emsp; &amp;emsp; }\n&amp;emsp; &amp;emsp; \n}\n</code></pre> <p>Das problematische an dieser Form der Implementierung ist, dass die Klasse modifiziert werden muss, wenn eine weitere Art der Preisberechnung erforderlich wird. Die Gefahr dabei ist, dass bei dieser Modifikation Fehler gemacht werden und die bisher schon vorhandenen Funktionen nicht mehr ordnungsgem\u00e4\u00df funktionieren. Auch wenn automatisierte Unit Tests und Integrationstests vorhanden sind besteht das Risiko, neue Bugs zu hinterlassen, weil man keine hundertprozentige Testabdeckung erreichen kann. Gesucht ist also generell ein Verfahren, welches die Klasse erweiterbar macht, ohne dass dazu die Klasse selbst modifiziert werden muss. Dies kann z.B. mit Hilfe des\u2003Strategy Patterns erreicht werden:</p> <pre><code>public interface IPreisRechner {\n\n&amp;emsp; &amp;emsp; double Preis(int menge, double einzelpreis);\n\n}\n\nprivate IPreisRechner preisRechner;\n\npublic double Preis() {\n&amp;emsp; &amp;emsp; return preisRechner.Preis(menge, einzelpreis);\n} \n\npublic class Einmalkunde : IPreisRechner {\n\n&amp;emsp; &amp;emsp; public double Preis(int menge, double einzelpreis) {\n&amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; return menge * einzelpreis;\n&amp;emsp; &amp;emsp; }\n\n}\npublic class Stammkunde : IPreisRechner {\n\n&amp;emsp; &amp;emsp; const decimal StammkundenRabatt = 0.95m;\n&amp;emsp; &amp;emsp; \n&amp;emsp; &amp;emsp; public double Preis(int menge, double einzelpreis) {\n&amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; return menge * einzelpreis * StammkundenRabatt;\n&amp;emsp; &amp;emsp; }\n\n}\n</code></pre> <p>Die konkrete Berechnung des Preises wird \u00fcber ein Interface in andere Klassen ausgelagert. Dadurch ist es m\u00f6glich, jederzeit neue Implementierungen des Interfaces zu erg\u00e4nzen. Damit ist die Klasse offen f\u00fcr Erweiterungen, gleichzeitig aber geschlossen gegen\u00fcber Modifikationen. Bestehender Code kann z.B. mit dem Refactoring Replace Conditional with Strategy so umgestaltet werden, dass das Open Closed Principle eingehalten wird.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Principle%20of%20Least%20Astonishment/","title":"Principle of Least Astonishment","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Principle%20of%20Least%20Astonishment/#principle-of-least-astonishment","title":"Principle of Least Astonishment","text":"<p>Warum? Wenn sich eine Komponente \u00fcberraschenderweise anders verh\u00e4lt als erwartet, wird ihre Anwendung unn\u00f6tig kompliziert und fehleranf\u00e4llig.</p> <p>Softwareentwicklung ist in hohem Ma\u00dfe ein kreativer Prozess. In diesem Prozess ist es wichtig, in den Fluss einzutauchen (engl. Flow). Wenn man diesen Zustand erreicht hat, sprudelt der Code nur so heraus. Jegliche St\u00f6rung des Flow f\u00fchrt zu Unterbrechungen und letztlich dazu, dass in der zur Verf\u00fcgung stehenden Zeit nur wenig Code produziert wird bzw. die Qualit\u00e4t des Code nicht optimal ist. Denn nach jeder Unterbrechung muss der Entwickler erst wieder Fahrt aufnehmen und erneut in den Fluss zu kommen. \u00dcberraschungen stellen St\u00f6rungen dar. Sie f\u00fchren zu Unterbrechungen und Fehlern. Dazu ein Beispiel: Ist die Tastenbelegung in der Entwicklungsumgebung so gew\u00e4hlt, dass eine \u00fcbliche Tastenkombination wie z.B. Ctrl-C eine v\u00f6llig andere Bedeutung hat, behindert dies den Entwickler. Ein Entwickler wird sich jedes mal \u00e4rgern, wenn er die \u201efalsche\u201c Tastenkombination verwendet. Dies behindert kreatives Arbeiten.</p> <p>Software sollte \u00fcberraschungsarm implementiert sein. Wenn eine Abfragemethode namens\u2003<code>GetValue()</code>\u2003nicht nur einen Wert liefert, sondern gleichzeitig den Zustand des Systems \u00e4ndert, wird der Entwickler diese Methode im besten Fall meiden, da er mit b\u00f6sen \u00dcberraschungen rechnet. Im ung\u00fcnstigen Fall f\u00e4llt ihm dieses merkw\u00fcrdige Verhalten nicht rechtzeitig auf. (Abfragemethoden die den Zustand \u00e4ndern, versto\u00dfen gegen das\u2003Command Query Separation\u2003Prinzip). Die Test-Driven-Development f\u00f6rdert \u00fcberraschungsarme Schnittstellen, da die Schnittstelle aus der Sichtweise ihrer Verwendung entworfen und implementiert wird.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Separation%20of%20Concerns/","title":"Separation of Concerns (SoC)","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Separation%20of%20Concerns/#separation-of-concerns-soc","title":"Separation of Concerns (SoC)","text":"<p>Warum? Wenn eine Codeeinheit keine klare Aufgabe hat, ist es schwer sie zu verstehen, sie anzuwenden und sie ggf. zu korrigieren oder zu erweitern.</p> <p>\u00dcbersetzt mit Trennung der Belange bedeutet dieses Prinzip, dass man nicht mehrere Belange in einer Klasse zusammenfassen soll. Was sind Belange? Belange sind \u201ekomplett verschiedene\u201c Zwecke. Man sagt auch, Belange seien orthogonal zu einander und vor allem orthogonal zur Hauptfunktionalit\u00e4t einer Funktionseinheit. Beispiele f\u00fcr typische Belange sind: Tracing, Logging, Transaktionalit\u00e4t, Caching. Diese Belange sollen nach dem Prinzip der Separation of Concerns in spezialisierte Funktionseinheiten ausgelagert werden.</p> <p>Das Separation of Concerns Prinzip h\u00e4ngt eng mit dem Single Responsibility Prinzip zusammen. Dabei sind Concerns eine \u00dcbermenge von Responsibilities. Jede Responsibility besteht im Idealfall aus genau einem Concern, n\u00e4mlich ihrer Kernfunktionalit\u00e4t. Oft sind in einer Responsibility jedoch mehrere Concerns vermischt. Da sich dies technisch meist nicht ganz vermeiden l\u00e4\u00dft, besagt das Prinzip nicht etwa, dass eine Responsibility nur aus einem Concern bestehen darf, sondern dass die Concerns getrennt sein sollten. Innerhalb einer Methode sollte beispielsweise klar erkennbar sein, dass es mehrere Concerns gibt. Ferner sollten die Concerns nicht irgendwie \u00fcber die Methode verstreut sein, sondern so gruppiert, dass klar ist, was zu einem Concern geh\u00f6rt.</p> <p>Im Domain Driven Design versucht man beispielsweise die Business Domain von der Infrastruktur strikt zu trennen. So darf dort eine Klasse aus der Business Domain keinerlei Infrastruktur, etwa f\u00fcr Datenbankzugriffe, enthalten, sondern soll ausschlie\u00dflich die Gesch\u00e4ftslogik abbilden. Persistenz ist ein \u201eConcern\u201c der nichts mit der Business Logik zu tun hat. Separation of Concerns f\u00fchrt zu loser Kopplung und hoher Koh\u00e4sion. Die einzelnen Komponenten sind jeweils auf eine Aufgabe, einen Concern, fokussiert und dadurch leicht verst\u00e4ndlich. Alle Teile aus denen die Komponente besteht, sind auf diese eine Aufgabe ausgerichtet, dadurch h\u00e4ngen die Teile eng zusammen (hohe Koh\u00e4sion). Separation of Concerns f\u00fchrt dar\u00fcber hinaus auch zu gut testbaren Komponenten. Denn wenn der Zweck einer Codeeinheit fokussiert ist, muss weniger breit getestet werden. In Bezug auf die zu testende Codeeinheit sind weniger Testparameterkombinationen zu pr\u00fcfen. Soll die Trennung der Belange konsequent betrieben werden, muss die Objektorientierung um das Konzept der Aspektorientierten Programmierung (AOP) erweitert werden. Dadurch wird es m\u00f6glich, Aspekte wie etwa Transaktionalit\u00e4t, Tracing oder Caching vollst\u00e4ndig aus einer Methode herauszuziehen.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Single%20Level%20of%20Abstraction/","title":"Single Level of Abstraction (SLA)","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Single%20Level%20of%20Abstraction/#single-level-of-abstraction-sla","title":"Single Level of Abstraction (SLA)","text":"<p>Warum? Die Einhaltung eines Abstraktionsniveaus f\u00f6rdert die Lesbarkeit</p> <p>Eine Codezeile kann auf verschiedenen Abstraktionsniveaus liegen. Die Zuweisung eines Wertes an eine Variable liegt auf einem niedrigeren Abstraktionsniveau als etwa ein Methodenaufruf. Schlie\u00dflich kann sich hinter dem Methodenaufruf weit mehr Logik befinden als in der Zuweisung einer Variable. Selbst Methodenaufrufe k\u00f6nnen auf unterschiedlichen Abstraktionsniveaus stehen. Der Aufruf einer Methode aus einem Framework steht auf einem anderen Niveau, als der Aufruf einer Methode der Anwendung.</p> <p>Damit Code gut zu lesen und zu verstehen ist, sollte in einer Methode nur ein Abstraktionsniveau verwendet werden. Andernfalls f\u00e4llt es dem Leser schwer, Essentielles von Details zu unterscheiden. Wenn Bitpfriemeleien erforderlich sind, sollten diese nicht mit dem Aufruf von Methoden vermischt werden.</p> <p>Hilfreich als Analogie ist der Blick auf Artikel in der Tageszeitung: dort steht zu oberst das Allerwichtigste, die \u00dcberschrift. Aus ihr sollte in groben Z\u00fcgen hervorgehen, wovon der Artikel handelt. Im ersten Satz des Artikels wird dies auf einem hohen Abstraktionsniveau beschrieben. Je weiter man im Artikel fortschreitet, desto mehr Details tauchen auf. So k\u00f6nnen wir auch unseren Code strukturieren. Der Name der Klasse ist die \u00dcberschrift. Dann folgen die \u00f6ffentlichen Methoden auf hohem Abstraktionsniveau. Diese rufen m\u00f6glicherweise Methoden auf niedrigerem Niveau auf, bis zuletzt die \u201eBitpfriemelmethoden\u201c \u00fcbrig bleiben. Durch diese Einteilung kann ich als Leser der Klasse entscheiden, welchen Detaillierungsgrad ich mir ansehen m\u00f6chte. Interessiert mich nur grob, wie die Klasse arbeitet, brauche ich mir nur die \u00f6ffentlichen Methoden anzuschauen. In ihnen wird die Funktionalit\u00e4t auf einem hohen Abstraktionsniveau gel\u00f6st. Interessieren mich weitere Details, kann ich tiefer einsteigen und mir die privaten Methoden ansehen.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Single%20Responsibility%20Principle/","title":"Single Responsibility Principle (SRP)","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Single%20Responsibility%20Principle/#single-responsibility-principle-srp","title":"Single Responsibility Principle (SRP)","text":"<p>Warum?</p> <p>Fokus erleichtert das Verst\u00e4ndnis. Eine Klasse mit genau einer Aufgabe ist verst\u00e4ndlicher als ein Gemischtwarenladen.</p> <p>Das Single Responsibility Principle (SRP) ist eines der\u2003SOLID\u2003Prinzipien. Es lautet: Eine Klasse sollte nur\u2003eine\u2003Verantwortlichkeit haben.</p> <p>Hintergrund des Single Responsibility Principle ist die \u00dcberlegung, dass \u00c4nderungen oder Erweiterungen der Funktionalit\u00e4t einer Anwendung sich auf wenige Klassen beschr\u00e4nken sollen. Je mehr Klassen angepasst werden m\u00fcssen, desto gr\u00f6\u00dfer ist das Risiko, dass sich durch die erforderlichen \u00c4nderungen Probleme an Stellen ergeben, die im Kern nichts mit der Erweiterung zu tun haben. Eine Verletzung des Single Responsibility Principle f\u00fchrt zu Kopplung und damit zu erh\u00f6hter Komplexit\u00e4t, es wird schwieriger den Code zu verstehen.</p> <p>Sources:</p> <ul> <li>https://clean-code-developer.de/die-grade/orangener-grad/Single_Responsibility_Principle_SRP</li> <li>https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html</li> </ul>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Source%20Code%20Conventions/","title":"Source Code Conventions","text":"","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Source%20Code%20Conventions/#source-code-conventions","title":"Source Code Conventions","text":"<p>Warum? Code wird h\u00e4ufiger gelesen als geschrieben. Daher sind Konventionen wichtig, die ein schnelles Lesen und Erfassen des Codes unterst\u00fctzen.</p> <p>Wir betrachten die folgenden Aspekte als wichtig:</p> <ul> <li>Namensregeln</li> <li>Richtig Kommentieren</li> </ul> <p>Damit wollen wir nicht zum Ausdruck bringen, dass andere Konventionen unwichtig sind, wir wollen nur mit diesen beiden beginnen, weil sie uns elementar erscheinen. Bei allen Code Konventionen ist uns n\u00e4mlich eines ganz wichtig: es geht weniger um die konkrete Ausgestaltung, sondern um konsequentes Einhalten der Konvention. Und es geht um das Bewusstsein, dass Konventionen notwendig sind.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Source%20Code%20Conventions/#namensregeln","title":"Namensregeln","text":"<p>Warum? Ohne Namensregeln muss man sich wieder und wieder auf den Stil einzelner Entwickler einstimmen.</p> <p>Namensregeln sollen den Leser des Codes dabei unterst\u00fctzen den Code zu verstehen. Da es z.B. hilfreich ist, Felder von lokalen Variablen zu unterscheiden, k\u00f6nnte dies durch eine Namensregel unterst\u00fctzt werden. Wie eine solche Konvention im Einzelfall aussieht ist Geschmacksache. Manche bevorzugen \u201ethis.xyz\u201c andere \u201e_xyz\u201c. Welche Variante man w\u00e4hlt ist uns nicht wichtig. Uns kommt es darauf an, dass die Konvention konsequent eingehalten wird. Die Notwendigkeit einer Namensregel f\u00fcr z.B. Felder h\u00e4ngt ferner vom Kontext ab. In einer Klasse mit 400 Zeilen w\u00e4re uns eine Namensregel, die Felder gegen\u00fcber Variablen hervorhebt, sehr wichtig, in \u00fcberschaubaren Klassen tritt sie dagegen eher in den Hintergrund. Mit Hilfe der Root Cause Analysis geht der Clean Code Developer der eigentlichen Ursache f\u00fcr die Notwendigkeit einer Namensregel auf den Grund.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/Source%20Code%20Conventions/#richtig-kommentieren","title":"Richtig kommentieren","text":"<p>Warum? Unn\u00f6tige oder gar falsche Kommentare halten beim Lesen auf. Der Code sollte so klar und deutlich sein, dass er m\u00f6glichst ohne Kommentare auskommt.</p> <p>Salopp gesagt ist ein Kommentar im Code ein Hinweis darauf, dass der Code noch verbessert werden kann. Typisch f\u00fcr solche F\u00e4lle sind 3 Zeilen Code, die mit einem Kommentar \u00fcberschrieben sind. An der Stelle hilft es wahrscheinlich, die drei Zeilen als Methode zu extrahieren (Refactoring: Extract Method) und den Kommentar als Name der Methode zu verwenden. Ganz allgemein kann der Bedarf an Kommentaren reduziert werden, in dem man gute Namen verwendet f\u00fcr Variablen, Methoden, Klassen, etc.</p> <p>Statt <pre><code>int laenge; // in mm\n</code></pre> besser <pre><code>int laengeInMM;\n</code></pre></p> <p>Statt <pre><code>public double Preis() {\n\t// Berechnet den Bruttopreis ...\n}\n</code></pre> besser <pre><code>public Money BruttoPreis() {\n\t...\n}\n</code></pre></p> <p>Kommentiert werden sollte nicht was man tut, sondern, wenn \u00fcberhaupt, wieso man etwas tut.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Clean%20Code%20Developer/Prinzipien/YAGNI/","title":"You Ain\u2019t Gonna Need It","text":"<p>$# You Ain\u2019t Gonna Need It </p> <p>Warum? Dinge die niemand braucht, haben keinen Wert. Verschwende an sie also keine Zeit.</p> <p>Das YAGNI-Prinzip (You Ain\u00b4t Gonna Need It) ist eines der einfachsten in der Softwareentwicklung \u2013 und doch wohl das nach dem DRY-Prinzip am h\u00e4ufigsten verletzte Prinzip. Deshalb steht YAGNI nicht nur am Anfang des\u2003roten Grades, sondern auch hier gegen Ende des Weges durch das\u2003Wertesystem.</p> <p>Geschuldet ist das YAGNI-Prinzip dem in der Softwareentwicklung besonderen Verh\u00e4ltnis von Anforderungsgenauigkeit und Produktmaterialit\u00e4t. Anforderungen sind notorisch ungenau oder wechselnd und das Produkt, in dem sie umgesetzt werden sollen, immateriell. Im Vergleich zum Maschinen- oder Geb\u00e4udebau ist das Material also unendlich flexibel und kann sich prinzipiell mit vergleichsweise wenig Aufwand an quasi jede Anforderung anpassen lassen. Hohe Volatili\u00e4t bzw. Ungenauigkeit trifft also auf hohe Flexibilit\u00e4t. Das scheint zun\u00e4chst einmal ideal.</p> <p>Die Praxis zeigt jedoch, dass gerade in diesem Verh\u00e4ltnis der Keim des Misserfolges vieler Projekte liegt. Kurzfristig betrachtet, versuchen die Projekte mit dem Naheliegenden auch das Richtige zu tun:</p> <ul> <li>Ungenaue Anforderungen werden oft kompensiert durch Produkte, die versuchen, die Ungenauigkeit zu kompensieren. Die Immaterialit\u00e4t von Software wird dazu genutzt, so breit und flexibel zu implementieren, dass auch noch unbekannte oder schwammige Anforderungen quasi schon im vorauseilenden Gehorsam erf\u00fcllt werden.</li> <li>St\u00e4ndig wechselnde Anforderungen werden im Produkt m\u00f6glichst schnell nachgef\u00fchrt, weil das dank seiner Immaterialit\u00e4t m\u00f6glich ist.</li> </ul> <p>Langfristig ist solches Verhalten allerdings kontraproduktiv:</p> <ul> <li>Der vorauseilende Gehorsam f\u00fchrt zu Breite und Flexibilit\u00e4t, die nicht wirklich gebraucht werden. Er realisiert Features, die keine Anwendung finden.</li> <li>Schnelle Umbauten an Software aufgrund wechselnder Anforderungen f\u00fchren zu Qualit\u00e4tserosionen im Code. Software ist zwar immateriell und flexibel \u2013 aber nicht jede Softwarestruktur ist evolvierbar oder auch nur verst\u00e4ndlich.</li> </ul> <p>Unklare und wechselnde Anforderungssituationen vor dem Hintergrund der hohen grunds\u00e4tzlichen Flexibilit\u00e4t von Software f\u00fchren schnell zu unn\u00f6tigen Aufw\u00e4nden und spr\u00f6dem Code. Eine gro\u00dfe Anzahl von Projekten, die ihre Budgetgrenzen gesprengt haben, und eine noch gr\u00f6\u00dfere Zahl von Projekten, die schon nach wenigen Jahren unwartbar geworden sind, sind daf\u00fcr beredtes Zeugnis.</p> <p>CCD als professionelle Softwareentwickler sehen es als ihre Pflicht, sich solcher Entwicklung jeden Tag entgegen zu stemmen. Angesichts der nicht zu leugnenden Natur von Software \u2013 sie ist und bleibt immateriell -, liegt der Ansatz daf\u00fcr beim Umgang mit den Anforderungen. Das ist der Ursprung des YAGNI-Prinzips.</p> <p>Das YAGNI-Prinzip ist wie ein scharfes Messer: Wer sie anwendet, schneidet ein Problem in kleine W\u00fcrfel des unmittelbar N\u00f6tigen. Nach dem YAGNI-Prinzip wird nur das unzweifelhaft und unmittelbar Nutzbringende implementiert. Alles andere\u2026 nun, das kommt sp\u00e4ter. Insofern geht YAGNI Hand in Hand mit der Regel \u201eEntscheide so sp\u00e4t wie m\u00f6glich\u201c des\u2003Lean Software Development.</p> <p>Das YAGNI-Prinzip ist relevant auf allen Ebenen der Softwareentwicklung und in allen Phasen. Wann immer Sie sich Fragen \u201eSollte ich diesen Aufwand wirklich treiben?\u201c oder \u201eBrauchen wir das wirklich?\u201c \u2013 und sei es auch nur ganz versch\u00e4mt und leise im Hinterkopf -, dann ist das ein Anwendungsfall f\u00fcr das YAGNI-Prinzip. Es besagt: Wenn im Zweifel, entscheide dich gegen den Aufwand.</p> <p>Das klingt leicht, ist aber schwer. Daher auch die h\u00e4ufigen Zuwiderhandlungen. Es gibt viele Kr\u00e4fte, die der Entscheidung gegen einen Aufwand widersprechen. \u201eAch, das ist doch gar nicht soviel Aufwand\u201c oder \u201eWenn wir jetzt nicht vorausschauen, dann k\u00f6nnen wir in Zukunft nicht mehr anders\u201c sind nur zwei naheliegende Begr\u00fcndungen f\u00fcr Aufwand, auch wenn Zweifel an seinem Nutzen bestehen. Das betrifft architektonische Entscheidungen (z.B. Soll schon mit einer verteilten Architektur begonnen werden, auch wenn die heutige Last sie noch nicht br\u00e4uchte?) wie lokale Entscheidungen (z.B. Soll der Algorithmus schon jetzt optimiert werden, auch wenn er im Augenblick noch keine Performanceprobleme macht?).</p> <p>Der Kunde bezahlt nur f\u00fcr unmittelbaren Nutzen. Was er heute nicht klar spezifizieren kann, nutzt ihm nicht. Es in der Implementation voraussehen zu wollen, investiert also Aufwand ohne Nutzen zu generieren. Wenn der Kunde sp\u00e4ter einmal genauer wei\u00df, was er will, dann \u2013 und nicht fr\u00fcher! \u2013 ist es Zeit, seinem Willen nachzukommen. Wo immer aber ein Projekt versucht, diesen Willen vorwegzunehmen riskiert es, von der morgigen Willensrealit\u00e4t des Kunden widerlegt zu werden. Ein Feature \u2013 funktional oder nicht-funktional -, das heute ohne klare Anforderung implementiert wird, interessiert den Kunden morgen vielleicht schon nicht mehr. Oder es ist ihm nicht mehr so wichtig wie ein anderes Feature.</p> <p>Das bedeutet f\u00fcr die Softwareentwicklung:</p> <ul> <li>Ausschlie\u00dflich klare Anforderungen implementieren.</li> <li>Der Kunde priorisiert seine klaren Anforderungen.</li> <li>Die klaren Anforderungen in der Reihenfolge ihrer Priorisierung umsetzen.</li> <li>Entwicklungsprozess und Codestruktur im Gro\u00dfen und Kleinen so aufsetzen, dass keine Angst aufkommt, sich \u00e4ndernde und neue Anforderungen zu realisieren.</li> </ul> <p>CCD als professionelle Entwickler kommunizieren diese Vorgehensweise unmissverst\u00e4ndlich dem Kunden gegen\u00fcber. Dadurch werden sie:</p> <ul> <li>servicewillig, denn sie m\u00fcssen dem Kunden keine klare Anforderung abschlagen</li> <li>verantwortungsbewusst, weil sie das Budget nur f\u00fcr klar formulierten Nutzen einsetzen</li> <li>besch\u00fctzend dem Code gegen\u00fcber, weil sie ihn gegen \u00dcberladung mit letztlich Unn\u00f6tigem bewahren</li> </ul> <p>YAGNI ist deshalb nicht nur ein Prinzip, das jeder Entwickler befolgen soll, sondern auch ein Prinzip f\u00fcr Projekte und Teams, also auf Organisationsebene. YAGNI ist immer in Anschlag zu bringen, genauso wie DRY. Wenn im Zweifel, dann verschiebe die Entscheidung falls m\u00f6glich. Ansonsten entscheide dich gegen den Aufwand. Das entspannt und entschlackt und f\u00fchrt schneller zum Erfolg.</p>","tags":["cleancode"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/","title":"Design Patterns","text":"","tags":["cleancode_designpatterns","cleancode_refactoring"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/#design-patterns","title":"Design Patterns","text":"<p>Design patterns\u2003are typical solutions to commonly occurring problems in software design. They are like pre-made blueprints that you can customize to solve a recurring design problem in your code</p>","tags":["cleancode_designpatterns","cleancode_refactoring"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/#creational","title":"Creational","text":"<p>These patterns provide various object creation mechanisms, which increase flexibility and reuse of existing code.</p> <ul> <li>Factory</li> <li>Abstract Factory</li> <li>Builder</li> <li>Prototype</li> <li>Singleton</li> </ul>","tags":["cleancode_designpatterns","cleancode_refactoring"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/#structural","title":"Structural","text":"<p>These patterns explain how to assemble objects and classes into larger structures while keeping these structures flexible and efficient. - Adapter - Bridge - Composite - Decorator - Facade - Flyweight - Proxy</p>","tags":["cleancode_designpatterns","cleancode_refactoring"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/#behavioral","title":"Behavioral","text":"<p>These patterns are concerned with algorithms and the assignment of responsibilities between objects. - Chain of Responsibility - Command - Iterator - Mediator - Memento - Observer - State - Strategy - Template Method - Visitor</p>","tags":["cleancode_designpatterns","cleancode_refactoring"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/#source","title":"Source","text":"<p>The initial Version of the listed Design Pattern pages will be a copy of Refactoring Guru</p>","tags":["cleancode_designpatterns","cleancode_refactoring"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Abstract%20Factory/","title":"Abstract Factory","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Abstract%20Factory/#abstract-factory","title":"Abstract Factory","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Abstract%20Factory/#intent","title":"Intent","text":"<p>Abstract Factory\u2003is a creational design pattern that lets you produce families of related objects without specifying their concrete\u2003classes.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Abstract%20Factory/#problem","title":"Problem","text":"<p>Imagine that you\u2019re creating a furniture shop simulator. Your code consists of classes that represent:</p> <ol> <li> <p>A family of related products, say:\u2003<code>Chair</code>\u2003+\u2003<code>Sofa</code>\u2003+\u2003<code>CoffeeTable</code>.</p> </li> <li> <p>Several variants of this family. For example, products\u2003<code>Chair</code>\u2003+\u2003<code>Sofa</code>\u2003+\u2003<code>CoffeeTable</code>\u2003are available in these variants:\u2003<code>Modern</code>,\u2003<code>Victorian</code>,\u2003<code>ArtDeco</code>.</p> </li> </ol> <p></p> <p>Product families and their\u2003variants.</p> <p>You need a way to create individual furniture objects so that they match other objects of the same family. Customers get quite mad when they receive non-matching furniture.</p> <p></p> <p>A Modern-style sofa doesn\u2019t match Victorian-style\u2003chairs.</p> <p>Also, you don\u2019t want to change existing code when adding new products or families of products to the program. Furniture vendors update their catalogs very often, and you wouldn\u2019t want to change the core code each time it happens.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Abstract%20Factory/#solution","title":"Solution","text":"<p>The first thing the Abstract Factory pattern suggests is to explicitly declare interfaces for each distinct product of the product family (e.g., chair, sofa or coffee table). Then you can make all variants of products follow those interfaces. For example, all chair variants can implement the\u2003<code>Chair</code>\u2003interface; all coffee table variants can implement the\u2003<code>CoffeeTable</code>\u2003interface, and so on.</p> <p></p> <p>All variants of the same object must be moved to a single class\u2003hierarchy.</p> <p>The next move is to declare the\u2003Abstract Factory\u2014an interface with a list of creation methods for all products that are part of the product family (for example,\u2003<code>createChair</code>,\u2003<code>createSofa</code>\u2003and\u2003<code>createCoffeeTable</code>). These methods must return\u2003abstract\u2003product types represented by the interfaces we extracted previously:\u2003<code>Chair</code>,\u2003<code>Sofa</code>,\u2003<code>CoffeeTable</code>\u2003and so on.</p> <p></p> <p>Each concrete factory corresponds to a specific product\u2003variant.</p> <p>Now, how about the product variants? For each variant of a product family, we create a separate factory class based on the\u2003<code>AbstractFactory</code>\u2003interface. A factory is a class that returns products of a particular kind. For example, the\u2003<code>ModernFurnitureFactory</code>\u2003can only create\u2003<code>ModernChair</code>,\u2003<code>ModernSofa</code>\u2003and\u2003<code>ModernCoffeeTable</code>\u2003objects.</p> <p>The client code has to work with both factories and products via their respective abstract interfaces. This lets you change the type of a factory that you pass to the client code, as well as the product variant that the client code receives, without breaking the actual client code.</p> <p></p> <p>The client shouldn\u2019t care about the concrete class of the factory it works\u2003with.</p> <p>Say the client wants a factory to produce a chair. The client doesn\u2019t have to be aware of the factory\u2019s class, nor does it matter what kind of chair it gets. Whether it\u2019s a Modern model or a Victorian-style chair, the client must treat all chairs in the same manner, using the abstract\u2003<code>Chair</code>\u2003interface. With this approach, the only thing that the client knows about the chair is that it implements the\u2003<code>sitOn</code>\u2003method in some way. Also, whichever variant of the chair is returned, it\u2019ll always match the type of sofa or coffee table produced by the same factory object.</p> <p>There\u2019s one more thing left to clarify: if the client is only exposed to the abstract interfaces, what creates the actual factory objects? Usually, the application creates a concrete factory object at the initialization stage. Just before that, the app must select the factory type depending on the configuration or the environment settings.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Abstract%20Factory/#structure","title":"Structure","text":"<ol> <li> <p>Abstract Products\u2003declare interfaces for a set of distinct but related products which make up a product family.</p> </li> <li> <p>Concrete Products\u2003are various implementations of abstract products, grouped by variants. Each abstract product (chair/sofa) must be implemented in all given variants (Victorian/Modern).</p> </li> <li> <p>The\u2003Abstract Factory\u2003interface declares a set of methods for creating each of the abstract products.</p> </li> <li> <p>Concrete Factories\u2003implement creation methods of the abstract factory. Each concrete factory corresponds to a specific variant of products and creates only those product variants.</p> </li> <li> <p>Although concrete factories instantiate concrete products, signatures of their creation methods must return corresponding\u2003abstract\u2003products. This way the client code that uses a factory doesn\u2019t get coupled to the specific variant of the product it gets from a factory. The\u2003Client\u2003can work with any concrete factory/product variant, as long as it communicates with their objects via abstract interfaces.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Abstract%20Factory/#pseudocode","title":"Pseudocode","text":"<p>This example illustrates how the\u2003Abstract Factory\u2003pattern can be used for creating cross-platform UI elements without coupling the client code to concrete UI classes, while keeping all created elements consistent with a selected operating system.</p> <p></p> <p>The cross-platform UI classes\u2003example.</p> <p>The same UI elements in a cross-platform application are expected to behave similarly, but look a little bit different under different operating systems. Moreover, it\u2019s your job to make sure that the UI elements match the style of the current operating system. You wouldn\u2019t want your program to render macOS controls when it\u2019s executed in Windows.</p> <p>The Abstract Factory interface declares a set of creation methods that the client code can use to produce different types of UI elements. Concrete factories correspond to specific operating systems and create the UI elements that match that particular OS.</p> <p>It works like this: when an application launches, it checks the type of the current operating system. The app uses this information to create a factory object from a class that matches the operating system. The rest of the code uses this factory to create UI elements. This prevents the wrong elements from being created.</p> <p>With this approach, the client code doesn\u2019t depend on concrete classes of factories and UI elements as long as it works with these objects via their abstract interfaces. This also lets the client code support other factories or UI elements that you might add in the future.</p> <p>As a result, you don\u2019t need to modify the client code each time you add a new variation of UI elements to your app. You just have to create a new factory class that produces these elements and slightly modify the app\u2019s initialization code so it selects that class when appropriate.</p> <pre><code>// The abstract factory interface declares a set of methods that\n// return different abstract products. These products are called\n// a family and are related by a high-level theme or concept.\n// Products of one family are usually able to collaborate among\n// themselves. A family of products may have several variants,\n// but the products of one variant are incompatible with the\n// products of another variant.\ninterface GUIFactory is\n    method createButton():Button\n    method createCheckbox():Checkbox\n\n// Concrete factories produce a family of products that belong\n// to a single variant. The factory guarantees that the\n// resulting products are compatible. Signatures of the concrete\n// factory's methods return an abstract product, while inside\n// the method a concrete product is instantiated.\nclass WinFactory implements GUIFactory is\n    method createButton():Button is\n        return new WinButton()\n    method createCheckbox():Checkbox is\n        return new WinCheckbox()\n\n// Each concrete factory has a corresponding product variant.\nclass MacFactory implements GUIFactory is\n    method createButton():Button is\n        return new MacButton()\n    method createCheckbox():Checkbox is\n        return new MacCheckbox()\n\n// Each distinct product of a product family should have a base\n// interface. All variants of the product must implement this\n// interface.\ninterface Button is\n    method paint()\n\n// Concrete products are created by corresponding concrete\n// factories.\nclass WinButton implements Button is\n    method paint() is\n        // Render a button in Windows style.\n\nclass MacButton implements Button is\n    method paint() is\n        // Render a button in macOS style.\n\n// Here's the base interface of another product. All products\n// can interact with each other, but proper interaction is\n// possible only between products of the same concrete variant.\ninterface Checkbox is\n    method paint()\n\nclass WinCheckbox implements Checkbox is\n    method paint() is\n        // Render a checkbox in Windows style.\n\nclass MacCheckbox implements Checkbox is\n    method paint() is\n        // Render a checkbox in macOS style.\n\n// The client code works with factories and products only\n// through abstract types: GUIFactory, Button and Checkbox. This\n// lets you pass any factory or product subclass to the client\n// code without breaking it.\nclass Application is\n    private field factory: GUIFactory\n    private field button: Button\n    constructor Application(factory: GUIFactory) is\n        this.factory = factory\n    method createUI() is\n        this.button = factory.createButton()\n    method paint() is\n        button.paint()\n\n// The application picks the factory type depending on the\n// current configuration or environment settings and creates it\n// at runtime (usually at the initialization stage).\nclass ApplicationConfigurator is\n    method main() is\n        config = readApplicationConfigFile()\n\n        if (config.OS == \"Windows\") then\n            factory = new WinFactory()\n        else if (config.OS == \"Mac\") then\n            factory = new MacFactory()\n        else\n            throw new Exception(\"Error! Unknown operating system.\")\n\n        Application app = new Application(factory)\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Abstract%20Factory/#applicability","title":"Applicability","text":"<ul> <li>Use the Abstract Factory when your code needs to work with various families of related products, but you don\u2019t want it to depend on the concrete classes of those products\u2014they might be unknown beforehand or you simply want to allow for future extensibility.     The Abstract Factory provides you with an interface for creating objects from each class of the product family. As long as your code creates objects via this interface, you don\u2019t have to worry about creating the wrong variant of a product which doesn\u2019t match the products already created by your app.<ul> <li>Consider implementing the Abstract Factory when you have a class with a set of\u2003Factory\u2003that blur its primary responsibility.</li> <li>In a well-designed program\u2003each class is responsible only for one thing. When a class deals with multiple product types, it may be worth extracting its factory methods into a stand-alone factory class or a full-blown Abstract Factory implementation.</li> </ul> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Abstract%20Factory/#how-to-implement","title":"How to Implement","text":"<ol> <li>Map out a matrix of distinct product types versus variants of these products.</li> <li>Declare abstract product interfaces for all product types. Then make all concrete product classes implement these interfaces.</li> <li>Declare the abstract factory interface with a set of creation methods for all abstract products.</li> <li>Implement a set of concrete factory classes, one for each product variant.</li> <li>Create factory initialization code somewhere in the app. It should instantiate one of the concrete factory classes, depending on the application configuration or the current environment. Pass this factory object to all classes that construct products.</li> <li>Scan through the code and find all direct calls to product constructors. Replace them with calls to the appropriate creation method on the factory object.W</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Abstract%20Factory/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can be sure that the products you\u2019re getting from a factory are compatible with each other. The code may become more complicated than it should be, since a lot of new interfaces and classes are introduced along with the pattern. You avoid tight coupling between concrete products and client code. Single Responsibility Principle. You can extract the product creation code into one place, making the code easier to support. Open Closed Principle. You can introduce new variants of products without breaking existing client code.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Abstract%20Factory/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).</li> <li>Builder focuses on constructing complex objects step by step. Abstract Factory specializes in creating families of related objects. Abstract Factory returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.</li> <li>Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.</li> <li>Abstract Factory can serve as an alternative to Facade when you only want to hide the way the subsystem objects are created from the client code.</li> <li>You can use Abstract Factory along with Bridge. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.</li> <li>Abstract Factory, Builder and Prototype can all be implemented as Singleton.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Adapter/","title":"Adapter","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Adapter/#adapter","title":"Adapter","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Adapter/#intent","title":"Intent","text":"<p>Adapter\u2003is a structural design pattern that allows objects with incompatible interfaces to\u2003collaborate.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Adapter/#problem","title":"Problem","text":"<p>Imagine that you\u2019re creating a stock market monitoring app. The app downloads the stock data from multiple sources in XML format and then displays nice-looking charts and diagrams for the user.</p> <p>At some point, you decide to improve the app by integrating a smart 3rd-party analytics library. But there\u2019s a catch: the analytics library only works with data in JSON format.</p> <p></p> <p>You can\u2019t use the analytics library \u201cas is\u201d because it expects the data in a format that\u2019s incompatible with your\u2003app.</p> <p>You could change the library to work with XML. However, this might break some existing code that relies on the library. And worse, you might not have access to the library\u2019s source code in the first place, making this approach impossible.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Adapter/#solution","title":"Solution","text":"<p>You can create an\u2003adapter. This is a special object that converts the interface of one object so that another object can understand it.</p> <p>An adapter wraps one of the objects to hide the complexity of conversion happening behind the scenes. The wrapped object isn\u2019t even aware of the adapter. For example, you can wrap an object that operates in meters and kilometers with an adapter that converts all of the data to imperial units such as feet and miles.</p> <p>Adapters can not only convert data into various formats but can also help objects with different interfaces collaborate. Here\u2019s how it works:</p> <ol> <li>The adapter gets an interface, compatible with one of the existing objects.</li> <li>Using this interface, the existing object can safely call the adapter\u2019s methods.</li> <li>Upon receiving a call, the adapter passes the request to the second object, but in a format and order that the second object expects.</li> </ol> <p>Sometimes it\u2019s even possible to create a two-way adapter that can convert the calls in both directions.</p> <p></p> <p>Let\u2019s get back to our stock market app. To solve the dilemma of incompatible formats, you can create XML-to-JSON adapters for every class of the analytics library that your code works with directly. Then you adjust your code to communicate with the library only via these adapters. When an adapter receives a call, it translates the incoming XML data into a JSON structure and passes the call to the appropriate methods of a wrapped analytics object.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Adapter/#real-world-analogy","title":"Real-World Analogy","text":"<p>A suitcase before and after a trip\u2003abroad.</p> <p>When you travel from the US to Europe for the first time, you may get a surprise when trying to charge your laptop. The power plug and sockets standards are different in different countries. That\u2019s why your US plug won\u2019t fit a German socket. The problem can be solved by using a power plug adapter that has the American-style socket and the European-style plug.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Adapter/#structure","title":"Structure","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Adapter/#object-adapter","title":"Object adapter","text":"<p>This implementation uses the object composition principle: the adapter implements the interface of one object and wraps the other one. It can be implemented in all popular programming languages.</p> <p></p> <ol> <li> <p>The\u2003Client\u2003is a class that contains the existing business logic of the program.</p> </li> <li> <p>The\u2003Client Interface\u2003describes a protocol that other classes must follow to be able to collaborate with the client code.</p> </li> <li> <p>The\u2003Service\u2003is some useful class (usually 3rd-party or legacy). The client can\u2019t use this class directly because it has an incompatible interface.</p> </li> <li> <p>The\u2003Adapter\u2003is a class that\u2019s able to work with both the client and the service: it implements the client interface, while wrapping the service object. The adapter receives calls from the client via the adapter interface and translates them into calls to the wrapped service object in a format it can understand.</p> </li> <li> <p>The client code doesn\u2019t get coupled to the concrete adapter class as long as it works with the adapter via the client interface. Thanks to this, you can introduce new types of adapters into the program without breaking the existing client code. This can be useful when the interface of the service class gets changed or replaced: you can just create a new adapter class without changing the client code.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Adapter/#class-adapter","title":"Class adapter","text":"<p>This implementation uses inheritance: the adapter inherits interfaces from both objects at the same time. Note that this approach can only be implemented in programming languages that support multiple inheritance, such as C++.</p> <p></p> <ol> <li>The\u2003Class Adapter\u2003doesn\u2019t need to wrap any objects because it inherits behaviors from both the client and the service. The adaptation happens within the overridden methods. The resulting adapter can be used in place of an existing client class.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Adapter/#pseudocode","title":"Pseudocode","text":"<p>This example of the\u2003Adapter\u2003pattern is based on the classic conflict between square pegs and round holes.</p> <p></p> <p>Adapting square pegs to round\u2003holes.</p> <p>The Adapter pretends to be a round peg, with a radius equal to a half of the square\u2019s diameter (in other words, the radius of the smallest circle that can accommodate the square peg).</p> <pre><code>// Say you have two classes with compatible interfaces:\n// RoundHole and RoundPeg.\nclass RoundHole is\n    constructor RoundHole(radius) { ... }\n\n    method getRadius() is\n        // Return the radius of the hole.\n\n    method fits(peg: RoundPeg) is\n        return this.getRadius() &gt;= peg.getRadius()\n\nclass RoundPeg is\n    constructor RoundPeg(radius) { ... }\n\n    method getRadius() is\n        // Return the radius of the peg.\n\n// But there's an incompatible class: SquarePeg.\nclass SquarePeg is\n    constructor SquarePeg(width) { ... }\n\n    method getWidth() is\n        // Return the square peg width.\n\n// An adapter class lets you fit square pegs into round holes.\n// It extends the RoundPeg class to let the adapter objects act\n// as round pegs.\nclass SquarePegAdapter extends RoundPeg is\n    // In reality, the adapter contains an instance of the\n    // SquarePeg class.\n    private field peg: SquarePeg\n\n    constructor SquarePegAdapter(peg: SquarePeg) is\n        this.peg = peg\n\n    method getRadius() is\n        // The adapter pretends that it's a round peg with a\n        // radius that could fit the square peg that the adapter\n        // actually wraps.\n        return peg.getWidth() * Math.sqrt(2) / 2\n\n// Somewhere in client code.\nhole = new RoundHole(5)\nrpeg = new RoundPeg(5)\nhole.fits(rpeg) // true\n\nsmall_sqpeg = new SquarePeg(5)\nlarge_sqpeg = new SquarePeg(10)\nhole.fits(small_sqpeg) // this won't compile (incompatible types)\n\nsmall_sqpeg_adapter = new SquarePegAdapter(small_sqpeg)\nlarge_sqpeg_adapter = new SquarePegAdapter(large_sqpeg)\nhole.fits(small_sqpeg_adapter) // true\nhole.fits(large_sqpeg_adapter) // false\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Adapter/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Adapter class when you want to use some existing class, but its interface isn\u2019t compatible with the rest of your code.     \u2003The Adapter pattern lets you create a middle-layer class that serves as a translator between your code and a legacy class, a 3rd-party class or any other class with a weird interface.</p> </li> <li> <p>Use the pattern when you want to reuse several existing subclasses that lack some common functionality that can\u2019t be added to the superclass.     \u2003You could extend each subclass and put the missing functionality into new child classes. However, you\u2019ll need to duplicate the code across all of these new classes, which\u2003smells really bad.</p> <p>The much more elegant solution would be to put the missing functionality into an adapter class. Then you would wrap objects with missing features inside the adapter, gaining needed features dynamically. For this to work, the target classes must have a common interface, and the adapter\u2019s field should follow that interface. This approach looks very similar to the\u2003Decorator\u2003pattern.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Adapter/#how-to-implement","title":"How to Implement","text":"<ol> <li>Make sure that you have at least two classes with incompatible interfaces:<ul> <li>A useful\u2003service\u2003class, which you can\u2019t change (often 3rd-party, legacy or with lots of existing dependencies).</li> <li>One or several\u2003client\u2003classes that would benefit from using the service class.</li> </ul> </li> <li>Declare the client interface and describe how clients communicate with the service.</li> <li>Create the adapter class and make it follow the client interface. Leave all the methods empty for now.</li> <li>Add a field to the adapter class to store a reference to the service object. The common practice is to initialize this field via the constructor, but sometimes it\u2019s more convenient to pass it to the adapter when calling its methods.</li> <li>One by one, implement all methods of the client interface in the adapter class. The adapter should delegate most of the real work to the service object, handling only the interface or data format conversion.</li> <li>Clients should use the adapter via the client interface. This will let you change or extend the adapters without affecting the client code.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Adapter/#pros-and-cons","title":"Pros and Cons","text":"Pros Cons Single Responsibility Principle. You can separate the interface or data conversion code from the primary business logic of the program. The overall complexity of the code increases because you need to introduce a set of new interfaces and classes. Sometimes it\u2019s simpler just to change the service class so that it matches the rest of your code. Open Closed Principle. You can introduce new types of adapters into the program without breaking the existing client code, as long as they work with the adapters through the client interface.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Adapter/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.</li> <li>Adapter changes the interface of an existing object, while Decorator enhances an object without changing its interface. In addition, Decorator supports recursive composition, which isn\u2019t possible when you use Adapter.</li> <li>Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.</li> <li>Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.</li> <li>Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn\u2019t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Bridge/","title":"Bridge","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Bridge/#bridge","title":"Bridge","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Bridge/#intent","title":"Intent","text":"<p>Bridge\u2003is a structural design pattern that lets you split a large class or a set of closely related classes into two separate hierarchies\u2014abstraction and implementation\u2014which can be developed independently of each\u2003other.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Bridge/#problem","title":"Problem","text":"<p>Abstraction? Implementation?\u2003Sound scary? Stay calm and let\u2019s consider a simple example.</p> <p>Say you have a geometric\u2003<code>Shape</code>\u2003class with a pair of subclasses:\u2003<code>Circle</code>\u2003and\u2003<code>Square</code>. You want to extend this class hierarchy to incorporate colors, so you plan to create\u2003<code>Red</code>\u2003and\u2003<code>Blue</code>\u2003shape subclasses. However, since you already have two subclasses, you\u2019ll need to create four class combinations such as\u2003<code>BlueCircle</code>\u2003and\u2003<code>RedSquare</code>.</p> <p></p> <p>Number of class combinations grows in geometric\u2003progression.</p> <p>Adding new shape types and colors to the hierarchy will grow it exponentially. For example, to add a triangle shape you\u2019d need to introduce two subclasses, one for each color. And after that, adding a new color would require creating three subclasses, one for each shape type. The further we go, the worse it becomes.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Bridge/#solution","title":"Solution","text":"<p>This problem occurs because we\u2019re trying to extend the shape classes in two independent dimensions: by form and by color. That\u2019s a very common issue with class inheritance.</p> <p>The Bridge pattern attempts to solve this problem by switching from inheritance to the object composition. What this means is that you extract one of the dimensions into a separate class hierarchy, so that the original classes will reference an object of the new hierarchy, instead of having all of its state and behaviors within one class.</p> <p></p> <p>You can prevent the explosion of a class hierarchy by transforming it into several related\u2003hierarchies.</p> <p>Following this approach, we can extract the color-related code into its own class with two subclasses:\u2003<code>Red</code>\u2003and\u2003<code>Blue</code>. The\u2003<code>Shape</code>\u2003class then gets a reference field pointing to one of the color objects. Now the shape can delegate any color-related work to the linked color object. That reference will act as a bridge between the\u2003<code>Shape</code>\u2003and\u2003<code>Color</code>\u2003classes. From now on, adding new colors won\u2019t require changing the shape hierarchy, and vice versa.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Bridge/#abstraction-and-implementation","title":"Abstraction and Implementation","text":"<p>The GoF book\u2003\u2003introduces the terms\u2003Abstraction\u2003and\u2003Implementation\u2003as part of the Bridge definition. In my opinion, the terms sound too academic and make the pattern seem more complicated than it really is. Having read the simple example with shapes and colors, let\u2019s decipher the meaning behind the GoF book\u2019s scary words.</p> <p>Abstraction\u2003(also called\u2003interface) is a high-level control layer for some entity. This layer isn\u2019t supposed to do any real work on its own. It should delegate the work to the\u2003implementation\u2003layer (also called\u2003platform).</p> <p>Note that we\u2019re not talking about\u2003interfaces\u2003or\u2003abstract classes\u2003from your programming language. These aren\u2019t the same things.</p> <p>When talking about real applications, the abstraction can be represented by a graphical user interface (GUI), and the implementation could be the underlying operating system code (API) which the GUI layer calls in response to user interactions.</p> <p>Generally speaking, you can extend such an app in two independent directions:</p> <ul> <li>Have several different GUIs (for instance, tailored for regular customers or admins).</li> <li>Support several different APIs (for example, to be able to launch the app under Windows, Linux, and macOS).</li> </ul> <p>In a worst-case scenario, this app might look like a giant spaghetti bowl, where hundreds of conditionals connect different types of GUI with various APIs all over the code.</p> <p></p> <p>Making even a simple change to a monolithic codebase is pretty hard because you must understand the\u2003entire thing\u2003very well. Making changes to smaller, well-defined modules is much\u2003easier.</p> <p>You can bring order to this chaos by extracting the code related to specific interface-platform combinations into separate classes. However, soon you\u2019ll discover that there are\u2003lots\u2003of these classes. The class hierarchy will grow exponentially because adding a new GUI or supporting a different API would require creating more and more classes.</p> <p>Let\u2019s try to solve this issue with the Bridge pattern. It suggests that we divide the classes into two hierarchies:</p> <ul> <li>Abstraction: the GUI layer of the app.</li> <li>Implementation: the operating systems\u2019 APIs.</li> </ul> <p></p> <p>One of the ways to structure a cross-platform\u2003application.</p> <p>The abstraction object controls the appearance of the app, delegating the actual work to the linked implementation object. Different implementations are interchangeable as long as they follow a common interface, enabling the same GUI to work under Windows and Linux.</p> <p>As a result, you can change the GUI classes without touching the API-related classes. Moreover, adding support for another operating system only requires creating a subclass in the implementation hierarchy.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Bridge/#structure","title":"Structure","text":"<ol> <li>The\u2003Abstraction\u2003provides high-level control logic. It relies on the implementation object to do the actual low-level work.</li> <li>The\u2003Implementation\u2003declares the interface that\u2019s common for all concrete implementations. An abstraction can only communicate with an implementation object via methods that are declared here.     The abstraction may list the same methods as the implementation, but usually the abstraction declares some complex behaviors that rely on a wide variety of primitive operations declared by the implementation.</li> <li>Concrete Implementations\u2003contain platform-specific code.</li> <li>Refined Abstractions\u2003provide variants of control logic. Like their parent, they work with different implementations via the general implementation interface.</li> <li>Usually, the\u2003Client\u2003is only interested in working with the abstraction. However, it\u2019s the client\u2019s job to link the abstraction object with one of the implementation objects.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Bridge/#pseudocode","title":"Pseudocode","text":"<p>This example illustrates how the\u2003Bridge\u2003pattern can help divide the monolithic code of an app that manages devices and their remote controls. The\u2003<code>Device</code>\u2003classes act as the implementation, whereas the\u2003<code>Remote</code>s act as the abstraction.</p> <p></p> <p>The original class hierarchy is divided into two parts: devices and remote\u2003controls.</p> <p>The base remote control class declares a reference field that links it with a device object. All remotes work with the devices via the general device interface, which lets the same remote support multiple device types.</p> <p>You can develop the remote control classes independently from the device classes. All that\u2019s needed is to create a new remote subclass. For example, a basic remote control might only have two buttons, but you could extend it with additional features, such as an extra battery or a touchscreen.</p> <p>The client code links the desired type of remote control with a specific device object via the remote\u2019s constructor.</p> <pre><code>// The \"abstraction\" defines the interface for the \"control\"\n// part of the two class hierarchies. It maintains a reference\n// to an object of the \"implementation\" hierarchy and delegates\n// all of the real work to this object.\nclass RemoteControl is\n    protected field device: Device\n    constructor RemoteControl(device: Device) is\n        this.device = device\n    method togglePower() is\n        if (device.isEnabled()) then\n            device.disable()\n        else\n            device.enable()\n    method volumeDown() is\n        device.setVolume(device.getVolume() - 10)\n    method volumeUp() is\n        device.setVolume(device.getVolume() + 10)\n    method channelDown() is\n        device.setChannel(device.getChannel() - 1)\n    method channelUp() is\n        device.setChannel(device.getChannel() + 1)\n\n// You can extend classes from the abstraction hierarchy\n// independently from device classes.\nclass AdvancedRemoteControl extends RemoteControl is\n    method mute() is\n        device.setVolume(0)\n\n// The \"implementation\" interface declares methods common to all\n// concrete implementation classes. It doesn't have to match the\n// abstraction's interface. In fact, the two interfaces can be\n// entirely different. Typically the implementation interface\n// provides only primitive operations, while the abstraction\n// defines higher-level operations based on those primitives.\ninterface Device is\n    method isEnabled()\n    method enable()\n    method disable()\n    method getVolume()\n    method setVolume(percent)\n    method getChannel()\n    method setChannel(channel)\n\n// All devices follow the same interface.\nclass Tv implements Device is\n    // ...\n\nclass Radio implements Device is\n    // ...\n\n// Somewhere in client code.\ntv = new Tv()\nremote = new RemoteControl(tv)\nremote.togglePower()\n\nradio = new Radio()\nremote = new AdvancedRemoteControl(radio)\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Bridge/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Bridge pattern when you want to divide and organize a monolithic class that has several variants of some functionality (for example, if the class can work with various database servers).     The bigger a class becomes, the harder it is to figure out how it works, and the longer it takes to make a change. The changes made to one of the variations of functionality may require making changes across the whole class, which often results in making errors or not addressing some critical side effects.</p> <p>The Bridge pattern lets you split the monolithic class into several class hierarchies. After this, you can change the classes in each hierarchy independently of the classes in the others. This approach simplifies code maintenance and minimizes the risk of breaking existing code.</p> </li> <li> <p>Use the pattern when you need to extend a class in several orthogonal (independent) dimensions.   The Bridge suggests that you extract a separate class hierarchy for each of the dimensions. The original class delegates the related work to the objects belonging to those hierarchies instead of doing everything on its own.</p> </li> <li>Use the Bridge if you need to be able to switch implementations at runtime.     Although it\u2019s optional, the Bridge pattern lets you replace the implementation object inside the abstraction. It\u2019s as easy as assigning a new value to a field.</li> </ul> <p>By the way, this last item is the main reason why so many people confuse the Bridge with the\u2003Strategy\u2003pattern. Remember that a pattern is more than just a certain way to structure your classes. It may also communicate intent and a problem being addressed.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Bridge/#how-to-implement","title":"How to Implement","text":"<ol> <li>Identify the orthogonal dimensions in your classes. These independent concepts could be: abstraction/platform, domain/infrastructure, front-end/back-end, or interface/implementation.</li> <li>See what operations the client needs and define them in the base abstraction class.</li> <li>Determine the operations available on all platforms. Declare the ones that the abstraction needs in the general implementation interface.</li> <li>For all platforms in your domain create concrete implementation classes, but make sure they all follow the implementation interface.</li> <li>Inside the abstraction class, add a reference field for the implementation type. The abstraction delegates most of the work to the implementation object that\u2019s referenced in that field.</li> <li>If you have several variants of high-level logic, create refined abstractions for each variant by extending the base abstraction class.</li> <li>The client code should pass an implementation object to the abstraction\u2019s constructor to associate one with the other. After that, the client can forget about the implementation and work only with the abstraction object.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Bridge/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can create platform-independent classes and apps. You might make the code more complicated by applying the pattern to a highly cohesive class. The client code works with high-level abstractions. It isn\u2019t exposed to the platform details. Open Closed Principle You can introduce new abstractions and implementations independently from each other. Single Responsibility Principle. You can focus on high-level logic in the abstraction and on platform details in the implementation.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Bridge/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.</li> <li>Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn\u2019t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.</li> <li>You can use Abstract Factory along with Bridge. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.</li> <li>You can combine Builder with Bridge: the director class plays the role of the abstraction, while different builders act as implementations.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Builder/","title":"Builder","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Builder/#builder","title":"Builder","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Builder/#intent","title":"Intent","text":"<p>Builder\u2003is a creational design pattern that lets you construct complex objects step by step. The pattern allows you to produce different types and representations of an object using the same construction\u2003code.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Builder/#problem","title":"Problem","text":"<p>Imagine a complex object that requires laborious, step-by-step initialization of many fields and nested objects. Such initialization code is usually buried inside a monstrous constructor with lots of parameters. Or even worse: scattered all over the client code.</p> <p></p> <p>You might make the program too complex by creating a subclass for every possible configuration of an\u2003object.</p> <p>For example, let\u2019s think about how to create a\u2003<code>House</code>\u2003object. To build a simple house, you need to construct four walls and a floor, install a door, fit a pair of windows, and build a roof. But what if you want a bigger, brighter house, with a backyard and other goodies (like a heating system, plumbing, and electrical wiring)?</p> <p>The simplest solution is to extend the base\u2003<code>House</code>\u2003class and create a set of subclasses to cover all combinations of the parameters. But eventually you\u2019ll end up with a considerable number of subclasses. Any new parameter, such as the porch style, will require growing this hierarchy even more.</p> <p>There\u2019s another approach that doesn\u2019t involve breeding subclasses. You can create a giant constructor right in the base\u2003<code>House</code>\u2003class with all possible parameters that control the house object. While this approach indeed eliminates the need for subclasses, it creates another problem.</p> <p></p> <p>The constructor with lots of parameters has its downside: not all the parameters are needed at all\u2003times.</p> <p>In most cases most of the parameters will be unused, making\u2003the constructor calls pretty ugly. For instance, only a fraction of houses have swimming pools, so the parameters related to swimming pools will be useless nine times out of ten.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Builder/#solution","title":"Solution","text":"<p>The Builder pattern suggests that you extract the object construction code out of its own class and move it to separate objects called\u2003builders.</p> <p></p> <p>The Builder pattern lets you construct complex objects step by step. The Builder doesn\u2019t allow other objects to access the product while it\u2019s being\u2003built.</p> <p>The pattern organizes object construction into a set of steps (<code>buildWalls</code>,\u2003<code>buildDoor</code>,\u2003etc.). To create an object, you execute a series of these steps on a builder object. The important part is that you don\u2019t need to call all of the steps. You can call only those steps that are necessary for producing a particular configuration of an object.</p> <p>Some of the construction steps might require different implementation when you need to build various representations of the product. For example, walls of a cabin may be built of wood, but the castle walls must be built with stone.</p> <p>In this case, you can create several different builder classes that implement the same set of building steps, but in a different manner. Then you can use these builders in the construction process (i.e., an ordered set of calls to the building steps) to produce different kinds of objects.</p> <p></p> <p>Different builders execute the same task in various\u2003ways.</p> <p>For example, imagine a builder that builds everything from wood and glass, a second one that builds everything with stone and iron and a third one that uses gold and diamonds. By calling the same set of steps, you get a regular house from the first builder, a small castle from the second and a palace from the third. However, this would only work if the client code that calls the building steps is able to interact with builders using a common interface.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Builder/#director","title":"Director","text":"<p>You can go further and extract a series of calls to the builder steps you use to construct a product into a separate class called\u2003director. The director class defines the order in which to execute the building steps, while the builder provides the implementation for those steps.</p> <p></p> <p>The director knows which building steps to execute to get a working\u2003product.</p> <p>Having a director class in your program isn\u2019t strictly necessary. You can always call the building steps in a specific order directly from the client code. However, the director class might be a good place to put various construction routines so you can reuse them across your program.</p> <p>In addition, the director class completely hides the details of product construction from the client code. The client only needs to associate a builder with a director, launch the construction with the director, and get the result from the builder.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Builder/#structure","title":"Structure","text":"<ol> <li>The\u2003Builder\u2003interface declares product construction steps that are common to all types of builders.</li> <li>Concrete Builders\u2003provide different implementations of the construction steps. Concrete builders may produce products that don\u2019t follow the common interface.</li> <li>Products\u2003are resulting objects. Products constructed by different builders don\u2019t have to belong to the same class hierarchy or interface.</li> <li>The\u2003Director\u2003class defines the order in which to call construction steps, so you can create and reuse specific configurations of products.</li> <li>The\u2003Client\u2003must associate one of the builder objects with the director. Usually, it\u2019s done just once, via parameters of the director\u2019s constructor. Then the director uses that builder object for all further construction. However, there\u2019s an alternative approach for when the client passes the builder object to the production method of the director. In this case, you can use a different builder each time you produce something with the director.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Builder/#pseudocode","title":"Pseudocode","text":"<p>This example of the\u2003Builder\u2003pattern illustrates how you can reuse the same object construction code when building different types of products, such as cars, and create the corresponding manuals for them.</p> <p></p> <p>The example of step-by-step construction of cars and the user guides that fit those car\u2003models.</p> <p>A car is a complex object that can be constructed in a hundred different ways. Instead of bloating the\u2003<code>Car</code>\u2003class with a huge constructor, we extracted the car assembly code into a separate car builder class. This class has a set of methods for configuring various parts of a car.</p> <p>If the client code needs to assemble a special, fine-tuned model of a car, it can work with the builder directly. On the other hand, the client can delegate the assembly to the director class, which knows how to use a builder to construct several of the most popular models of cars.</p> <p>You might be shocked, but every car needs a manual (seriously, who reads them?). The manual describes every feature of the car, so the details in the manuals vary across the different models. That\u2019s why it makes sense to reuse an existing construction process for both real cars and their respective manuals. Of course, building a manual isn\u2019t the same as building a car, and that\u2019s why we must provide another builder class that specializes in composing manuals. This class implements the same building methods as its car-building sibling, but instead of crafting car parts, it describes them. By passing these builders to the same director object, we can construct either a car or a manual.</p> <p>The final part is fetching the resulting object. A metal car and a paper manual, although related, are still very different things. We can\u2019t place a method for fetching results in the director without coupling the director to concrete product classes. Hence, we obtain the result of the construction from the builder which performed the job.</p> <pre><code>// Using the Builder pattern makes sense only when your products\n// are quite complex and require extensive configuration. The\n// following two products are related, although they don't have\n// a common interface.\nclass Car is\n    // A car can have a GPS, trip computer and some number of\n    // seats. Different models of cars (sports car, SUV,\n    // cabriolet) might have different features installed or\n    // enabled.\n\nclass Manual is\n    // Each car should have a user manual that corresponds to\n    // the car's configuration and describes all its features.\n\n// The builder interface specifies methods for creating the\n// different parts of the product objects.\ninterface Builder is\n    method reset()\n    method setSeats(...)\n    method setEngine(...)\n    method setTripComputer(...)\n    method setGPS(...)\n\n// The concrete builder classes follow the builder interface and\n// provide specific implementations of the building steps. Your\n// program may have several variations of builders, each\n// implemented differently.\nclass CarBuilder implements Builder is\n    private field car:Car\n\n    // A fresh builder instance should contain a blank product\n    // object which it uses in further assembly.\n    constructor CarBuilder() is\n        this.reset()\n\n    // The reset method clears the object being built.\n    method reset() is\n        this.car = new Car()\n\n    // All production steps work with the same product instance.\n    method setSeats(...) is\n        // Set the number of seats in the car.\n\n    method setEngine(...) is\n        // Install a given engine.\n\n    method setTripComputer(...) is\n        // Install a trip computer.\n\n    method setGPS(...) is\n        // Install a global positioning system.\n\n    // Concrete builders are supposed to provide their own\n    // methods for retrieving results. That's because various\n    // types of builders may create entirely different products\n    // that don't all follow the same interface. Therefore such\n    // methods can't be declared in the builder interface (at\n    // least not in a statically-typed programming language).\n    //\n    // Usually, after returning the end result to the client, a\n    // builder instance is expected to be ready to start\n    // producing another product. That's why it's a usual\n    // practice to call the reset method at the end of the\n    // `getProduct` method body. However, this behavior isn't\n    // mandatory, and you can make your builder wait for an\n    // explicit reset call from the client code before disposing\n    // of the previous result.\n    method getProduct():Car is\n        product = this.car\n        this.reset()\n        return product\n\n// Unlike other creational patterns, builder lets you construct\n// products that don't follow the common interface.\nclass CarManualBuilder implements Builder is\n    private field manual:Manual\n\n    constructor CarManualBuilder() is\n        this.reset()\n\n    method reset() is\n        this.manual = new Manual()\n\n    method setSeats(...) is\n        // Document car seat features.\n\n    method setEngine(...) is\n        // Add engine instructions.\n\n    method setTripComputer(...) is\n        // Add trip computer instructions.\n\n    method setGPS(...) is\n        // Add GPS instructions.\n\n    method getProduct():Manual is\n        // Return the manual and reset the builder.\n\n// The director is only responsible for executing the building\n// steps in a particular sequence. It's helpful when producing\n// products according to a specific order or configuration.\n// Strictly speaking, the director class is optional, since the\n// client can control builders directly.\nclass Director is\n    private field builder:Builder\n\n    // The director works with any builder instance that the\n    // client code passes to it. This way, the client code may\n    // alter the final type of the newly assembled product.\n    method setBuilder(builder:Builder)\n        this.builder = builder\n\n    // The director can construct several product variations\n    // using the same building steps.\n    method constructSportsCar(builder: Builder) is\n        builder.reset()\n        builder.setSeats(2)\n        builder.setEngine(new SportEngine())\n        builder.setTripComputer(true)\n        builder.setGPS(true)\n\n    method constructSUV(builder: Builder) is\n        // ...\n\n// The client code creates a builder object, passes it to the\n// director and then initiates the construction process. The end\n// result is retrieved from the builder object.\nclass Application is\n\n    method makeCar() is\n        director = new Director()\n\n        CarBuilder builder = new CarBuilder()\n        director.constructSportsCar(builder)\n        Car car = builder.getProduct()\n\n        CarManualBuilder builder = new CarManualBuilder()\n        director.constructSportsCar(builder)\n\n        // The final product is often retrieved from a builder\n        // object since the director isn't aware of and not\n        // dependent on concrete builders and products.\n        Manual manual = builder.getProduct()\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Builder/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Builder pattern to get rid of a \u201ctelescoping constructor\u201d.      Say you have a constructor with ten optional parameters. Calling such a beast is very inconvenient; therefore, you overload the constructor and create several shorter versions with fewer parameters. These constructors still refer to the main one, passing some default values into any omitted parameters. <pre><code>class Pizza {\n    Pizza(int size) { ... }\n    Pizza(int size, boolean cheese) { ... }\n    Pizza(int size, boolean cheese, boolean pepperoni) { ... }\n    // ...\n</code></pre>     Creating such a monster is only possible in languages that support method overloading, such as C# or Java.</p> <p>The Builder pattern lets you build objects step by step, using only those steps that you really need. After implementing the pattern, you don\u2019t have to cram dozens of parameters into your constructors anymore.</p> </li> <li> <p>Use the Builder pattern when you want your code to be able to create different representations of some product (for example, stone and wooden houses).     The Builder pattern can be applied when construction of various representations of the product involves similar steps that differ only in the details.</p> <p>The base builder interface defines all possible construction steps, and concrete builders implement these steps to construct particular representations of the product. Meanwhile, the director class guides the order of construction.</p> </li> <li> <p>Use the Builder to construct Composite trees or other complex objects.      The Builder pattern lets you construct products step-by-step. You could defer execution of some steps without breaking the final product. You can even call steps recursively, which comes in handy when you need to build an object tree.</p> <p>A builder doesn\u2019t expose the unfinished product while running construction steps. This prevents the client code from fetching an incomplete result.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Builder/#how-to-implement","title":"How to Implement","text":"<ol> <li>Make sure that you can clearly define the common construction steps for building all available product representations. Otherwise, you won\u2019t be able to proceed with implementing the pattern.</li> <li>Declare these steps in the base builder interface.</li> <li> <p>Create a concrete builder class for each of the product representations and implement their construction steps.</p> <p>Don\u2019t forget about implementing a method for fetching the result of the construction. The reason why this method can\u2019t be declared inside the builder interface is that various builders may construct products that don\u2019t have a common interface. Therefore, you don\u2019t know what would be the return type for such a method. However, if you\u2019re dealing with products from a single hierarchy, the fetching method can be safely added to the base interface. </p> </li> <li> <p>Think about creating a director class. It may encapsulate various ways to construct a product using the same builder object.</p> </li> <li>The client code creates both the builder and the director objects. Before construction starts, the client must pass a builder object to the director. Usually, the client does this only once, via parameters of the director\u2019s class constructor. The director uses the builder object in all further construction. There\u2019s an alternative approach, where the builder is passed to a specific product construction method of the director.</li> <li>The construction result can be obtained directly from the director only if all products follow the same interface. Otherwise, the client should fetch the result from the builder.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Builder/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can construct objects step-by-step, defer construction steps or run steps recursively. The overall complexity of the code increases since the pattern requires creating multiple new classes. You can reuse the same construction code when building various representations of products. Single Responsibility Principle. You can isolate complex construction code from the business logic of the product.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Builder/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).</li> <li>Builder focuses on constructing complex objects step by step. Abstract Factory specializes in creating families of related objects. Abstract Factory returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.</li> <li>You can use Builder when creating complex Composite trees because you can program its construction steps to work recursively.</li> <li>You can combine Builder with Bridge: the director class plays the role of the abstraction, while different builders act as implementations.</li> <li>Abstract Factories, Builders and Prototypes can all be implemented as Singletons.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Chain%20of%20Responsibility/","title":"Chain of Responsibility","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Chain%20of%20Responsibility/#chain-of-responsibility","title":"Chain of Responsibility","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Chain%20of%20Responsibility/#intent","title":"Intent","text":"<p>Chain of Responsibility\u2003is a behavioral design pattern that lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the\u2003chain.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Chain%20of%20Responsibility/#problem","title":"Problem","text":"<p>Imagine that you\u2019re working on an online ordering system. You want to restrict access to the system so only authenticated users can create orders. Also, users who have administrative permissions must have full access to all orders.</p> <p>After a bit of planning, you realized that these checks must be performed sequentially. The application can attempt to authenticate a user to the system whenever it receives a request that contains the user\u2019s credentials. However, if those credentials aren\u2019t correct and authentication fails, there\u2019s no reason to proceed with any other checks.</p> <p></p> <p>The request must pass a series of checks before the ordering system itself can handle\u2003it.</p> <p>During the next few months, you implemented several more of those sequential checks.</p> <ul> <li> <p>One of your colleagues suggested that it\u2019s unsafe to pass raw data straight to the ordering system. So you added an extra validation step to sanitize the data in a request.</p> </li> <li> <p>Later, somebody noticed that the system is vulnerable to brute force password cracking. To negate this, you promptly added a check that filters repeated failed requests coming from the same IP address.</p> </li> <li> <p>Someone else suggested that you could speed up the system by returning cached results on repeated requests containing the same data. Hence, you added another check which lets the request pass through to the system only if there\u2019s no suitable cached response.</p> </li> </ul> <p></p> <p>The bigger the code grew, the messier it\u2003became.</p> <p>The code of the checks, which had already looked like a mess, became more and more bloated as you added each new feature. Changing one check sometimes affected the others. Worst of all, when you tried to reuse the checks to protect other components of the system, you had to duplicate some of the code since those components required some of the checks, but not all of them.</p> <p>The system became very hard to comprehend and expensive to maintain. You struggled with the code for a while, until one day you decided to refactor the whole thing.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Chain%20of%20Responsibility/#solution","title":"Solution","text":"<p>Like many other behavioral design patterns, the\u2003Chain of Responsibility\u2003relies on transforming particular behaviors into stand-alone objects called\u2003handlers. In our case, each check should be extracted to its own class with a single method that performs the check. The request, along with its data, is passed to this method as an argument.</p> <p>The pattern suggests that you link these handlers into a chain. Each linked handler has a field for storing a reference to the next handler in the chain. In addition to processing a request, handlers pass the request further along the chain. The request travels along the chain until all handlers have had a chance to process it.</p> <p>Here\u2019s the best part: a handler can decide not to pass the request further down the chain and effectively stop any further processing.</p> <p>In our example with ordering systems, a handler performs the processing and then decides whether to pass the request further down the chain. Assuming the request contains the right data, all the handlers can execute their primary behavior, whether it\u2019s authentication checks or caching.</p> <p></p> <p>Handlers are lined up one by one, forming a\u2003chain.</p> <p>However, there\u2019s a slightly different approach (and it\u2019s a bit more canonical) in which, upon receiving a request, a handler decides whether it can process it. If it can, it doesn\u2019t pass the request any further. So it\u2019s either only one handler that processes the request or none at all. This approach is very common when dealing with events in stacks of elements within a graphical user interface.</p> <p>For instance, when a user clicks a button, the event propagates through the chain of GUI elements that starts with the button, goes along its containers (like forms or panels), and ends up with the main application window. The event is processed by the first element in the chain that\u2019s capable of handling it. This example is also noteworthy because it shows that a chain can always be extracted from an object tree.</p> <p></p> <p>A chain can be formed from a branch of an object\u2003tree.</p> <p>It\u2019s crucial that all handler classes implement the same interface. Each concrete handler should only care about the following one having the\u2003<code>execute</code>\u2003method. This way you can compose chains at runtime, using various handlers without coupling your code to their concrete classes.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Chain%20of%20Responsibility/#real-world-analogy","title":"Real-World Analogy","text":"<p>A call to tech support can go through multiple\u2003operators.</p> <p>You\u2019ve just bought and installed a new piece of hardware on your computer. Since you\u2019re a geek, the computer has several operating systems installed. You try to boot all of them to see whether the hardware is supported. Windows detects and enables the hardware automatically. However, your beloved Linux refuses to work with the new hardware. With a small flicker of hope, you decide to call the tech-support phone number written on the box.</p> <p>The first thing you hear is the robotic voice of the autoresponder. It suggests nine popular solutions to various problems, none of which are relevant to your case. After a while, the robot connects you to a live operator.</p> <p>Alas, the operator isn\u2019t able to suggest anything specific either. He keeps quoting lengthy excerpts from the manual, refusing to listen to your comments. After hearing the phrase \u201chave you tried turning the computer off and on again?\u201d for the 10th time, you demand to be connected to a proper engineer.</p> <p>Eventually, the operator passes your call to one of the engineers, who had probably longed for a live human chat for hours as he sat in his lonely server room in the dark basement of some office building. The engineer tells you where to download proper drivers for your new hardware and how to install them on Linux. Finally, the solution! You end the call, bursting with joy.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Chain%20of%20Responsibility/#structure","title":"Structure","text":"<ol> <li>The\u2003Handler\u2003declares the interface, common for all concrete handlers. It usually contains just a single method for handling requests, but sometimes it may also have another method for setting the next handler on the chain.</li> <li> <p>The\u2003Base Handler\u2003is an optional class where you can put the boilerplate code that\u2019s common to all handler classes.</p> <p>Usually, this class defines a field for storing a reference to the next handler. The clients can build a chain by passing a handler to the constructor or setter of the previous handler. The class may also implement the default handling behavior: it can pass execution to the next handler after checking for its existence.</p> </li> <li> <p>Concrete Handlers\u2003contain the actual code for processing requests. Upon receiving a request, each handler must decide whether to process it and, additionally, whether to pass it along the chain.</p> <p>Handlers are usually self-contained and immutable, accepting all necessary data just once via the constructor.</p> </li> <li> <p>The\u2003Client\u2003may compose chains just once or compose them dynamically, depending on the application\u2019s logic. Note that a request can be sent to any handler in the chain\u2014it doesn\u2019t have to be the first one.    </p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Chain%20of%20Responsibility/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Chain of Responsibility\u2003pattern is responsible for displaying contextual help information for active GUI elements.</p> <p></p> <p>The GUI classes are built with the Composite pattern. Each element is linked to its container element. At any point, you can build a chain of elements that starts with the element itself and goes through all of its container\u2003elements.</p> <p>The application\u2019s GUI is usually structured as an object tree. For example, the\u2003<code>Dialog</code>\u2003class, which renders the main window of the app, would be the root of the object tree. The dialog contains\u2003<code>Panels</code>, which might contain other panels or simple low-level elements like\u2003<code>Buttons</code>\u2003and\u2003<code>TextFields</code>.</p> <p>A simple component can show brief contextual tooltips, as long as the component has some help text assigned. But more complex components define their own way of showing contextual help, such as showing an excerpt from the manual or opening a page in a browser.</p> <p></p> <p>That\u2019s how a help request traverses GUI\u2003objects.</p> <p>When a user points the mouse cursor at an element and presses the\u2003<code>F1</code>\u2003key, the application detects the component under the pointer and sends it a help request. The request bubbles up through all the element\u2019s containers until it reaches the element that\u2019s capable of displaying the help information.</p> <p>// The handler interface declares a method for executing a // request. interface ComponentWithContextualHelp is     method showHelp()</p> <p>// The base class for simple components. abstract class Component implements ComponentWithContextualHelp is     field tooltipText: string</p> <pre><code>    // The component's container acts as the next link in the\n    // chain of handlers.\n    protected field container: Container\n\n    // The component shows a tooltip if there's help text\n    // assigned to it. Otherwise it forwards the call to the\n    // container, if it exists.\n    method showHelp() is\n        if (tooltipText != null)\n            // Show tooltip.\n        else\n            container.showHelp()\n\n// Containers can contain both simple components and other\n// containers as children. The chain relationships are\n// established here. The class inherits showHelp behavior from\n// its parent.\nabstract class Container extends Component is\n    protected field children: array of Component\n\n    method add(child) is\n        children.add(child)\n        child.container = this\n\n// Primitive components may be fine with default help\n// implementation...\nclass Button extends Component is\n    // ...\n\n// But complex components may override the default\n// implementation. If the help text can't be provided in a new\n// way, the component can always call the base implementation\n// (see Component class).\nclass Panel extends Container is\n    field modalHelpText: string\n\n    method showHelp() is\n        if (modalHelpText != null)\n            // Show a modal window with the help text.\n        else\n            super.showHelp()\n\n// ...same as above...\nclass Dialog extends Container is\n    field wikiPageURL: string\n\n    method showHelp() is\n        if (wikiPageURL != null)\n            // Open the wiki help page.\n        else\n            super.showHelp()\n\n// Client code.\nclass Application is\n    // Every application configures the chain differently.\n    method createUI() is\n        dialog = new Dialog(\"Budget Reports\")\n        dialog.wikiPageURL = \"http://...\"\n        panel = new Panel(0, 0, 400, 800)\n        panel.modalHelpText = \"This panel does...\"\n        ok = new Button(250, 760, 50, 20, \"OK\")\n        ok.tooltipText = \"This is an OK button that...\"\n        cancel = new Button(320, 760, 50, 20, \"Cancel\")\n        // ...\n        panel.add(ok)\n        panel.add(cancel)\n        dialog.add(panel)\n\n    // Imagine what happens here.\n    method onF1KeyPress() is\n        component = this.getComponentAtMouseCoords()\n        component.showHelp()\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Chain%20of%20Responsibility/#applicability","title":"Applicability","text":"<ul> <li>Use the Chain of Responsibility pattern when your program is expected to process different kinds of requests in various ways, but the exact types of requests and their sequences are unknown beforehand.   The pattern lets you link several handlers into one chain and, upon receiving a request, \u201cask\u201d each handler whether it can process it. This way all handlers get a chance to process the request.</li> <li>Use the pattern when it\u2019s essential to execute several handlers in a particular order.   Since you can link the handlers in the chain in any order, all requests will get through the chain exactly as you planned.</li> <li>Use the CoR pattern when the set of handlers and their order are supposed to change at runtime.   If you provide setters for a reference field inside the handler classes, you\u2019ll be able to insert, remove or reorder handlers dynamically.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Chain%20of%20Responsibility/#how-to-implement","title":"How to Implement","text":"<ol> <li> <p>Declare the handler interface and describe the signature of a method for handling requests.</p> <p>Decide how the client will pass the request data into the method. The most flexible way is to convert the request into an object and pass it to the handling method as an argument.</p> </li> <li> <p>To eliminate duplicate boilerplate code in concrete handlers, it might be worth creating an abstract base handler class, derived from the handler interface.</p> <p>This class should have a field for storing a reference to the next handler in the chain. Consider making the class immutable. However, if you plan to modify chains at runtime, you need to define a setter for altering the value of the reference field.</p> <p>You can also implement the convenient default behavior for the handling method, which is to forward the request to the next object unless there\u2019s none left. Concrete handlers will be able to use this behavior by calling the parent method.</p> </li> <li> <p>One by one create concrete handler subclasses and implement their handling methods. Each handler should make two decisions when receiving a request:</p> <ul> <li>Whether it\u2019ll process the request.</li> <li> <p>Whether it\u2019ll pass the request along the chain. 4.  The client may either assemble chains on its own or receive pre-built chains from other objects. In the latter case, you must implement some factory classes to build chains according to the configuration or environment settings. 5.  The client may trigger any handler in the chain, not just the first one. The request will be passed along the chain until some handler refuses to pass it further or until it reaches the end of the chain. 6.  Due to the dynamic nature of the chain, the client should be ready to handle the following scenarios:</p> </li> <li> <p>The chain may consist of a single link.</p> </li> <li>Some requests may not reach the end of the chain.</li> <li>Others may reach the end of the chain unhandled.</li> </ul> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Chain%20of%20Responsibility/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can control the order of request handling. Some requests may end up unhandled. Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform operations. Open Closed Principle. You can introduce new handlers into the app without breaking the existing client code.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Chain%20of%20Responsibility/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:<ul> <li>Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.</li> <li>Command establishes unidirectional connections between senders and receivers.</li> <li>Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.</li> <li>Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.</li> </ul> </li> <li>Chain of Responsibility is often used in conjunction with Composite. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.</li> <li> <p>Handlers in Chain of Responsibility can be implemented as Commands. In this case, you can execute a lot of different operations over the same context object, represented by a request.</p> <p>However, there\u2019s another approach, where the request itself is a Command object. In this case, you can execute the same operation in a series of different contexts linked into a chain.</p> </li> <li> <p>Chain of Responsibility and Decorator have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences.</p> <p>The CoR handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various Decorators can extend the object\u2019s behavior while keeping it consistent with the base interface. In addition, decorators aren\u2019t allowed to break the flow of the request.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Command/","title":"Command","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Command/#command","title":"Command","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Command/#intent","title":"Intent","text":"<p>Command\u2003is a behavioral design pattern that turns a request into a stand-alone object that contains all information about the request. This transformation lets you pass requests as a method arguments, delay or queue a request\u2019s execution, and support undoable\u2003operations.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Command/#problem","title":"Problem","text":"<p>Imagine that you\u2019re working on a new text-editor app. Your current task is to create a toolbar with a bunch of buttons for various operations of the editor. You created a very neat\u2003<code>Button</code>\u2003class that can be used for buttons on the toolbar, as well as for generic buttons in various dialogs.</p> <p></p> <p>All buttons of the app are derived from the same\u2003class.</p> <p>While all of these buttons look similar, they\u2019re all supposed to do different things. Where would you put the code for the various click handlers of these buttons? The simplest solution is to create tons of subclasses for each place where the button is used. These subclasses would contain the code that would have to be executed on a button click.</p> <p></p> <p>Lots of button subclasses. What can go\u2003wrong?</p> <p>Before long, you realize that this approach is deeply flawed. First, you have an enormous number of subclasses, and that would be okay if you weren\u2019t risking breaking the code in these subclasses each time you modify the base\u2003<code>Button</code>\u2003class. Put simply, your GUI code has become awkwardly dependent on the volatile code of the business logic.</p> <p></p> <p>Several classes implement the same\u2003functionality.</p> <p>And here\u2019s the ugliest part. Some operations, such as copying/pasting text, would need to be invoked from multiple places. For example, a user could click a small \u201cCopy\u201d button on the toolbar, or copy something via the context menu, or just hit\u2003<code>Ctrl+C</code>\u2003on the keyboard.</p> <p>Initially, when our app only had the toolbar, it was okay to place the implementation of various operations into the button subclasses. In other words, having the code for copying text inside the\u2003<code>CopyButton</code>\u2003subclass was fine. But then, when you implement context menus, shortcuts, and other stuff, you have to either duplicate the operation\u2019s code in many classes or make menus dependent on buttons, which is an even worse option.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Command/#solution","title":"Solution","text":"<p>Good software design is often based on the\u2003principle of Separation of Concerns, which usually results in breaking an app into layers. The most common example: a layer for the graphical user interface and another layer for the business logic. The GUI layer is responsible for rendering a beautiful picture on the screen, capturing any input and showing results of what the user and the app are doing. However, when it comes to doing something important, like calculating the trajectory of the moon or composing an annual report, the GUI layer delegates the work to the underlying layer of business logic.</p> <p>In the code it might look like this: a GUI object calls a method of a business logic object, passing it some arguments. This process is usually described as one object sending another a\u2003request.</p> <p></p> <p>The GUI objects may access the business logic objects\u2003directly.</p> <p>The Command pattern suggests that GUI objects shouldn\u2019t send these requests directly. Instead, you should extract all of the request details, such as the object being called, the name of the method and the list of arguments into a separate\u2003command\u2003class with a single method that triggers this request.</p> <p>Command objects serve as links between various GUI and business logic objects. From now on, the GUI object doesn\u2019t need to know what business logic object will receive the request and how it\u2019ll be processed. The GUI object just triggers the command, which handles all the details.</p> <p></p> <p>Accessing the business logic layer via a\u2003command.</p> <p>The next step is to make your commands implement the same interface. Usually it has just a single execution method that takes no parameters. This interface lets you use various commands with the same request sender, without coupling it to concrete classes of commands. As a bonus, now you can switch command objects linked to the sender, effectively changing the sender\u2019s behavior at runtime.</p> <p>You might have noticed one missing piece of the puzzle, which is the request parameters. A GUI object might have supplied the business-layer object with some parameters. Since the command execution method doesn\u2019t have any parameters, how would we pass the request details to the receiver? It turns out the command should be either pre-configured with this data, or capable of getting it on its own.</p> <p></p> <p>The GUI objects delegate the work to\u2003commands.</p> <p>Let\u2019s get back to our text editor. After we apply the Command pattern, we no longer need all those button subclasses to implement various click behaviors. It\u2019s enough to put a single field into the base\u2003<code>Button</code>\u2003class that stores a reference to a command object and make the button execute that command on a click.</p> <p>You\u2019ll implement a bunch of command classes for every possible operation and link them with particular buttons, depending on the buttons\u2019 intended behavior.</p> <p>Other GUI elements, such as menus, shortcuts or entire dialogs, can be implemented in the same way. They\u2019ll be linked to a command which gets executed when a user interacts with the GUI element. As you\u2019ve probably guessed by now, the elements related to the same operations will be linked to the same commands, preventing any code duplication.</p> <p>As a result, commands become a convenient middle layer that reduces coupling between the GUI and business logic layers. And that\u2019s only a fraction of the benefits that the Command pattern can offer!</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Command/#real-world-analogy","title":"Real-World Analogy","text":"<p>Making an order in a\u2003restaurant.</p> <p>After a long walk through the city, you get to a nice restaurant and sit at the table by the window. A friendly waiter approaches you and quickly takes your order, writing it down on a piece of paper. The waiter goes to the kitchen and sticks the order on the wall. After a while, the order gets to the chef, who reads it and cooks the meal accordingly. The cook places the meal on a tray along with the order. The waiter discovers the tray, checks the order to make sure everything is as you wanted it, and brings everything to your table.</p> <p>The paper order serves as a command. It remains in a queue until the chef is ready to serve it. The order contains all the relevant information required to cook the meal. It allows the chef to start cooking right away instead of running around clarifying the order details from you directly.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Command/#structure","title":"Structure","text":"<ol> <li>The\u2003Sender\u2003class (aka\u2003invoker) is responsible for initiating requests. This class must have a field for storing a reference to a command object. The sender triggers that command instead of sending the request directly to the receiver. Note that the sender isn\u2019t responsible for creating the command object. Usually, it gets a pre-created command from the client via the constructor.</li> <li>The\u2003Command\u2003interface usually declares just a single method for executing the command.</li> <li>Concrete Commands\u2003implement various kinds of requests. A concrete command isn\u2019t supposed to perform the work on its own, but rather to pass the call to one of the business logic objects. However, for the sake of simplifying the code, these classes can be merged.     Parameters required to execute a method on a receiving object can be declared as fields in the concrete command. You can make command objects immutable by only allowing the initialization of these fields via the constructor.</li> <li>The\u2003Receiver\u2003class contains some business logic. Almost any object may act as a receiver. Most commands only handle the details of how a request is passed to the receiver, while the receiver itself does the actual work.</li> <li>The\u2003Client\u2003creates and configures concrete command objects. The client must pass all of the request parameters, including a receiver instance, into the command\u2019s constructor. After that, the resulting command may be associated with one or multiple senders.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Command/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Command\u2003pattern helps to track the history of executed operations and makes it possible to revert an operation if needed.</p> <p></p> <p>Undoable operations in a text\u2003editor.</p> <p>Commands which result in changing the State of the editor (e.g., cutting and pasting) make a backup copy of the editor\u2019s state before executing an operation associated with the command. After a command is executed, it\u2019s placed into the command history (a stack of command objects) along with the backup copy of the editor\u2019s state at that point. Later, if the user needs to revert an operation, the app can take the most recent command from the history, read the associated backup of the editor\u2019s state, and restore it.</p> <p>The client code (GUI elements, command history,\u2003etc.) isn\u2019t coupled to concrete command classes because it works with commands via the command interface. This approach lets you introduce new commands into the app without breaking any existing code.</p> <pre><code>// The base command class defines the common interface for all\n// concrete commands.\nabstract class Command is\n    protected field app: Application\n    protected field editor: Editor\n    protected field backup: text\n\n    constructor Command(app: Application, editor: Editor) is\n        this.app = app\n        this.editor = editor\n\n    // Make a backup of the editor's state.\n    method saveBackup() is\n        backup = editor.text\n\n    // Restore the editor's state.\n    method undo() is\n        editor.text = backup\n\n    // The execution method is declared abstract to force all\n    // concrete commands to provide their own implementations.\n    // The method must return true or false depending on whether\n    // the command changes the editor's state.\n    abstract method execute()\n\n// The concrete commands go here.\nclass CopyCommand extends Command is\n    // The copy command isn't saved to the history since it\n    // doesn't change the editor's state.\n    method execute() is\n        app.clipboard = editor.getSelection()\n        return false\n\nclass CutCommand extends Command is\n    // The cut command does change the editor's state, therefore\n    // it must be saved to the history. And it'll be saved as\n    // long as the method returns true.\n    method execute() is\n        saveBackup()\n        app.clipboard = editor.getSelection()\n        editor.deleteSelection()\n        return true\n\nclass PasteCommand extends Command is\n    method execute() is\n        saveBackup()\n        editor.replaceSelection(app.clipboard)\n        return true\n\n// The undo operation is also a command.\nclass UndoCommand extends Command is\n    method execute() is\n        app.undo()\n        return false\n\n// The global command history is just a stack.\nclass CommandHistory is\n    private field history: array of Command\n\n    // Last in...\n    method push(c: Command) is\n        // Push the command to the end of the history array.\n\n    // ...first out\n    method pop():Command is\n        // Get the most recent command from the history.\n\n// The editor class has actual text editing operations. It plays\n// the role of a receiver: all commands end up delegating\n// execution to the editor's methods.\nclass Editor is\n    field text: string\n\n    method getSelection() is\n        // Return selected text.\n\n    method deleteSelection() is\n        // Delete selected text.\n\n    method replaceSelection(text) is\n        // Insert the clipboard's contents at the current\n        // position.\n\n// The application class sets up object relations. It acts as a\n// sender: when something needs to be done, it creates a command\n// object and executes it.\nclass Application is\n    field clipboard: string\n    field editors: array of Editors\n    field activeEditor: Editor\n    field history: CommandHistory\n\n    // The code which assigns commands to UI objects may look\n    // like this.\n    method createUI() is\n        // ...\n        copy = function() { executeCommand(\n            new CopyCommand(this, activeEditor)) }\n        copyButton.setCommand(copy)\n        shortcuts.onKeyPress(\"Ctrl+C\", copy)\n\n        cut = function() { executeCommand(\n            new CutCommand(this, activeEditor)) }\n        cutButton.setCommand(cut)\n        shortcuts.onKeyPress(\"Ctrl+X\", cut)\n\n        paste = function() { executeCommand(\n            new PasteCommand(this, activeEditor)) }\n        pasteButton.setCommand(paste)\n        shortcuts.onKeyPress(\"Ctrl+V\", paste)\n\n        undo = function() { executeCommand(\n            new UndoCommand(this, activeEditor)) }\n        undoButton.setCommand(undo)\n        shortcuts.onKeyPress(\"Ctrl+Z\", undo)\n\n    // Execute a command and check whether it has to be added to\n    // the history.\n    method executeCommand(command) is\n        if (command.execute)\n            history.push(command)\n\n    // Take the most recent command from the history and run its\n    // undo method. Note that we don't know the class of that\n    // command. But we don't have to, since the command knows\n    // how to undo its own action.\n    method undo() is\n        command = history.pop()\n        if (command != null)\n            command.undo()\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Command/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Command pattern when you want to parametrize objects with operations.   The Command pattern can turn a specific method call into a stand-alone object. This change opens up a lot of interesting uses: you can pass commands as method arguments, store them inside other objects, switch linked commands at runtime,\u2003etc.</p> <p>Here\u2019s an example: you\u2019re developing a GUI component such as a context menu, and you want your users to be able to configure menu items that trigger operations when an end user clicks an item.</p> </li> <li> <p>Use the Command pattern when you want to queue operations, schedule their execution, or execute them remotely.   As with any other object, a command can be serialized, which means converting it to a string that can be easily written to a file or a database. Later, the string can be restored as the initial command object. Thus, you can delay and schedule command execution. But there\u2019s even more! In the same way, you can queue, log or send commands over the network.</p> </li> <li> <p>Use the Command pattern when you want to implement reversible operations.   Although there are many ways to implement undo/redo, the Command pattern is perhaps the most popular of all.</p> <p>To be able to revert operations, you need to implement the history of performed operations. The command history is a stack that contains all executed command objects along with related backups of the application\u2019s state.</p> <p>This method has two drawbacks. First, it isn\u2019t that easy to save an application\u2019s state because some of it can be private. This problem can be mitigated with the\u2003Memento\u2003pattern.</p> <p>Second, the state backups may consume quite a lot of RAM. Therefore, sometimes you can resort to an alternative implementation: instead of restoring the past state, the command performs the inverse operation. The reverse operation also has a price: it may turn out to be hard or even impossible to implement.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Command/#how-to-implement","title":"How to Implement","text":"<ol> <li>Declare the command interface with a single execution method.</li> <li>Start extracting requests into concrete command classes that implement the command interface. Each class must have a set of fields for storing the request arguments along with a reference to the actual receiver object. All these values must be initialized via the command\u2019s constructor.</li> <li>Identify classes that will act as\u2003senders. Add the fields for storing commands into these classes. Senders should communicate with their commands only via the command interface. Senders usually don\u2019t create command objects on their own, but rather get them from the client code.</li> <li>Change the senders so they execute the command instead of sending a request to the receiver directly.</li> <li>The client should initialize objects in the following order:<ul> <li>Create receivers.</li> <li>Create commands, and associate them with receivers if needed.</li> <li>Create senders, and associate them with specific commands.</li> </ul> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Command/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform these operations. The code may become more complicated since you\u2019re introducing a whole new layer between senders and receivers. Open Closed Principle. You can introduce new commands into the app without breaking existing client code. You can implement undo/redo. You can implement deferred execution of operations. You can assemble a set of simple commands into a complex one.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Command/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:<ul> <li>Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.</li> <li>Command establishes unidirectional connections between senders and receivers.</li> <li>Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a Mediator object.</li> <li>Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.</li> </ul> </li> <li> <p>Handlers in Chain of Responsibility can be implemented as Commands. In this case, you can execute a lot of different operations over the same context object, represented by a request.</p> <p>However, there\u2019s another approach, where the request itself is a Command object. In this case, you can execute the same operation in a series of different contexts linked into a chain.</p> </li> <li> <p>You can use Command and Memento together when implementing \u201cundo\u201d. In this case, commands are responsible for performing various operations over a target object, while mementos save the state of that object just before a command gets executed.</p> </li> <li> <p>Command and Strategy may look similar because you can use both to parameterize an object with some action. However, they have very different intents.</p> <ul> <li>You can use Command to convert any operation into an object. The operation\u2019s parameters become fields of that object. The conversion lets you defer execution of the operation, queue it, store the history of commands, send commands to remote services, etc.</li> <li>On the other hand, Strategy usually describes different ways of doing the same thing, letting you swap these algorithms within a single context class.</li> </ul> </li> <li>Prototype can help when you need to save copies of Commands into history.</li> <li>You can treat Visitor as a powerful version of the Command pattern. Its objects can execute operations over various objects of different classes.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Composite/","title":"Composite","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Composite/#composite","title":"Composite","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Composite/#intent","title":"Intent","text":"<p>Composite\u2003is a structural design pattern that lets you compose objects into tree structures and then work with these structures as if they were individual\u2003objects.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Composite/#problem","title":"Problem","text":"<p>Using the Composite pattern makes sense only when the core model of your app can be represented as a tree.</p> <p>For example, imagine that you have two types of objects:\u2003<code>Products</code>\u2003and\u2003<code>Boxes</code>. A\u2003<code>Box</code>\u2003can contain several\u2003<code>Products</code>\u2003as well as a number of smaller\u2003<code>Boxes</code>. These little\u2003<code>Boxes</code>\u2003can also hold some\u2003<code>Products</code>\u2003or even smaller\u2003<code>Boxes</code>, and so on.</p> <p>Say you decide to create an ordering system that uses these classes. Orders could contain simple products without any wrapping, as well as boxes stuffed with products\u2026and other boxes. How would you determine the total price of such an order?</p> <p></p> <p>An order might comprise various products, packaged in boxes, which are packaged in bigger boxes and so on. The whole structure looks like an upside down\u2003tree.</p> <p>You could try the direct approach: unwrap all the boxes, go over all the products and then calculate the total. That would be doable in the real world; but in a program, it\u2019s not as simple as running a loop. You have to know the classes of\u2003<code>Products</code>\u2003and\u2003<code>Boxes</code>\u2003you\u2019re going through, the nesting level of the boxes and other nasty details beforehand. All of this makes the direct approach either too awkward or even impossible.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Composite/#solution","title":"Solution","text":"<p>The Composite pattern suggests that you work with\u2003<code>Products</code>\u2003and\u2003<code>Boxes</code>\u2003through a common interface which declares a method for calculating the total price.</p> <p>How would this method work? For a product, it\u2019d simply return the product\u2019s price. For a box, it\u2019d go over each item the box contains, ask its price and then return a total for this box. If one of these items were a smaller box, that box would also start going over its contents and so on, until the prices of all inner components were calculated. A box could even add some extra cost to the final price, such as packaging cost.</p> <p></p> <p>The Composite pattern lets you run a behavior recursively over all components of an object\u2003tree.</p> <p>The greatest benefit of this approach is that you don\u2019t need to care about the concrete classes of objects that compose the tree. You don\u2019t need to know whether an object is a simple product or a sophisticated box. You can treat them all the same via the common interface. When you call a method, the objects themselves pass the request down the tree.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Composite/#real-world-analogy","title":"Real-World Analogy","text":"<p>An example of a military\u2003structure.</p> <p>Armies of most countries are structured as hierarchies. An army consists of several divisions; a division is a set of brigades, and a brigade consists of platoons, which can be broken down into squads. Finally, a squad is a small group of real soldiers. Orders are given at the top of the hierarchy and passed down onto each level until every soldier knows what needs to be done.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Composite/#structure","title":"Structure","text":"<ol> <li>The\u2003Component\u2003interface describes operations that are common to both simple and complex elements of the tree.</li> <li> <p>The\u2003Leaf\u2003is a basic element of a tree that doesn\u2019t have sub-elements.</p> <p>Usually, leaf components end up doing most of the real work, since they don\u2019t have anyone to delegate the work to.</p> </li> <li> <p>The\u2003Container\u2003(aka\u2003composite) is an element that has sub-elements: leaves or other containers. A container doesn\u2019t know the concrete classes of its children. It works with all sub-elements only via the component interface.</p> <p>Upon receiving a request, a container delegates the work to its sub-elements, processes intermediate results and then returns the final result to the client.</p> </li> <li> <p>The\u2003Client\u2003works with all elements through the component interface. As a result, the client can work in the same way with both simple or complex elements of the tree.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Composite/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Composite\u2003pattern lets you implement stacking of geometric shapes in a graphical editor.</p> <p></p> <p>The geometric shapes editor\u2003example.</p> <p>The\u2003<code>CompoundGraphic</code>\u2003class is a container that can comprise any number of sub-shapes, including other compound shapes. A compound shape has the same methods as a simple shape. However, instead of doing something on its own, a compound shape passes the request recursively to all its children and \u201csums up\u201d the result.</p> <p>The client code works with all shapes through the single interface common to all shape classes. Thus, the client doesn\u2019t know whether it\u2019s working with a simple shape or a compound one. The client can work with very complex object structures without being coupled to concrete classes that form that structure.</p> <pre><code>// The component interface declares common operations for both\n// simple and complex objects of a composition.\ninterface Graphic is\n    method move(x, y)\n    method draw()\n\n// The leaf class represents end objects of a composition. A\n// leaf object can't have any sub-objects. Usually, it's leaf\n// objects that do the actual work, while composite objects only\n// delegate to their sub-components.\nclass Dot implements Graphic is\n    field x, y\n\n    constructor Dot(x, y) { ... }\n\n    method move(x, y) is\n        this.x += x, this.y += y\n\n    method draw() is\n        // Draw a dot at X and Y.\n\n// All component classes can extend other components.\nclass Circle extends Dot is\n    field radius\n\n    constructor Circle(x, y, radius) { ... }\n\n    method draw() is\n        // Draw a circle at X and Y with radius R.\n\n// The composite class represents complex components that may\n// have children. Composite objects usually delegate the actual\n// work to their children and then \"sum up\" the result.\nclass CompoundGraphic implements Graphic is\n    field children: array of Graphic\n\n    // A composite object can add or remove other components\n    // (both simple or complex) to or from its child list.\n    method add(child: Graphic) is\n        // Add a child to the array of children.\n\n    method remove(child: Graphic) is\n        // Remove a child from the array of children.\n\n    method move(x, y) is\n        foreach (child in children) do\n            child.move(x, y)\n\n    // A composite executes its primary logic in a particular\n    // way. It traverses recursively through all its children,\n    // collecting and summing up their results. Since the\n    // composite's children pass these calls to their own\n    // children and so forth, the whole object tree is traversed\n    // as a result.\n    method draw() is\n        // 1. For each child component:\n        //     - Draw the component.\n        //     - Update the bounding rectangle.\n        // 2. Draw a dashed rectangle using the bounding\n        // coordinates.\n\n// The client code works with all the components via their base\n// interface. This way the client code can support simple leaf\n// components as well as complex composites.\nclass ImageEditor is\n    field all: CompoundGraphic\n\n    method load() is\n        all = new CompoundGraphic()\n        all.add(new Dot(1, 2))\n        all.add(new Circle(5, 3, 10))\n        // ...\n\n    // Combine selected components into one complex composite\n    // component.\n    method groupSelected(components: array of Graphic) is\n        group = new CompoundGraphic()\n        foreach (component in components) do\n            group.add(component)\n            all.remove(component)\n        all.add(group)\n        // All components will be drawn.\n        all.draw()\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Composite/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Composite pattern when you have to implement a tree-like object structure.     The Composite pattern provides you with two basic element types that share a common interface: simple leaves and complex containers. A container can be composed of both leaves and other containers. This lets you construct a nested recursive object structure that resembles a tree.</p> </li> <li> <p>Use the pattern when you want the client code to treat both simple and complex elements uniformly.     All elements defined by the Composite pattern share a common interface. Using this interface, the client doesn\u2019t have to worry about the concrete class of the objects it works with. </p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Composite/#how-to-implement","title":"How to Implement","text":"<ol> <li>Make sure that the core model of your app can be represented as a tree structure. Try to break it down into simple elements and containers. Remember that containers must be able to contain both simple elements and other containers.</li> <li>Declare the component interface with a list of methods that make sense for both simple and complex components.</li> <li>Create a leaf class to represent simple elements. A program may have multiple different leaf classes.</li> <li> <p>Create a container class to represent complex elements. In this class, provide an array field for storing references to sub-elements. The array must be able to store both leaves and containers, so make sure it\u2019s declared with the component interface type.</p> <p>While implementing the methods of the component interface, remember that a container is supposed to be delegating most of the work to sub-elements.</p> </li> <li> <p>Finally, define the methods for adding and removal of child elements in the container.</p> </li> </ol> <p>Keep in mind that these operations can be declared in the component interface. This would violate the\u2003Interface Segragation Principle\u2003because the methods will be empty in the leaf class. However, the client will be able to treat all the elements equally, even when composing the tree.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Composite/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can work with complex tree structures more conveniently: use polymorphism and recursion to your advantage. \u2003It might be difficult to provide a common interface for classes whose functionality differs too much. In certain scenarios, you\u2019d need to overgeneralize the component interface, making it harder to comprehend. Open Closed Principle. You can introduce new element types into the app without breaking the existing code, which now works with the object tree.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Composite/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>You can use Builder when creating complex Composite trees because you can program its construction steps to work recursively.</li> <li>Chain of Responsibility is often used in conjunction with Composite. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.</li> <li>You can use Iterators to traverse Composite trees.</li> <li>You can use Visitor to execute an operation over an entire Composite tree.</li> <li>You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.</li> <li> <p>Composite and Decorator have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.</p> <p>A Decorator is like a Composite but only has one child component. There\u2019s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just \u201csums up\u201d its children\u2019s results.</p> <p>However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.</p> </li> <li> <p>Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Decorator/","title":"Decorator","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Decorator/#decorator","title":"Decorator","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Decorator/#intent","title":"Intent","text":"<p>Decorator\u2003is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the\u2003behaviors.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Decorator/#problem","title":"Problem","text":"<p>Imagine that you\u2019re working on a notification library which lets other programs notify their users about important events.</p> <p>The initial version of the library was based on the\u2003<code>Notifier</code>\u2003class that had only a few fields, a constructor and a single\u2003<code>send</code>\u2003method. The method could accept a message argument from a client and send the message to a list of emails that were passed to the notifier via its constructor. A third-party app which acted as a client was supposed to create and configure the notifier object once, and then use it each time something important happened.</p> <p></p> <p>A program could use the notifier class to send notifications about important events to a predefined set of\u2003emails.</p> <p>At some point, you realize that users of the library expect more than just email notifications. Many of them would like to receive an SMS about critical issues. Others would like to be notified on Facebook and, of course, the corporate users would love to get Slack notifications.</p> <p></p> <p>Each notification type is implemented as a notifier\u2019s\u2003subclass.</p> <p>How hard can that be? You extended the\u2003<code>Notifier</code>\u2003class and put the additional notification methods into new subclasses. Now the client was supposed to instantiate the desired notification class and use it for all further notifications.</p> <p>But then someone reasonably asked you, \u201cWhy can\u2019t you use several notification types at once? If your house is on fire, you\u2019d probably want to be informed through every channel.\u201d</p> <p>You tried to address that problem by creating special subclasses which combined several notification methods within one class. However, it quickly became apparent that this approach would bloat the code immensely, not only the library code but the client code as well.</p> <p></p> <p>Combinatorial explosion of\u2003subclasses.</p> <p>You have to find some other way to structure notifications classes so that their number won\u2019t accidentally break some Guinness record.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Decorator/#solution","title":"Solution","text":"<p>Extending a class is the first thing that comes to mind when you need to alter an object\u2019s behavior. However, inheritance has several serious caveats that you need to be aware of.</p> <ul> <li>Inheritance is static. You can\u2019t alter the behavior of an existing object at runtime. You can only replace the whole object with another one that\u2019s created from a different subclass.</li> <li>Subclasses can have just one parent class. In most languages, inheritance doesn\u2019t let a class inherit behaviors of multiple classes at the same time.</li> </ul> <p>One of the ways to overcome these caveats is by using\u2003Aggregation\u2003or\u2003Composition\u2003\u2003instead of\u2003Inheritance. Both of the alternatives work almost the same way: one object\u2003has a\u2003reference to another and delegates it some work, whereas with inheritance, the object itself\u2003is\u2003able to do that work, inheriting the behavior from its superclass.</p> <p>With this new approach you can easily substitute the linked \u201chelper\u201d object with another, changing the behavior of the container at runtime. An object can use the behavior of various classes, having references to multiple objects and delegating them all kinds of work. Aggregation/composition is the key principle behind many design patterns, including Decorator. On that note, let\u2019s return to the pattern discussion.</p> <p></p> <p>Inheritance vs.\u2003Aggregation</p> <p>\u201cWrapper\u201d is the alternative nickname for the Decorator pattern that clearly expresses the main idea of the pattern. A\u2003wrapper\u2003is an object that can be linked with some\u2003target\u2003object. The wrapper contains the same set of methods as the target and delegates to it all requests it receives. However, the wrapper may alter the result by doing something either before or after it passes the request to the target.</p> <p>When does a simple wrapper become the real decorator? As I mentioned, the wrapper implements the same interface as the wrapped object. That\u2019s why from the client\u2019s perspective these objects are identical. Make the wrapper\u2019s reference field accept any object that follows that interface. This will let you cover an object in multiple wrappers, adding the combined behavior of all the wrappers to it.</p> <p>In our notifications example, let\u2019s leave the simple email notification behavior inside the base\u2003<code>Notifier</code>\u2003class, but turn all other notification methods into decorators.</p> <p></p> <p>Various notification methods become\u2003decorators.</p> <p>The client code would need to wrap a basic notifier object into a set of decorators that match the client\u2019s preferences. The resulting objects will be structured as a stack.</p> <p></p> <p>Apps might configure complex stacks of notification\u2003decorators.</p> <p>The last decorator in the stack would be the object that the client actually works with. Since all decorators implement the same interface as the base notifier, the rest of the client code won\u2019t care whether it works with the \u201cpure\u201d notifier object or the decorated one.</p> <p>We could apply the same approach to other behaviors such as formatting messages or composing the recipient list. The client can decorate the object with any custom decorators, as long as they follow the same interface as the others.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Decorator/#real-world-analogy","title":"Real-World Analogy","text":"<p>You get a combined effect from wearing multiple pieces of\u2003clothing.</p> <p>Wearing clothes is an example of using decorators. When you\u2019re cold, you wrap yourself in a sweater. If you\u2019re still cold with a sweater, you can wear a jacket on top. If it\u2019s raining, you can put on a raincoat. All of these garments \u201cextend\u201d your basic behavior but aren\u2019t part of you, and you can easily take off any piece of clothing whenever you don\u2019t need it.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Decorator/#structure","title":"Structure","text":"<ol> <li> <p>The\u2003Component\u2003declares the common interface for both wrappers and wrapped objects.</p> </li> <li> <p>Concrete Component\u2003is a class of objects being wrapped. It defines the basic behavior, which can be altered by decorators.</p> </li> <li> <p>The\u2003Base Decorator\u2003class has a field for referencing a wrapped object. The field\u2019s type should be declared as the component interface so it can contain both concrete components and decorators. The base decorator delegates all operations to the wrapped object.</p> </li> <li> <p>Concrete Decorators\u2003define extra behaviors that can be added to components dynamically. Concrete decorators override methods of the base decorator and execute their behavior either before or after calling the parent method.</p> </li> <li> <p>The\u2003Client\u2003can wrap components in multiple layers of decorators, as long as it works with all objects via the component interface.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Decorator/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Decorator\u2003pattern lets you compress and encrypt sensitive data independently from the code that actually uses this data.</p> <p></p> <p>The encryption and compression decorators\u2003example.</p> <p>The application wraps the data source object with a pair of decorators. Both wrappers change the way the data is written to and read from the disk:</p> <ul> <li> <p>Just before the data is\u2003written to disk, the decorators encrypt and compress it. The original class writes the encrypted and protected data to the file without knowing about the change.</p> </li> <li> <p>Right after the data is\u2003read from disk, it goes through the same decorators, which decompress and decode it.</p> </li> </ul> <p>The decorators and the data source class implement the same interface, which makes them all interchangeable in the client code.</p> <pre><code>// The component interface defines operations that can be\n// altered by decorators.\ninterface DataSource is\n    method writeData(data)\n    method readData():data\n\n// Concrete components provide default implementations for the\n// operations. There might be several variations of these\n// classes in a program.\nclass FileDataSource implements DataSource is\n    constructor FileDataSource(filename) { ... }\n\n    method writeData(data) is\n        // Write data to file.\n\n    method readData():data is\n        // Read data from file.\n\n// The base decorator class follows the same interface as the\n// other components. The primary purpose of this class is to\n// define the wrapping interface for all concrete decorators.\n// The default implementation of the wrapping code might include\n// a field for storing a wrapped component and the means to\n// initialize it.\nclass DataSourceDecorator implements DataSource is\n    protected field wrappee: DataSource\n\n    constructor DataSourceDecorator(source: DataSource) is\n        wrappee = source\n\n    // The base decorator simply delegates all work to the\n    // wrapped component. Extra behaviors can be added in\n    // concrete decorators.\n    method writeData(data) is\n        wrappee.writeData(data)\n\n    // Concrete decorators may call the parent implementation of\n    // the operation instead of calling the wrapped object\n    // directly. This approach simplifies extension of decorator\n    // classes.\n    method readData():data is\n        return wrappee.readData()\n\n// Concrete decorators must call methods on the wrapped object,\n// but may add something of their own to the result. Decorators\n// can execute the added behavior either before or after the\n// call to a wrapped object.\nclass EncryptionDecorator extends DataSourceDecorator is\n    method writeData(data) is\n        // 1. Encrypt passed data.\n        // 2. Pass encrypted data to the wrappee's writeData\n        // method.\n\n    method readData():data is\n        // 1. Get data from the wrappee's readData method.\n        // 2. Try to decrypt it if it's encrypted.\n        // 3. Return the result.\n\n// You can wrap objects in several layers of decorators.\nclass CompressionDecorator extends DataSourceDecorator is\n    method writeData(data) is\n        // 1. Compress passed data.\n        // 2. Pass compressed data to the wrappee's writeData\n        // method.\n\n    method readData():data is\n        // 1. Get data from the wrappee's readData method.\n        // 2. Try to decompress it if it's compressed.\n        // 3. Return the result.\n\n// Option 1. A simple example of a decorator assembly.\nclass Application is\n    method dumbUsageExample() is\n        source = new FileDataSource(\"somefile.dat\")\n        source.writeData(salaryRecords)\n        // The target file has been written with plain data.\n\n        source = new CompressionDecorator(source)\n        source.writeData(salaryRecords)\n        // The target file has been written with compressed\n        // data.\n\n        source = new EncryptionDecorator(source)\n        // The source variable now contains this:\n        // Encryption &gt; Compression &gt; FileDataSource\n        source.writeData(salaryRecords)\n        // The file has been written with compressed and\n        // encrypted data.\n\n// Option 2. Client code that uses an external data source.\n// SalaryManager objects neither know nor care about data\n// storage specifics. They work with a pre-configured data\n// source received from the app configurator.\nclass SalaryManager is\n    field source: DataSource\n\n    constructor SalaryManager(source: DataSource) { ... }\n\n    method load() is\n        return source.readData()\n\n    method save() is\n        source.writeData(salaryRecords)\n    // ...Other useful methods...\n\n// The app can assemble different stacks of decorators at\n// runtime, depending on the configuration or environment.\nclass ApplicationConfigurator is\n    method configurationExample() is\n        source = new FileDataSource(\"salary.dat\")\n        if (enabledEncryption)\n            source = new EncryptionDecorator(source)\n        if (enabledCompression)\n            source = new CompressionDecorator(source)\n\n        logger = new SalaryManager(source)\n        salary = logger.load()\n    // ...\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Decorator/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Decorator pattern when you need to be able to assign extra behaviors to objects at runtime without breaking the code that uses these objects.     \u2003The Decorator lets you structure your business logic into layers, create a decorator for each layer and compose objects with various combinations of this logic at runtime. The client code can treat all these objects in the same way, since they all follow a common interface.</p> </li> <li> <p>Use the pattern when it\u2019s awkward or not possible to extend an object\u2019s behavior using inheritance.     Many programming languages have the\u2003<code>final</code>\u2003keyword that can be used to prevent further extension of a class. For a final class, the only way to reuse the existing behavior would be to wrap the class with your own wrapper, using the Decorator pattern.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Decorator/#how-to-implement","title":"How to Implement","text":"<ol> <li>Make sure your business domain can be represented as a primary component with multiple optional layers over it.</li> <li>Figure out what methods are common to both the primary component and the optional layers. Create a component interface and declare those methods there.</li> <li>Create a concrete component class and define the base behavior in it.</li> <li>Create a base decorator class. It should have a field for storing a reference to a wrapped object. The field should be declared with the component interface type to allow linking to concrete components as well as decorators. The base decorator must delegate all work to the wrapped object.</li> <li>Make sure all classes implement the component interface.</li> <li>Create concrete decorators by extending them from the base decorator. A concrete decorator must execute its behavior before or after the call to the parent method (which always delegates to the wrapped object).</li> <li>The client code must be responsible for creating decorators and composing them in the way the client needs.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Decorator/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can extend an object\u2019s behavior without making a new subclass. It\u2019s hard to remove a specific wrapper from the wrappers stack. You can add or remove responsibilities from an object at runtime. It\u2019s hard to implement a decorator in such a way that its behavior doesn\u2019t depend on the order in the decorators stack. You can combine several behaviors by wrapping an object into multiple decorators. The initial configuration code of layers might look pretty ugly. Single Responsibility Principle. You can divide a monolithic class that implements many possible variants of behavior into several smaller classes.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Decorator/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<p>Adapter changes the interface of an existing object, while Decorator enhances an object without changing its interface. In addition, Decorator supports recursive composition, which isn\u2019t possible when you use Adapter.</p> <p>Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.</p> <p>Chain of Responsibility and Decorator have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences.</p> <p>The CoR handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various Decorators can extend the object\u2019s behavior while keeping it consistent with the base interface. In addition, decorators aren\u2019t allowed to break the flow of the request.</p> <p>Composite and Decorator have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.</p> <p>A Decorator is like a Composite but only has one child component. There\u2019s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just \u201csums up\u201d its children\u2019s results.</p> <p>However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.</p> <p>Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.</p> <p>Decorator lets you change the skin of an object, while Strategy lets you change the guts.</p> <p>Decorator and Proxy have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a Proxy usually manages the life cycle of its service object on its own, whereas the composition of Decorators is always controlled by the client.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Facade/","title":"Facade","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Facade/#facade","title":"Facade","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Facade/#intent","title":"Intent","text":"<p>Facade\u2003is a structural design pattern that provides a simplified interface to a library, a framework, or any other complex set of\u2003classes.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Facade/#problem","title":"Problem","text":"<p>Imagine that you must make your code work with a broad set of objects that belong to a sophisticated library or framework. Ordinarily, you\u2019d need to initialize all of those objects, keep track of dependencies, execute methods in the correct order, and so on.</p> <p>As a result, the business logic of your classes would become tightly coupled to the implementation details of 3rd-party classes, making it hard to comprehend and maintain.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Facade/#solution","title":"Solution","text":"<p>A facade is a class that provides a simple interface to a complex subsystem which contains lots of moving parts. A facade might provide limited functionality in comparison to working with the subsystem directly. However, it includes only those features that clients really care about.</p> <p>Having a facade is handy when you need to integrate your app with a sophisticated library that has dozens of features, but you just need a tiny bit of its functionality.</p> <p>For instance, an app that uploads short funny videos with cats to social media could potentially use a professional video conversion library. However, all that it really needs is a class with the single method\u2003<code>encode(filename, format)</code>. After creating such a class and connecting it with the video conversion library, you\u2019ll have your first facade.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Facade/#real-world-analogy","title":"Real-World Analogy","text":"<p>Placing orders by\u2003phone.</p> <p>When you call a shop to place a phone order, an operator is your facade to all services and departments of the shop. The operator provides you with a simple voice interface to the ordering system, payment gateways, and various delivery services.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Facade/#structure","title":"Structure","text":"<ol> <li>The\u2003Facade\u2003provides convenient access to a particular part of the subsystem\u2019s functionality. It knows where to direct the client\u2019s request and how to operate all the moving parts.</li> <li>An\u2003Additional Facade\u2003class can be created to prevent polluting a single facade with unrelated features that might make it yet another complex structure. Additional facades can be used by both clients and other facades.</li> <li> <p>The\u2003Complex Subsystem\u2003consists of dozens of various objects. To make them all do something meaningful, you have to dive deep into the subsystem\u2019s implementation details, such as initializing objects in the correct order and supplying them with data in the proper format.</p> <p>Subsystem classes aren\u2019t aware of the facade\u2019s existence. They operate within the system and work with each other directly.</p> </li> <li> <p>The\u2003Client\u2003uses the facade instead of calling the subsystem objects directly.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Facade/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Facade\u2003pattern simplifies interaction with a complex video conversion framework.</p> <p></p> <p>An example of isolating multiple dependencies within a single facade\u2003class.</p> <p>Instead of making your code work with dozens of the framework classes directly, you create a facade class which encapsulates that functionality and hides it from the rest of the code. This structure also helps you to minimize the effort of upgrading to future versions of the framework or replacing it with another one. The only thing you\u2019d need to change in your app would be the implementation of the facade\u2019s methods. <pre><code>// These are some of the classes of a complex 3rd-party video\n// conversion framework. We don't control that code, therefore\n// can't simplify it.\n\nclass VideoFile\n// ...\n\nclass OggCompressionCodec\n// ...\n\nclass MPEG4CompressionCodec\n// ...\n\nclass CodecFactory\n// ...\n\nclass BitrateReader\n// ...\n\nclass AudioMixer\n// ...\n\n// We create a facade class to hide the framework's complexity\n// behind a simple interface. It's a trade-off between\n// functionality and simplicity.\nclass VideoConverter is\n    method convert(filename, format):File is\n        file = new VideoFile(filename)\n        sourceCodec = new CodecFactory.extract(file)\n        if (format == \"mp4\")\n            destinationCodec = new MPEG4CompressionCodec()\n        else\n            destinationCodec = new OggCompressionCodec()\n        buffer = BitrateReader.read(filename, sourceCodec)\n        result = BitrateReader.convert(buffer, destinationCodec)\n        result = (new AudioMixer()).fix(result)\n        return new File(result)\n\n// Application classes don't depend on a billion classes\n// provided by the complex framework. Also, if you decide to\n// switch frameworks, you only need to rewrite the facade class.\nclass Application is\n    method main() is\n        convertor = new VideoConverter()\n        mp4 = convertor.convert(\"funny-cats-video.ogg\", \"mp4\")\n        mp4.save()\n</code></pre></p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Facade/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Facade pattern when you need to have a limited but straightforward interface to a complex subsystem.     Often, subsystems get more complex over time. Even applying design patterns typically leads to creating more classes. A subsystem may become more flexible and easier to reuse in various contexts, but the amount of configuration and boilerplate code it demands from a client grows ever larger. The Facade attempts to fix this problem by providing a shortcut to the most-used features of the subsystem which fit most client requirements.</p> </li> <li> <p>Use the Facade when you want to structure a subsystem into layers.     Create facades to define entry points to each level of a subsystem. You can reduce coupling between multiple subsystems by requiring them to communicate only through facades.</p> <p>For example, let\u2019s return to our video conversion framework. It can be broken down into two layers: video- and audio-related. For each layer, you can create a facade and then make the classes of each layer communicate with each another via those facades. This approach looks very similar to the Mediator pattern.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Facade/#how-to-implement","title":"How to Implement","text":"<ol> <li>Check whether it\u2019s possible to provide a simpler interface than what an existing subsystem already provides. You\u2019re on the right track if this interface makes the client code independent from many of the subsystem\u2019s classes.</li> <li>Declare and implement this interface in a new facade class. The facade should redirect the calls from the client code to appropriate objects of the subsystem. The facade should be responsible for initializing the subsystem and managing its further life cycle unless the client code already does this.</li> <li>To get the full benefit from the pattern, make all the client code communicate with the subsystem only via the facade. Now the client code is protected from any changes in the subsystem code. For example, when a subsystem gets upgraded to a new version, you will only need to modify the code in the facade.</li> <li>If the facade becomes\u2003Large Class, consider extracting part of its behavior to a new, refined facade class.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Facade/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can isolate your code from the complexity of a subsystem. A facade can become a god object coupled to all classes of an app.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Facade/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.</li> <li>Abstract Factorycan serve as an alternative to Facade when you only want to hide the way the subsystem objects are created from the client code.</li> <li>Flyweight shows how to make lots of little objects, whereas Facade shows how to make a single object that represents an entire subsystem.</li> <li>Facade and Mediator have similar jobs: they try to organize collaboration between lots of tightly coupled classes.<ul> <li>Facade defines a simplified interface to a subsystem of objects, but it doesn\u2019t introduce any new functionality. The subsystem itself is unaware of the facade. Objects within the subsystem can communicate directly.</li> <li>Mediator centralizes communication between components of the system. The components only know about the mediator object and don\u2019t communicate directly.</li> </ul> </li> <li>A Facade class can often be transformed into a Singleton since a single facade object is sufficient in most cases.</li> <li>Facade is similar to Proxy in that both buffer a complex entity and initialize it on its own. Unlike Facade, Proxy has the same interface as its service object, which makes them interchangeable.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Factory/","title":"Factory","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Factory/#factory","title":"Factory","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Factory/#intent","title":"Intent","text":"<p>Factory Method is a creational design pattern that provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be\u2003created.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Factory/#problem","title":"Problem","text":"<p>Imagine that you\u2019re creating a logistics management application. The first version of your app can only handle transportation by trucks, so the bulk of your code lives inside the <code>Truck</code> class.</p> <p>After a while, your app becomes pretty popular. Each day you receive dozens of requests from sea transportation companies to incorporate sea logistics into the app.</p> <p></p> <p>Adding a new class to the program isn\u2019t that simple if the rest of the code is already coupled to existing\u2003classes.</p> <p>Great news, right? But how about the code? At present, most of your code is coupled to the <code>Truck</code> class. Adding <code>Ships</code> into the app would require making changes to the entire codebase. Moreover, if later you decide to add another type of transportation to the app, you will probably need to make all of these changes again.</p> <p>As a result, you will end up with pretty nasty code, riddled with conditionals that switch the app\u2019s behavior depending on the class of transportation objects.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Factory/#solution","title":"Solution","text":"<p>The Factory Method pattern suggests that you replace direct object construction calls (using the <code>new</code> operator) with calls to a special factory method. Don\u2019t worry: the objects are still created via the <code>new</code> operator, but it\u2019s being called from within the factory method. Objects returned by a factory method are often referred to as products.</p> <p></p> <p>Subclasses can alter the class of objects being returned by the factory\u2003method.</p> <p>At first glance, this change may look pointless: we just moved the constructor call from one part of the program to another. However, consider this: now you can override the factory method in a subclass and change the class of products being created by the method.</p> <p>There\u2019s a slight limitation though: subclasses may return different types of products only if these products have a common base class or interface. Also, the factory method in the base class should have its return type declared as this interface.</p> <p></p> <p>All products must follow the same\u2003interface.</p> <p>For example, both <code>Truck</code> and <code>Ship</code> classes should implement the <code>Transport</code> interface, which declares a method called <code>deliver</code>. Each class implements this method differently: trucks deliver cargo by land, ships deliver cargo by sea. The factory method in the <code>RoadLogistics</code> class returns truck objects, whereas the factory method in the <code>SeaLogistics</code> class returns ships.</p> <p></p> <p>As long as all product classes implement a common interface, you can pass their objects to the client code without breaking\u2003it.</p> <p>The code that uses the factory method (often called the client code) doesn\u2019t see a difference between the actual products returned by various subclasses. The client treats all the products as abstract <code>Transport</code>. The client knows that all transport objects are supposed to have the <code>deliver</code> method, but exactly how it works isn\u2019t important to the client.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Factory/#structure","title":"Structure","text":"<ol> <li> <p>The Product declares the interface, which is common to all objects that can be produced by the creator and its subclasses.</p> </li> <li> <p>Concrete Products are different implementations of the product interface.</p> </li> <li> <p>The Creator class declares the factory method that returns new product objects. It\u2019s important that the return type of this method matches the product interface.</p> <p>You can declare the factory method as <code>abstract</code> to force all subclasses to implement their own versions of the method. As an alternative, the base factory method can return some default product type.</p> <p>Note, despite its name, product creation is not the primary responsibility of the creator. Usually, the creator class already has some core business logic related to products. The factory method helps to decouple this logic from the concrete product classes. Here is an analogy: a large software development company can have a training department for programmers. However, the primary function of the company as a whole is still writing code, not producing programmers.</p> </li> <li> <p>Concrete Creators override the base factory method so it returns a different type of product.</p> <p>Note that the factory method doesn\u2019t have to create new instances all the time. It can also return existing objects from a cache, an object pool, or another source.</p> </li> </ol> <p></p> <p>The cross-platform dialog\u2003example.</p> <p>The base <code>Dialog</code> class uses different UI elements to render its window. Under various operating systems, these elements may look a little bit different, but they should still behave consistently. A button in Windows is still a button in Linux.</p> <p>When the factory method comes into play, you don\u2019t need to rewrite the logic of the <code>Dialog</code> class for each operating system. If we declare a factory method that produces buttons inside the base <code>Dialog</code> class, we can later create a subclass that returns Windows-styled buttons from the factory method. The subclass then inherits most of the code from the base class, but, thanks to the factory method, can render Windows-looking buttons on the screen.</p> <p>For this pattern to work, the base <code>Dialog</code> class must work with abstract buttons: a base class or an interface that all concrete buttons follow. This way the code within <code>Dialog</code> remains functional, whichever type of buttons it works with.</p> <p>Of course, you can apply this approach to other UI elements as well. However, with each new factory method you add to the <code>Dialog</code>, you get closer to the Abstract Factory pattern. Fear not, we\u2019ll talk about this pattern later.</p> <pre><code>// The creator class declares the factory method that must\n// return an object of a product class. The creator's subclasses\n// usually provide the implementation of this method.\nclass Dialog is\n    // The creator may also provide some default implementation\n    // of the factory method.\n    abstract method createButton():Button\n\n    // Note that, despite its name, the creator's primary\n    // responsibility isn't creating products. It usually\n    // contains some core business logic that relies on product\n    // objects returned by the factory method. Subclasses can\n    // indirectly change that business logic by overriding the\n    // factory method and returning a different type of product\n    // from it.\n    method render() is\n        // Call the factory method to create a product object.\n        Button okButton = createButton()\n        // Now use the product.\n        okButton.onClick(closeDialog)\n        okButton.render()\n\n// Concrete creators override the factory method to change the\n// resulting product's type.\nclass WindowsDialog extends Dialog is\n    method createButton():Button is\n        return new WindowsButton()\n\nclass WebDialog extends Dialog is\n    method createButton():Button is\n        return new HTMLButton()\n\n// The product interface declares the operations that all\n// concrete products must implement.\ninterface Button is\n    method render()\n    method onClick(f)\n\n// Concrete products provide various implementations of the\n// product interface.\nclass WindowsButton implements Button is\n    method render(a, b) is\n        // Render a button in Windows style.\n    method onClick(f) is\n        // Bind a native OS click event.\n\nclass HTMLButton implements Button is\n    method render(a, b) is\n        // Return an HTML representation of a button.\n    method onClick(f) is\n        // Bind a web browser click event.\n\nclass Application is\n    field dialog: Dialog\n\n    // The application picks a creator's type depending on the\n    // current configuration or environment settings.\n    method initialize() is\n        config = readApplicationConfigFile()\n\n        if (config.OS == \"Windows\") then\n            dialog = new WindowsDialog()\n        else if (config.OS == \"Web\") then\n            dialog = new WebDialog()\n        else\n            throw new Exception(\"Error! Unknown operating system.\")\n\n    // The client code works with an instance of a concrete\n    // creator, albeit through its base interface. As long as\n    // the client keeps working with the creator via the base\n    // interface, you can pass it any creator's subclass.\n    method main() is\n        this.initialize()\n        dialog.render()\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Factory/#pseudocode","title":"Pseudocode","text":"<p>This example illustrates how the Factory Method can be used for creating cross-platform UI elements without coupling the client code to concrete UI classes.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Factory/#applicability","title":"Applicability","text":"<ul> <li>Use the Factory Method when you don\u2019t know beforehand the exact types and dependencies of the objects your code should work with.   The Factory Method separates product construction code from the code that actually uses the product. Therefore it\u2019s easier to extend the product construction code independently from the rest of the code.</li> </ul> <p>For example, to add a new product type to the app, you\u2019ll only need to create a new creator subclass and override the factory method in it.</p> <ul> <li>Use the Factory Method when you want to provide users of your library or framework with a way to extend its internal components.   Inheritance is probably the easiest way to extend the default behavior of a library or framework. But how would the framework recognize that your subclass should be used instead of a standard component?</li> </ul> <p>The solution is to reduce the code that constructs components across the framework into a single factory method and let anyone override this method in addition to extending the component itself.</p> <p>Let\u2019s see how that would work. Imagine that you write an app using an open source UI framework. Your app should have round buttons, but the framework only provides square ones. You extend the standard <code>Button</code> class with a glorious <code>RoundButton</code> subclass. But now you need to tell the main <code>UIFramework</code> class to use the new button subclass instead of a default one.</p> <p>To achieve this, you create a subclass <code>UIWithRoundButtons</code> from a base framework class and override its <code>createButton</code> method. While this method returns <code>Button</code> objects in the base class, you make your subclass return <code>RoundButton</code> objects. Now use the <code>UIWithRoundButtons</code> class instead of <code>UIFramework</code>. And that\u2019s about it!</p> <ul> <li>Use the Factory Method when you want to save system resources by reusing existing objects instead of rebuilding them each time.</li> </ul> <p>You often experience this need when dealing with large, resource-intensive objects such as database connections, file systems, and network resources.</p> <p>Let\u2019s think about what has to be done to reuse an existing object:</p> <ol> <li>First, you need to create some storage to keep track of all of the created objects.</li> <li>When someone requests an object, the program should look for a free object inside that pool.</li> <li>\u2026 and then return it to the client code.</li> <li>If there are no free objects, the program should create a new one (and add it to the pool).</li> </ol> <p>That\u2019s a lot of code! And it must all be put into a single place so that you don\u2019t pollute the program with duplicate code.</p> <p>Probably the most obvious and convenient place where this code could be placed is the constructor of the class whose objects we\u2019re trying to reuse. However, a constructor must always return new objects by definition. It can\u2019t return existing instances.</p> <p>Therefore, you need to have a regular method capable of creating new objects as well as reusing existing ones. That sounds very much like a factory method.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Factory/#how-to-implement","title":"How to Implement","text":"<ol> <li> <p>Make all products follow the same interface. This interface should declare methods that make sense in every product.</p> </li> <li> <p>Add an empty factory method inside the creator class. The return type of the method should match the common product interface.</p> </li> <li> <p>In the creator\u2019s code find all references to product constructors. One by one, replace them with calls to the factory method, while extracting the product creation code into the factory method.</p> <p>You might need to add a temporary parameter to the factory method to control the type of returned product.</p> <p>At this point, the code of the factory method may look pretty ugly. It may have a large <code>switch</code> statement that picks which product class to instantiate. But don\u2019t worry, we\u2019ll fix it soon enough.</p> </li> <li> <p>Now, create a set of creator subclasses for each type of product listed in the factory method. Override the factory method in the subclasses and extract the appropriate bits of construction code from the base method.</p> </li> <li> <p>If there are too many product types and it doesn\u2019t make sense to create subclasses for all of them, you can reuse the control parameter from the base class in subclasses.</p> <p>For instance, imagine that you have the following hierarchy of classes: the base <code>Mail</code> class with a couple of subclasses: <code>AirMail</code> and <code>GroundMail</code>; the <code>Transport</code> classes are <code>Plane</code>, <code>Truck</code> and <code>Train</code>. While the <code>AirMail</code> class only uses <code>Plane</code> objects, <code>GroundMail</code> may work with both <code>Truck</code> and <code>Train</code> objects. You can create a new subclass (say <code>TrainMail</code>) to handle both cases, but there\u2019s another option. The client code can pass an argument to the factory method of the <code>GroundMail</code> class to control which product it wants to receive.</p> </li> <li> <p>If, after all of the extractions, the base factory method has become empty, you can make it abstract. If there\u2019s something left, you can make it a default behavior of the method.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Factory/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You avoid tight coupling between the creator and the concrete products. The code may become more complicated since you need to introduce a lot of new subclasses to implement the pattern. The best case scenario is when you\u2019re introducing the pattern into an existing hierarchy of creator classes. Single Responsibility Principle. You can move the product creation code into one place in the program, making the code easier to support. Open Closed Principle. You can introduce new types of products into the program without breaking existing client code. ## Relations with Other Patterns - Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated). - Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes. - You can use Factory Method along with Iterator to let collection subclasses return different types of iterators that are compatible with the collections. - Prototype isn\u2019t based on inheritance, so it doesn\u2019t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. Factory Method is based on inheritance but doesn\u2019t require an initialization step. - Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Flyweight/","title":"Flyweight","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Flyweight/#flyweight","title":"Flyweight","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Flyweight/#intent","title":"Intent","text":"<p>Flyweight\u2003is a structural design pattern that lets you fit more objects into the available amount of RAM by sharing common parts of state between multiple objects instead of keeping all of the data in each\u2003object.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Flyweight/#problem","title":"Problem","text":"<p>To have some fun after long working hours, you decided to create a simple video game: players would be moving around a map and shooting each other. You chose to implement a realistic particle system and make it a distinctive feature of the game. Vast quantities of bullets, missiles, and shrapnel from explosions should fly all over the map and deliver a thrilling experience to the player.</p> <p>Upon its completion, you pushed the last commit, built the game and sent it to your friend for a test drive. Although the game was running flawlessly on your machine, your friend wasn\u2019t able to play for long. On his computer, the game kept crashing after a few minutes of gameplay. After spending several hours digging through debug logs, you discovered that the game crashed because of an insufficient amount of RAM. It turned out that your friend\u2019s rig was much less powerful than your own computer, and that\u2019s why the problem emerged so quickly on his machine.</p> <p>The actual problem was related to your particle system. Each particle, such as a bullet, a missile or a piece of shrapnel was represented by a separate object containing plenty of data. At some point, when the carnage on a player\u2019s screen reached its climax, newly created particles no longer fit into the remaining RAM, so the program crashed.</p> <p></p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Flyweight/#solution","title":"Solution","text":"<p>On closer inspection of the\u2003<code>Particle</code>\u2003class, you may notice that the color and\u2003sprite\u2003fields consume a lot more memory than other fields. What\u2019s worse is that these two fields store almost identical data across all particles. For example, all bullets have the same color and sprite.</p> <p></p> <p>Other parts of a particle\u2019s state, such as coordinates, movement vector and speed, are unique to each particle. After all, the values of these fields change over time. This data represents the always changing context in which the particle exists, while the color and sprite remain constant for each particle.</p> <p>This constant data of an object is usually called the\u2003intrinsic state. It lives within the object; other objects can only read it, not change it. The rest of the object\u2019s state, often altered \u201cfrom the outside\u201d by other objects, is called the\u2003extrinsic state.</p> <p>The Flyweight pattern suggests that you stop storing the extrinsic state inside the object. Instead, you should pass this state to specific methods which rely on it. Only the intrinsic state stays within the object, letting you reuse it in different contexts. As a result, you\u2019d need fewer of these objects since they only differ in the intrinsic state, which has much fewer variations than the extrinsic.</p> <p></p> <p>Let\u2019s return to our game. Assuming that we had extracted the extrinsic state from our particle class, only three different objects would suffice to represent all particles in the game: a bullet, a missile, and a piece of shrapnel. As you\u2019ve probably guessed by now, an object that only stores the intrinsic state is called\u2003a flyweight.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Flyweight/#extrinsic-state-storage","title":"Extrinsic state storage","text":"<p>Where does the extrinsic state move to? Some class should still store it, right? In most cases, it gets moved to the container object, which aggregates objects before we apply the pattern.</p> <p>In our case, that\u2019s the main\u2003<code>Game</code>\u2003object that stores all particles in the\u2003<code>particles</code>\u2003field. To move the extrinsic state into this class, you need to create several array fields for storing coordinates, vectors, and speed of each individual particle. But that\u2019s not all. You need another array for storing references to a specific flyweight that represents a particle. These arrays must be in sync so that you can access all data of a particle using the same index.</p> <p></p> <p>A more elegant solution is to create a separate context class that would store the extrinsic state along with reference to the flyweight object. This approach would require having just a single array in the container class.</p> <p>Wait a second! Won\u2019t we need to have as many of these contextual objects as we had at the very beginning? Technically, yes. But the thing is, these objects are much smaller than before. The most memory-consuming fields have been moved to just a few flyweight objects. Now, a thousand small contextual objects can reuse a single heavy flyweight object instead of storing a thousand copies of its data.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Flyweight/#flyweight-and-immutability","title":"Flyweight and immutability","text":"<p>Since the same flyweight object can be used in different contexts, you have to make sure that its state can\u2019t be modified. A flyweight should initialize its state just once, via constructor parameters. It shouldn\u2019t expose any setters or public fields to other objects.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Flyweight/#flyweight-factory","title":"Flyweight factory","text":"<p>For more convenient access to various flyweights, you can create a factory method that manages a pool of existing flyweight objects. The method accepts the intrinsic state of the desired flyweight from a client, looks for an existing flyweight object matching this state, and returns it if it was found. If not, it creates a new flyweight and adds it to the pool.</p> <p>There are several options where this method could be placed. The most obvious place is a flyweight container. Alternatively, you could create a new factory class. Or you could make the factory method static and put it inside an actual flyweight class.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Flyweight/#structure","title":"Structure","text":"<ol> <li>The Flyweight pattern is merely an optimization. Before applying it, make sure your program does have the RAM consumption problem related to having a massive number of similar objects in memory at the same time. Make sure that this problem can\u2019t be solved in any other meaningful way.</li> <li>The\u2003Flyweight\u2003class contains the portion of the original object\u2019s state that can be shared between multiple objects. The same flyweight object can be used in many different contexts. The state stored inside a flyweight is called\u2003intrinsic.\u2003The state passed to the flyweight\u2019s methods is called\u2003extrinsic.</li> <li>The\u2003Context\u2003class contains the extrinsic state, unique across all original objects. When a context is paired with one of the flyweight objects, it represents the full state of the original object.</li> <li>Usually, the behavior of the original object remains in the flyweight class. In this case, whoever calls a flyweight\u2019s method must also pass appropriate bits of the extrinsic state into the method\u2019s parameters. On the other hand, the behavior can be moved to the context class, which would use the linked flyweight merely as a data object.</li> <li>The\u2003Client\u2003calculates or stores the extrinsic state of flyweights. From the client\u2019s perspective, a flyweight is a template object which can be configured at runtime by passing some contextual data into parameters of its methods.    </li> <li>The\u2003Flyweight Factory\u2003manages a pool of existing flyweights. With the factory, clients don\u2019t create flyweights directly. Instead, they call the factory, passing it bits of the intrinsic state of the desired flyweight. The factory looks over previously created flyweights and either returns an existing one that matches search criteria or creates a new one if nothing is found.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Flyweight/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Flyweight\u2003pattern helps to reduce memory usage when rendering millions of tree objects on a canvas.</p> <p></p> <p>The pattern extracts the repeating intrinsic state from a main\u2003<code>Tree</code>\u2003class and moves it into the flyweight class\u2003<code>TreeType</code>.</p> <p>Now instead of storing the same data in multiple objects, it\u2019s kept in just a few flyweight objects and linked to appropriate\u2003<code>Tree</code>\u2003objects which act as contexts. The client code creates new tree objects using the flyweight factory, which encapsulates the complexity of searching for the right object and reusing it if needed.</p> <pre><code>// The flyweight class contains a portion of the state of a\n// tree. These fields store values that are unique for each\n// particular tree. For instance, you won't find here the tree\n// coordinates. But the texture and colors shared between many\n// trees are here. Since this data is usually BIG, you'd waste a\n// lot of memory by keeping it in each tree object. Instead, we\n// can extract texture, color and other repeating data into a\n// separate object which lots of individual tree objects can\n// reference.\nclass TreeType is\n    field name\n    field color\n    field texture\n    constructor TreeType(name, color, texture) { ... }\n    method draw(canvas, x, y) is\n        // 1. Create a bitmap of a given type, color &amp; texture.\n        // 2. Draw the bitmap on the canvas at X and Y coords.\n\n// Flyweight factory decides whether to re-use existing\n// flyweight or to create a new object.\nclass TreeFactory is\n    static field treeTypes: collection of tree types\n    static method getTreeType(name, color, texture) is\n        type = treeTypes.find(name, color, texture)\n        if (type == null)\n            type = new TreeType(name, color, texture)\n            treeTypes.add(type)\n        return type\n\n// The contextual object contains the extrinsic part of the tree\n// state. An application can create billions of these since they\n// are pretty small: just two integer coordinates and one\n// reference field.\nclass Tree is\n    field x,y\n    field type: TreeType\n    constructor Tree(x, y, type) { ... }\n    method draw(canvas) is\n        type.draw(canvas, this.x, this.y)\n\n// The Tree and the Forest classes are the flyweight's clients.\n// You can merge them if you don't plan to develop the Tree\n// class any further.\nclass Forest is\n    field trees: collection of Trees\n\n    method plantTree(x, y, name, color, texture) is\n        type = TreeFactory.getTreeType(name, color, texture)\n        tree = new Tree(x, y, type)\n        trees.add(tree)\n\n    method draw(canvas) is\n        foreach (tree in trees) do\n            tree.draw(canvas)\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Flyweight/#applicability","title":"Applicability","text":"<ul> <li>Use the Flyweight pattern only when your program must support a huge number of objects which barely fit into available RAM.     The benefit of applying the pattern depends heavily on how and where it\u2019s used. It\u2019s most useful when:<ul> <li>an application needs to spawn a huge number of similar objects</li> <li>this drains all available RAM on a target device</li> <li>the objects contain duplicate states which can be extracted and shared between multiple objects</li> </ul> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Flyweight/#how-to-implement","title":"How to Implement","text":"<ol> <li> <p>Divide fields of a class that will become a flyweight into two parts:</p> <ul> <li>the intrinsic state: the fields that contain unchanging data duplicated across many objects</li> <li>the extrinsic state: the fields that contain contextual data unique to each object 2.  Leave the fields that represent the intrinsic state in the class, but make sure they\u2019re immutable. They should take their initial values only inside the constructor. 3.  Go over methods that use fields of the extrinsic state. For each field used in the method, introduce a new parameter and use it instead of the field. 4.  Optionally, create a factory class to manage the pool of flyweights. It should check for an existing flyweight before creating a new one. Once the factory is in place, clients must only request flyweights through it. They should describe the desired flyweight by passing its intrinsic state to the factory. 5.  The client must store or calculate values of the extrinsic state (context) to be able to call methods of flyweight objects. For the sake of convenience, the extrinsic state along with the flyweight-referencing field may be moved to a separate context class.</li> </ul> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Flyweight/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can save lots of RAM, assuming your program has tons of similar objects. You might be trading RAM over CPU cycles when some of the context data needs to be recalculated each time somebody calls a flyweight method. The code becomes much more complicated. New team members will always be wondering why the state of an entity was separated in such a way.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Flyweight/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.</li> <li>Flyweight shows how to make lots of little objects, whereas Facade shows how to make a single object that represents an entire subsystem.</li> <li>Flyweight would resemble Singleton if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:<ol> <li>There should be only one Singleton instance, whereas a Flyweight class can have multiple instances with different intrinsic states.</li> <li>The Singleton object can be mutable. Flyweight objects are immutable.</li> </ol> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Iterator/","title":"Iterator","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Iterator/#iterator","title":"Iterator","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Iterator/#intent","title":"Intent","text":"<p>Iterator\u2003is a behavioral design pattern that lets you traverse elements of a collection without exposing its underlying representation (list, stack, tree,\u2003etc.). Collections are one of the most used data types in programming. Nonetheless, a collection is just a container for a group of objects.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Iterator/#problem","title":"Problem","text":"<p>Various types of\u2003collections.</p> <p>Most collections store their elements in simple lists. However, some of them are based on stacks, trees, graphs and other complex data structures.</p> <p>But no matter how a collection is structured, it must provide some way of accessing its elements so that other code can use these elements. There should be a way to go through each element of the collection without accessing the same elements over and over.</p> <p>This may sound like an easy job if you have a collection based on a list. You just loop over all of the elements. But how do you sequentially traverse elements of a complex data structure, such as a tree? For example, one day you might be just fine with depth-first traversal of a tree. Yet the next day you might require breadth-first traversal. And the next week, you might need something else, like random access to the tree elements.</p> <p></p> <p>The same collection can be traversed in several different\u2003ways.</p> <p>Adding more and more traversal algorithms to the collection gradually blurs its primary responsibility, which is efficient data storage. Additionally, some algorithms might be tailored for a specific application, so including them into a generic collection class would be weird.</p> <p>On the other hand, the client code that\u2019s supposed to work with various collections may not even care how they store their elements. However, since collections all provide different ways of accessing their elements, you have no option other than to couple your code to the specific collection classes.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Iterator/#solution","title":"Solution","text":"<p>The main idea of the Iterator pattern is to extract the traversal behavior of a collection into a separate object called an\u2003iterator.</p> <p></p> <p>Iterators implement various traversal algorithms. Several iterator objects can traverse the same collection at the same\u2003time.</p> <p>In addition to implementing the algorithm itself, an iterator object encapsulates all of the traversal details, such as the current position and how many elements are left till the end. Because of this, several iterators can go through the same collection at the same time, independently of each other.</p> <p>Usually, iterators provide one primary method for fetching elements of the collection. The client can keep running this method until it doesn\u2019t return anything, which means that the iterator has traversed all of the elements.</p> <p>All iterators must implement the same interface. This makes the client code compatible with any collection type or any traversal algorithm as long as there\u2019s a proper iterator. If you need a special way to traverse a collection, you just create a new iterator class, without having to change the collection or the client.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Iterator/#real-world-analogy","title":"Real-World Analogy","text":"<p>Various ways to walk around\u2003Rome.</p> <p>You plan to visit Rome for a few days and visit all of its main sights and attractions. But once there, you could waste a lot of time walking in circles, unable to find even the Colosseum.</p> <p>On the other hand, you could buy a virtual guide app for your smartphone and use it for navigation. It\u2019s smart and inexpensive, and you could be staying at some interesting places for as long as you want.</p> <p>A third alternative is that you could spend some of the trip\u2019s budget and hire a local guide who knows the city like the back of his hand. The guide would be able to tailor the tour to your likings, show you every attraction and tell a lot of exciting stories. That\u2019ll be even more fun; but, alas, more expensive, too.</p> <p>All of these options\u2014the random directions born in your head, the smartphone navigator or the human guide\u2014act as iterators over the vast collection of sights and attractions located in Rome.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Iterator/#structure","title":"Structure","text":"<ol> <li> <p>The\u2003Iterator\u2003interface declares the operations required for traversing a collection: fetching the next element, retrieving the current position, restarting iteration,\u2003etc.</p> </li> <li> <p>Concrete Iterators\u2003implement specific algorithms for traversing a collection. The iterator object should track the traversal progress on its own. This allows several iterators to traverse the same collection independently of each other.</p> </li> <li> <p>The\u2003Collection\u2003interface declares one or multiple methods for getting iterators compatible with the collection. Note that the return type of the methods must be declared as the iterator interface so that the concrete collections can return various kinds of iterators.</p> </li> <li> <p>Concrete Collections\u2003return new instances of a particular concrete iterator class each time the client requests one. You might be wondering, where\u2019s the rest of the collection\u2019s code? Don\u2019t worry, it should be in the same class. It\u2019s just that these details aren\u2019t crucial to the actual pattern, so we\u2019re omitting them.</p> </li> <li> <p>The\u2003Client\u2003works with both collections and iterators via their interfaces. This way the client isn\u2019t coupled to concrete classes, allowing you to use various collections and iterators with the same client code.</p> <p>Typically, clients don\u2019t create iterators on their own, but instead get them from collections. Yet, in certain cases, the client can create one directly; for example, when the client defines its own special iterator.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Iterator/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Iterator\u2003pattern is used to walk through a special kind of collection which encapsulates access to Facebook\u2019s social graph. The collection provides several iterators that can traverse profiles in various ways.</p> <p></p> <p>Example of iterating over social\u2003profiles.</p> <p>The \u2018friends\u2019 iterator can be used to go over the friends of a given profile. The \u2018colleagues\u2019 iterator does the same, except it omits friends who don\u2019t work at the same company as a target person. Both iterators implement a common interface which allows clients to fetch profiles without diving into implementation details such as authentication and sending REST requests.</p> <p>The client code isn\u2019t coupled to concrete classes because it works with collections and iterators only through interfaces. If you decide to connect your app to a new social network, you simply need to provide new collection and iterator classes without changing the existing code.</p> <pre><code>// The collection interface must declare a factory method for\n// producing iterators. You can declare several methods if there\n// are different kinds of iteration available in your program.\ninterface SocialNetwork is\n    method createFriendsIterator(profileId):ProfileIterator\n    method createCoworkersIterator(profileId):ProfileIterator\n\n// Each concrete collection is coupled to a set of concrete\n// iterator classes it returns. But the client isn't, since the\n// signature of these methods returns iterator interfaces.\nclass Facebook implements SocialNetwork is\n    // ... The bulk of the collection's code should go here ...\n\n    // Iterator creation code.\n    method createFriendsIterator(profileId) is\n        return new FacebookIterator(this, profileId, \"friends\")\n    method createCoworkersIterator(profileId) is\n        return new FacebookIterator(this, profileId, \"coworkers\")\n\n// The common interface for all iterators.\ninterface ProfileIterator is\n    method getNext():Profile\n    method hasMore():bool\n\n// The concrete iterator class.\nclass FacebookIterator implements ProfileIterator is\n    // The iterator needs a reference to the collection that it\n    // traverses.\n    private field facebook: Facebook\n    private field profileId, type: string\n\n    // An iterator object traverses the collection independently\n    // from other iterators. Therefore it has to store the\n    // iteration state.\n    private field currentPosition\n    private field cache: array of Profile\n\n    constructor FacebookIterator(facebook, profileId, type) is\n        this.facebook = facebook\n        this.profileId = profileId\n        this.type = type\n\n    private method lazyInit() is\n        if (cache == null)\n            cache = facebook.socialGraphRequest(profileId, type)\n\n    // Each concrete iterator class has its own implementation\n    // of the common iterator interface.\n    method getNext() is\n        if (hasMore())\n            currentPosition++\n            return cache[currentPosition]\n\n    method hasMore() is\n        lazyInit()\n        return currentPosition &lt; cache.length\n\n// Here is another useful trick: you can pass an iterator to a\n// client class instead of giving it access to a whole\n// collection. This way, you don't expose the collection to the\n// client.\n//\n// And there's another benefit: you can change the way the\n// client works with the collection at runtime by passing it a\n// different iterator. This is possible because the client code\n// isn't coupled to concrete iterator classes.\nclass SocialSpammer is\n    method send(iterator: ProfileIterator, message: string) is\n        while (iterator.hasMore())\n            profile = iterator.getNext()\n            System.sendEmail(profile.getEmail(), message)\n\n// The application class configures collections and iterators\n// and then passes them to the client code.\nclass Application is\n    field network: SocialNetwork\n    field spammer: SocialSpammer\n\n    method config() is\n        if working with Facebook\n            this.network = new Facebook()\n        if working with LinkedIn\n            this.network = new LinkedIn()\n        this.spammer = new SocialSpammer()\n\n    method sendSpamToFriends(profile) is\n        iterator = network.createFriendsIterator(profile.getId())\n        spammer.send(iterator, \"Very important message\")\n\n    method sendSpamToCoworkers(profile) is\n        iterator = network.createCoworkersIterator(profile.getId())\n        spammer.send(iterator, \"Very important message\")\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Iterator/#applicability","title":"Applicability","text":"<ul> <li>Use the Iterator pattern when your collection has a complex data structure under the hood, but you want to hide its complexity from clients (either for convenience or security reasons).     \u2003The iterator encapsulates the details of working with a complex data structure, providing the client with several simple methods of accessing the collection elements. While this approach is very convenient for the client, it also protects the collection from careless or malicious actions which the client would be able to perform if working with the collection directly.</li> <li>Use the pattern to reduce duplication of the traversal code across your app.     \u2003The code of non-trivial iteration algorithms tends to be very bulky. When placed within the business logic of an app, it may blur the responsibility of the original code and make it less maintainable. Moving the traversal code to designated iterators can help you make the code of the application more lean and clean.</li> <li>Use the Iterator when you want your code to be able to traverse different data structures or when types of these structures are unknown beforehand.     \u2003The pattern provides a couple of generic interfaces for both collections and iterators. Given that your code now uses these interfaces, it\u2019ll still work if you pass it various kinds of collections and iterators that implement these interfaces.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Iterator/#how-to-implement","title":"How to Implement","text":"<ol> <li> <p>Declare the iterator interface. At the very least, it must have a method for fetching the next element from a collection. But for the sake of convenience you can add a couple of other methods, such as fetching the previous element, tracking the current position, and checking the end of the iteration.</p> </li> <li> <p>Declare the collection interface and describe a method for fetching iterators. The return type should be equal to that of the iterator interface. You may declare similar methods if you plan to have several distinct groups of iterators.</p> </li> <li> <p>Implement concrete iterator classes for the collections that you want to be traversable with iterators. An iterator object must be linked with a single collection instance. Usually, this link is established via the iterator\u2019s constructor.</p> </li> <li> <p>Implement the collection interface in your collection classes. The main idea is to provide the client with a shortcut for creating iterators, tailored for a particular collection class. The collection object must pass itself to the iterator\u2019s constructor to establish a link between them.</p> </li> <li> <p>Go over the client code to replace all of the collection traversal code with the use of iterators. The client fetches a new iterator object each time it needs to iterate over the collection elements.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Iterator/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons Single Responsibility Principle. You can clean up the client code and the collections by extracting bulky traversal algorithms into separate classes. Applying the pattern can be an overkill if your app only works with simple collections. Open Closed Principle. You can implement new types of collections and iterators and pass them to existing code without breaking anything. Using an iterator may be less efficient than going through elements of some specialized collections directly. You can iterate over the same collection in parallel because each iterator object contains its own iteration state. For the same reason, you can delay an iteration and continue it when needed.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Iterator/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>You can use Iterators to traverse Composite trees.</li> <li>You can use Factory Method along with Iterator to let collection subclasses return different types of iterators that are compatible with the collections.</li> <li>You can use Memento along with Iterator to capture the current iteration state and roll it back if necessary.</li> <li>You can use Visitor along with Iterator to traverse a complex data structure and execute some operation over its elements, even if they all have different classes.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Mediator/","title":"Mediator","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Mediator/#mediator","title":"Mediator","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Mediator/#intent","title":"Intent","text":"<p>Mediator\u2003is a behavioral design pattern that lets you reduce chaotic dependencies between objects. The pattern restricts direct communications between the objects and forces them to collaborate only via a mediator\u2003object.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Mediator/#problem","title":"Problem","text":"<p>Say you have a dialog for creating and editing customer profiles. It consists of various form controls such as text fields, checkboxes, buttons,\u2003etc.</p> <p></p> <p>Relations between elements of the user interface can become chaotic as the application\u2003evolves.</p> <p>Some of the form elements may interact with others. For instance, selecting the \u201cI have a dog\u201d checkbox may reveal a hidden text field for entering the dog\u2019s name. Another example is the submit button that has to validate values of all fields before saving the data.</p> <p></p> <p>Elements can have lots of relations with other elements. Hence, changes to some elements may affect the\u2003others.</p> <p>By having this logic implemented directly inside the code of the form elements you make these elements\u2019 classes much harder to reuse in other forms of the app. For example, you won\u2019t be able to use that checkbox class inside another form, because it\u2019s coupled to the dog\u2019s text field. You can use either all the classes involved in rendering the profile form, or none at all.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Mediator/#solution","title":"Solution","text":"<p>The Mediator pattern suggests that you should cease all direct communication between the components which you want to make independent of each other. Instead, these components must collaborate indirectly, by calling a special mediator object that redirects the calls to appropriate components. As a result, the components depend only on a single mediator class instead of being coupled to dozens of their colleagues.</p> <p>In our example with the profile editing form, the dialog class itself may act as the mediator. Most likely, the dialog class is already aware of all of its sub-elements, so you won\u2019t even need to introduce new dependencies into this class.</p> <p></p> <p>UI elements should communicate indirectly, via the mediator\u2003object.</p> <p>The most significant change happens to the actual form elements. Let\u2019s consider the submit button. Previously, each time a user clicked the button, it had to validate the values of all individual form elements. Now its single job is to notify the dialog about the click. Upon receiving this notification, the dialog itself performs the validations or passes the task to the individual elements. Thus, instead of being tied to a dozen form elements, the button is only dependent on the dialog class.</p> <p>You can go further and make the dependency even looser by extracting the common interface for all types of dialogs. The interface would declare the notification method which all form elements can use to notify the dialog about events happening to those elements. Thus, our submit button should now be able to work with any dialog that implements that interface.</p> <p>This way, the Mediator pattern lets you encapsulate a complex web of relations between various objects inside a single mediator object. The fewer dependencies a class has, the easier it becomes to modify, extend or reuse that class.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Mediator/#real-world-analogy","title":"Real-World Analogy","text":"<p>Aircraft pilots don\u2019t talk to each other directly when deciding who gets to land their plane next. All communication goes through the control\u2003tower.</p> <p>Pilots of aircraft that approach or depart the airport control area don\u2019t communicate directly with each other. Instead, they speak to an air traffic controller, who sits in a tall tower somewhere near the airstrip. Without the air traffic controller, pilots would need to be aware of every plane in the vicinity of the airport, discussing landing priorities with a committee of dozens of other pilots. That would probably skyrocket the airplane crash statistics.</p> <p>The tower doesn\u2019t need to control the whole flight. It exists only to enforce constraints in the terminal area because the number of involved actors there might be overwhelming to a pilot.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Mediator/#structure","title":"Structure","text":"<ol> <li> <p>Components\u2003are various classes that contain some business logic. Each component has a reference to a mediator, declared with the type of the mediator interface. The component isn\u2019t aware of the actual class of the mediator, so you can reuse the component in other programs by linking it to a different mediator.</p> </li> <li> <p>The\u2003Mediator\u2003interface declares methods of communication with components, which usually include just a single notification method. Components may pass any context as arguments of this method, including their own objects, but only in such a way that no coupling occurs between a receiving component and the sender\u2019s class.</p> </li> <li> <p>Concrete Mediators\u2003encapsulate relations between various components. Concrete mediators often keep references to all components they manage and sometimes even manage their lifecycle.</p> </li> <li> <p>Components must not be aware of other components. If something important happens within or to a component, it must only notify the mediator. When the mediator receives the notification, it can easily identify the sender, which might be just enough to decide what component should be triggered in return.</p> <p>From a component\u2019s perspective, it all looks like a total black box. The sender doesn\u2019t know who\u2019ll end up handling its request, and the receiver doesn\u2019t know who sent the request in the first place.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Mediator/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Mediator\u2003pattern helps you eliminate mutual dependencies between various UI classes: buttons, checkboxes and text labels.</p> <p></p> <p>Structure of the UI dialog\u2003classes.</p> <p>An element, triggered by a user, doesn\u2019t communicate with other elements directly, even if it looks like it\u2019s supposed to. Instead, the element only needs to let its mediator know about the event, passing any contextual info along with that notification.</p> <p>In this example, the whole authentication dialog acts as the mediator. It knows how concrete elements are supposed to collaborate and facilitates their indirect communication. Upon receiving a notification about an event, the dialog decides what element should address the event and redirects the call accordingly.</p> <pre><code>// The mediator interface declares a method used by components\n// to notify the mediator about various events. The mediator may\n// react to these events and pass the execution to other\n// components.\ninterface Mediator is\n    method notify(sender: Component, event: string)\n\n// The concrete mediator class. The intertwined web of\n// connections between individual components has been untangled\n// and moved into the mediator.\nclass AuthenticationDialog implements Mediator is\n    private field title: string\n    private field loginOrRegisterChkBx: Checkbox\n    private field loginUsername, loginPassword: Textbox\n    private field registrationUsername, registrationPassword,\n                  registrationEmail: Textbox\n    private field okBtn, cancelBtn: Button\n\n    constructor AuthenticationDialog() is\n        // Create all component objects by passing the current\n        // mediator into their constructors to establish links.\n\n    // When something happens with a component, it notifies the\n    // mediator. Upon receiving a notification, the mediator may\n    // do something on its own or pass the request to another\n    // component.\n    method notify(sender, event) is\n        if (sender == loginOrRegisterChkBx and event == \"check\")\n            if (loginOrRegisterChkBx.checked)\n                title = \"Log in\"\n                // 1. Show login form components.\n                // 2. Hide registration form components.\n            else\n                title = \"Register\"\n                // 1. Show registration form components.\n                // 2. Hide login form components\n\n        if (sender == okBtn &amp;&amp; event == \"click\")\n            if (loginOrRegister.checked)\n                // Try to find a user using login credentials.\n                if (!found)\n                    // Show an error message above the login\n                    // field.\n            else\n                // 1. Create a user account using data from the\n                // registration fields.\n                // 2. Log that user in.\n                // ...\n\n// Components communicate with a mediator using the mediator\n// interface. Thanks to that, you can use the same components in\n// other contexts by linking them with different mediator\n// objects.\nclass Component is\n    field dialog: Mediator\n\n    constructor Component(dialog) is\n        this.dialog = dialog\n\n    method click() is\n        dialog.notify(this, \"click\")\n\n    method keypress() is\n        dialog.notify(this, \"keypress\")\n\n// Concrete components don't talk to each other. They have only\n// one communication channel, which is sending notifications to\n// the mediator.\nclass Button extends Component is\n    // ...\n\nclass Textbox extends Component is\n    // ...\n\nclass Checkbox extends Component is\n    method check() is\n        dialog.notify(this, \"check\")\n    // ...\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Mediator/#applicability","title":"Applicability","text":"<ul> <li>Use the Mediator pattern when it\u2019s hard to change some of the classes because they are tightly coupled to a bunch of other classes.     \u2003The pattern lets you extract all the relationships between classes into a separate class, isolating any changes to a specific component from the rest of the components.</li> <li>Use the pattern when you can\u2019t reuse a component in a different program because it\u2019s too dependent on other components.     \u2003After you apply the Mediator, individual components become unaware of the other components. They could still communicate with each other, albeit indirectly, through a mediator object. To reuse a component in a different app, you need to provide it with a new mediator class.</li> <li>Use the Mediator when you find yourself creating tons of component subclasses just to reuse some basic behavior in various contexts.     Since all relations between components are contained within the mediator, it\u2019s easy to define entirely new ways for these components to collaborate by introducing new mediator classes, without having to change the components themselves.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Mediator/#how-to-implement","title":"How to Implement","text":"<ol> <li> <p>Identify a group of tightly coupled classes which would benefit from being more independent (e.g., for easier maintenance or simpler reuse of these classes).</p> </li> <li> <p>Declare the mediator interface and describe the desired communication protocol between mediators and various components. In most cases, a single method for receiving notifications from components is sufficient.</p> <p>This interface is crucial when you want to reuse component classes in different contexts. As long as the component works with its mediator via the generic interface, you can link the component with a different implementation of the mediator.</p> </li> <li> <p>Implement the concrete mediator class. Consider storing references to all components inside the mediator. This way, you could call any component from the mediator\u2019s methods.</p> </li> <li> <p>You can go even further and make the mediator responsible for the creation and destruction of component objects. After this, the mediator may resemble a\u2003Factory\u2003or a\u2003Facade.</p> </li> <li> <p>Components should store a reference to the mediator object. The connection is usually established in the component\u2019s constructor, where a mediator object is passed as an argument.</p> </li> <li> <p>Change the components\u2019 code so that they call the mediator\u2019s notification method instead of methods on other components. Extract the code that involves calling other components into the mediator class. Execute this code whenever the mediator receives notifications from that component.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Mediator/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons Single Responsibility Principle. You can extract the communications between various components into a single place, making it easier to comprehend and maintain. \u2003Over time a mediator can evolve into a\u2003God Object. Open Closed Principle. You can introduce new mediators without having to change the actual components. You can reduce coupling between various components of a program. You can reuse individual components more easily.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Mediator/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:<ul> <li>Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.</li> <li>Command establishes unidirectional connections between senders and receivers.</li> <li>Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.</li> <li>Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.</li> </ul> </li> <li>Facade and Mediator have similar jobs: they try to organize collaboration between lots of tightly coupled classes.<ul> <li>Facade defines a simplified interface to a subsystem of objects, but it doesn\u2019t introduce any new functionality. The subsystem itself is unaware of the Facade. Objects within the subsystem can communicate directly.</li> <li>Mediator centralizes communication between components of the system. The components only know about the mediator object and don\u2019t communicate directly.</li> </ul> </li> <li> <p>The difference between Mediator and Observer is often elusive. In most cases, you can implement either of these patterns; but sometimes you can apply both simultaneously. Let\u2019s see how we can do that.</p> <p>The primary goal of Mediator is to eliminate mutual dependencies among a set of system components. Instead, these components become dependent on a single mediator object. The goal of Observer is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.</p> <p>There\u2019s a popular implementation of the Mediator pattern that relies on Observer. The mediator object plays the role of publisher, and the components act as subscribers which subscribe to and unsubscribe from the mediator\u2019s events. When Mediator is implemented this way, it may look very similar to Observer.</p> <p>When you\u2019re confused, remember that you can implement the Mediator pattern in other ways. For example, you can permanently link all the components to the same mediator object. This implementation won\u2019t resemble Observer but will still be an instance of the Mediator pattern.</p> <p>Now imagine a program where all components have become publishers, allowing dynamic connections between each other. There won\u2019t be a centralized mediator object, only a distributed set of observers.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Memento/","title":"Memento","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Memento/#memento","title":"Memento","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Memento/#intent","title":"Intent","text":"<p>Memento\u2003is a behavioral design pattern that lets you save and restore the previous state of an object without revealing the details of its\u2003implementation.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Memento/#problem","title":"Problem","text":"<p>Imagine that you\u2019re creating a text editor app. In addition to simple text editing, your editor can format text, insert inline images,\u2003etc.</p> <p>At some point, you decided to let users undo any operations carried out on the text. This feature has become so common over the years that nowadays people expect every app to have it. For the implementation, you chose to take the direct approach. Before performing any operation, the app records the state of all objects and saves it in some storage. Later, when a user decides to revert an action, the app fetches the latest snapshot from the history and uses it to restore the state of all objects.</p> <p></p> <p>Before executing an operation, the app saves a snapshot of the objects\u2019 state, which can later be used to restore objects to their previous\u2003state.</p> <p>Let\u2019s think about those state snapshots. How exactly would you produce one? You\u2019d probably need to go over all the fields in an object and copy their values into storage. However, this would only work if the object had quite relaxed access restrictions to its contents. Unfortunately, most real objects won\u2019t let others peek inside them that easily, hiding all significant data in private fields.</p> <p>Ignore that problem for now and let\u2019s assume that our objects behave like hippies: preferring open relations and keeping their state public. While this approach would solve the immediate problem and let you produce snapshots of objects\u2019 states at will, it still has some serious issues. In the future, you might decide to refactor some of the editor classes, or add or remove some of the fields. Sounds easy, but this would also require changing the classes responsible for copying the state of the affected objects.</p> <p></p> <p>How to make a copy of the object\u2019s private\u2003state?</p> <p>But there\u2019s more. Let\u2019s consider the actual \u201csnapshots\u201d of the editor\u2019s state. What data does it contain? At a bare minimum, it must contain the actual text, cursor coordinates, current scroll position,\u2003etc. To make a snapshot, you\u2019d need to collect these values and put them into some kind of container.</p> <p>Most likely, you\u2019re going to store lots of these container objects inside some list that would represent the history. Therefore the containers would probably end up being objects of one class. The class would have almost no methods, but lots of fields that mirror the editor\u2019s state. To allow other objects to write and read data to and from a snapshot, you\u2019d probably need to make its fields public. That would expose all the editor\u2019s states, private or not. Other classes would become dependent on every little change to the snapshot class, which would otherwise happen within private fields and methods without affecting outer classes.</p> <p>It looks like we\u2019ve reached a dead end: you either expose all internal details of classes, making them too fragile, or restrict access to their state, making it impossible to produce snapshots. Is there any other way to implement the \u201cundo\u201d?</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Memento/#solution","title":"Solution","text":"<p>All problems that we\u2019ve just experienced are caused by broken encapsulation. Some objects try to do more than they are supposed to. To collect the data required to perform some action, they invade the private space of other objects instead of letting these objects perform the actual action.</p> <p>The Memento pattern delegates creating the state snapshots to the actual owner of that state, the\u2003originator\u2003object. Hence, instead of other objects trying to copy the editor\u2019s state from the \u201coutside,\u201d the editor class itself can make the snapshot since it has full access to its own state.</p> <p>The pattern suggests storing the copy of the object\u2019s state in a special object called\u2003memento. The contents of the memento aren\u2019t accessible to any other object except the one that produced it. Other objects must communicate with mementos using a limited interface which may allow fetching the snapshot\u2019s metadata (creation time, the name of the performed operation,\u2003etc.), but not the original object\u2019s state contained in the snapshot.</p> <p></p> <p>The originator has full access to the memento, whereas the caretaker can only access the\u2003metadata.</p> <p>Such a restrictive policy lets you store mementos inside other objects, usually called\u2003caretakers. Since the caretaker works with the memento only via the limited interface, it\u2019s not able to tamper with the state stored inside the memento. At the same time, the originator has access to all fields inside the memento, allowing it to restore its previous state at will.</p> <p>In our text editor example, we can create a separate history class to act as the caretaker. A stack of mementos stored inside the caretaker will grow each time the editor is about to execute an operation. You could even render this stack within the app\u2019s UI, displaying the history of previously performed operations to a user.</p> <p>When a user triggers the undo, the history grabs the most recent memento from the stack and passes it back to the editor, requesting a roll-back. Since the editor has full access to the memento, it changes its own state with the values taken from the memento.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Memento/#structure","title":"Structure","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Memento/#implementation-based-on-nested-classes","title":"Implementation based on nested classes","text":"<p>The classic implementation of the pattern relies on support for nested classes, available in many popular programming languages (such as C++, C#, and Java).</p> <p></p> <ol> <li> <p>The\u2003Originator\u2003class can produce snapshots of its own state, as well as restore its state from snapshots when needed.</p> </li> <li> <p>The\u2003Memento\u2003is a value object that acts as a snapshot of the originator\u2019s state. It\u2019s a common practice to make the memento immutable and pass it the data only once, via the constructor.</p> </li> <li> <p>The\u2003Caretaker\u2003knows not only \u201cwhen\u201d and \u201cwhy\u201d to capture the originator\u2019s state, but also when the state should be restored.</p> <p>A caretaker can keep track of the originator\u2019s history by storing a stack of mementos. When the originator has to travel back in history, the caretaker fetches the topmost memento from the stack and passes it to the originator\u2019s restoration method.</p> </li> <li> <p>In this implementation, the memento class is nested inside the originator. This lets the originator access the fields and methods of the memento, even though they\u2019re declared private. On the other hand, the caretaker has very limited access to the memento\u2019s fields and methods, which lets it store mementos in a stack but not tamper with their state.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Memento/#implementation-based-on-an-intermediate-interface","title":"Implementation based on an intermediate interface","text":"<p>There\u2019s an alternative implementation, suitable for programming languages that don\u2019t support nested classes (yeah, PHP, I\u2019m talking about you).</p> <p></p> <ol> <li> <p>In the absence of nested classes, you can restrict access to the memento\u2019s fields by establishing a convention that caretakers can work with a memento only through an explicitly declared intermediary interface, which would only declare methods related to the memento\u2019s metadata.</p> </li> <li> <p>On the other hand, originators can work with a memento object directly, accessing fields and methods declared in the memento class. The downside of this approach is that you need to declare all members of the memento public.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Memento/#implementation-with-even-stricter-encapsulation","title":"Implementation with even stricter encapsulation","text":"<p>There\u2019s another implementation which is useful when you don\u2019t want to leave even the slightest chance of other classes accessing the state of the originator through the memento.</p> <p></p> <ol> <li> <p>This implementation allows having multiple types of originators and mementos. Each originator works with a corresponding memento class. Neither originators nor mementos expose their state to anyone.</p> </li> <li> <p>Caretakers are now explicitly restricted from changing the state stored in mementos. Moreover, the caretaker class becomes independent from the originator because the restoration method is now defined in the memento class.</p> </li> <li> <p>Each memento becomes linked to the originator that produced it. The originator passes itself to the memento\u2019s constructor, along with the values of its state. Thanks to the close relationship between these classes, a memento can restore the state of its originator, given that the latter has defined the appropriate setters.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Memento/#pseudocode","title":"Pseudocode","text":"<p>This example uses the Memento pattern alongside the\u2003Command\u2003pattern for storing snapshots of the complex text editor\u2019s state and restoring an earlier state from these snapshots when needed.</p> <p></p> <p>Saving snapshots of the text editor\u2019s\u2003state.</p> <p>The command objects act as caretakers. They fetch the editor\u2019s memento before executing operations related to commands. When a user attempts to undo the most recent command, the editor can use the memento stored in that command to revert itself to the previous state.</p> <p>The memento class doesn\u2019t declare any public fields, getters or setters. Therefore no object can alter its contents. Mementos are linked to the editor object that created them. This lets a memento restore the linked editor\u2019s state by passing the data via setters on the editor object. Since mementos are linked to specific editor objects, you can make your app support several independent editor windows with a centralized undo stack.</p> <pre><code>// The originator holds some important data that may change over\n// time. It also defines a method for saving its state inside a\n// memento and another method for restoring the state from it.\nclass Editor is\n    private field text, curX, curY, selectionWidth\n\n    method setText(text) is\n        this.text = text\n\n    method setCursor(x, y) is\n        this.curX = x\n        this.curY = y\n\n    method setSelectionWidth(width) is\n        this.selectionWidth = width\n\n    // Saves the current state inside a memento.\n    method createSnapshot():Snapshot is\n        // Memento is an immutable object; that's why the\n        // originator passes its state to the memento's\n        // constructor parameters.\n        return new Snapshot(this, text, curX, curY, selectionWidth)\n\n// The memento class stores the past state of the editor.\nclass Snapshot is\n    private field editor: Editor\n    private field text, curX, curY, selectionWidth\n\n    constructor Snapshot(editor, text, curX, curY, selectionWidth) is\n        this.editor = editor\n        this.text = text\n        this.curX = x\n        this.curY = y\n        this.selectionWidth = selectionWidth\n\n    // At some point, a previous state of the editor can be\n    // restored using a memento object.\n    method restore() is\n        editor.setText(text)\n        editor.setCursor(curX, curY)\n        editor.setSelectionWidth(selectionWidth)\n\n// A command object can act as a caretaker. In that case, the\n// command gets a memento just before it changes the\n// originator's state. When undo is requested, it restores the\n// originator's state from a memento.\nclass Command is\n    private field backup: Snapshot\n\n    method makeBackup() is\n        backup = editor.createSnapshot()\n\n    method undo() is\n        if (backup != null)\n            backup.restore()\n    // ...\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Memento/#applicability","title":"Applicability","text":"<ul> <li>Use the Memento pattern when you want to produce snapshots of the object\u2019s state to be able to restore a previous state of the object.     The Memento pattern lets you make full copies of an object\u2019s state, including private fields, and store them separately from the object. While most people remember this pattern thanks to the \u201cundo\u201d use case, it\u2019s also indispensable when dealing with transactions (i.e., if you need to roll back an operation on error).</li> <li>Use the pattern when direct access to the object\u2019s fields/getters/setters violates its encapsulation.     The Memento makes the object itself responsible for creating a snapshot of its state. No other object can read the snapshot, making the original object\u2019s state data safe and secure.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Memento/#how-to-implement","title":"How to Implement","text":"<ol> <li> <p>Determine what class will play the role of the originator. It\u2019s important to know whether the program uses one central object of this type or multiple smaller ones.</p> </li> <li> <p>Create the memento class. One by one, declare a set of fields that mirror the fields declared inside the originator class.</p> </li> <li> <p>Make the memento class immutable. A memento should accept the data just once, via the constructor. The class should have no setters.</p> </li> <li> <p>If your programming language supports nested classes, nest the memento inside the originator. If not, extract a blank interface from the memento class and make all other objects use it to refer to the memento. You may add some metadata operations to the interface, but nothing that exposes the originator\u2019s state.</p> </li> <li> <p>Add a method for producing mementos to the originator class. The originator should pass its state to the memento via one or multiple arguments of the memento\u2019s constructor.</p> <p>The return type of the method should be of the interface you extracted in the previous step (assuming that you extracted it at all). Under the hood, the memento-producing method should work directly with the memento class.</p> </li> <li> <p>Add a method for restoring the originator\u2019s state to its class. It should accept a memento object as an argument. If you extracted an interface in the previous step, make it the type of the parameter. In this case, you need to typecast the incoming object to the memento class, since the originator needs full access to that object.</p> </li> <li> <p>The caretaker, whether it represents a command object, a history, or something entirely different, should know when to request new mementos from the originator, how to store them and when to restore the originator with a particular memento.</p> </li> <li> <p>The link between caretakers and originators may be moved into the memento class. In this case, each memento must be connected to the originator that had created it. The restoration method would also move to the memento class. However, this would all make sense only if the memento class is nested into originator or the originator class provides sufficient setters for overriding its state.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Memento/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can produce snapshots of the object\u2019s state without violating its encapsulation. The app might consume lots of RAM if clients create mementos too often. You can simplify the originator\u2019s code by letting the caretaker maintain the history of the originator\u2019s state. Caretakers should track the originator\u2019s lifecycle to be able to destroy obsolete mementos. Most dynamic programming languages, such as PHP, Python and JavaScript, can\u2019t guarantee that the state within the memento stays untouched.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Memento/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>You can use Command and Memento together when implementing \u201cundo\u201d. In this case, commands are responsible for performing various operations over a target object, while mementos save the state of that object just before a Command gets executed.</li> <li>You can use Memento along with Iterator to capture the current iteration state and roll it back if necessary.</li> <li>Sometimes Prototype can be a simpler alternative to Memento. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn\u2019t have links to external resources, or the links are easy to re-establish.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Observer/","title":"Observer","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Observer/#observer","title":"Observer","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Observer/#intent","title":"Intent","text":"<p>Observer\u2003is a behavioral design pattern that lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they\u2019re\u2003observing.</p> <p></p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Observer/#problem","title":"Problem","text":"<p>Imagine that you have two types of objects: a\u2003<code>Customer</code>\u2003and a\u2003<code>Store</code>. The customer is very interested in a particular brand of product (say, it\u2019s a new model of the iPhone) which should become available in the store very soon.</p> <p>The customer could visit the store every day and check product availability. But while the product is still en route, most of these trips would be pointless.</p> <p></p> <p>Visiting the store vs. sending\u2003spam</p> <p>On the other hand, the store could send tons of emails (which might be considered spam) to all customers each time a new product becomes available. This would save some customers from endless trips to the store. At the same time, it\u2019d upset other customers who aren\u2019t interested in new products.</p> <p>It looks like we\u2019ve got a conflict. Either the customer wastes time checking product availability or the store wastes resources notifying the wrong customers.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Observer/#solution","title":"Solution","text":"<p>The object that has some interesting state is often called\u2003subject, but since it\u2019s also going to notify other objects about the changes to its state, we\u2019ll call it\u2003publisher. All other objects that want to track changes to the publisher\u2019s state are called\u2003subscribers.</p> <p>The Observer pattern suggests that you add a subscription mechanism to the publisher class so individual objects can subscribe to or unsubscribe from a stream of events coming from that publisher. Fear not! Everything isn\u2019t as complicated as it sounds. In reality, this mechanism consists of 1) an array field for storing a list of references to subscriber objects and 2) several public methods which allow adding subscribers to and removing them from that list.</p> <p></p> <p>A subscription mechanism lets individual objects subscribe to event\u2003notifications.</p> <p>Now, whenever an important event happens to the publisher, it goes over its subscribers and calls the specific notification method on their objects.</p> <p>Real apps might have dozens of different subscriber classes that are interested in tracking events of the same publisher class. You wouldn\u2019t want to couple the publisher to all of those classes. Besides, you might not even know about some of them beforehand if your publisher class is supposed to be used by other people.</p> <p>That\u2019s why it\u2019s crucial that all subscribers implement the same interface and that the publisher communicates with them only via that interface. This interface should declare the notification method along with a set of parameters that the publisher can use to pass some contextual data along with the notification.</p> <p></p> <p>Publisher notifies subscribers by calling the specific notification method on their\u2003objects.</p> <p>If your app has several different types of publishers and you want to make your subscribers compatible with all of them, you can go even further and make all publishers follow the same interface. This interface would only need to describe a few subscription methods. The interface would allow subscribers to observe publishers\u2019 states without coupling to their concrete classes.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Observer/#real-world-analogy","title":"Real-World Analogy","text":"<p>Magazine and newspaper\u2003subscriptions.</p> <p>If you subscribe to a newspaper or magazine, you no longer need to go to the store to check if the next issue is available. Instead, the publisher sends new issues directly to your mailbox right after publication or even in advance.</p> <p>The publisher maintains a list of subscribers and knows which magazines they\u2019re interested in. Subscribers can leave the list at any time when they wish to stop the publisher sending new magazine issues to them.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Observer/#structure","title":"Structure","text":"<ol> <li> <p>The\u2003Publisher\u2003issues events of interest to other objects. These events occur when the publisher changes its state or executes some behaviors. Publishers contain a subscription infrastructure that lets new subscribers join and current subscribers leave the list.</p> </li> <li> <p>When a new event happens, the publisher goes over the subscription list and calls the notification method declared in the subscriber interface on each subscriber object.</p> </li> <li> <p>The\u2003Subscriber\u2003interface declares the notification interface. In most cases, it consists of a single\u2003<code>update</code>\u2003method. The method may have several parameters that let the publisher pass some event details along with the update.</p> </li> <li> <p>Concrete Subscribers\u2003perform some actions in response to notifications issued by the publisher. All of these classes must implement the same interface so the publisher isn\u2019t coupled to concrete classes.</p> </li> <li> <p>Usually, subscribers need some contextual information to handle the update correctly. For this reason, publishers often pass some context data as arguments of the notification method. The publisher can pass itself as an argument, letting subscriber fetch any required data directly.</p> </li> <li> <p>The\u2003Client\u2003creates publisher and subscriber objects separately and then registers subscribers for publisher updates.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Observer/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Observer\u2003pattern lets the text editor object notify other service objects about changes in its state.</p> <p></p> <p>Notifying objects about events that happen to other\u2003objects.</p> <p>The list of subscribers is compiled dynamically: objects can start or stop listening to notifications at runtime, depending on the desired behavior of your app.</p> <p>In this implementation, the editor class doesn\u2019t maintain the subscription list by itself. It delegates this job to the special helper object devoted to just that. You could upgrade that object to serve as a centralized event dispatcher, letting any object act as a publisher.</p> <p>Adding new subscribers to the program doesn\u2019t require changes to existing publisher classes, as long as they work with all subscribers through the same interface. <pre><code>// The base publisher class includes subscription management\n// code and notification methods.\nclass EventManager is\n    private field listeners: hash map of event types and listeners\n\n    method subscribe(eventType, listener) is\n        listeners.add(eventType, listener)\n\n    method unsubscribe(eventType, listener) is\n        listeners.remove(eventType, listener)\n\n    method notify(eventType, data) is\n        foreach (listener in listeners.of(eventType)) do\n            listener.update(data)\n\n// The concrete publisher contains real business logic that's\n// interesting for some subscribers. We could derive this class\n// from the base publisher, but that isn't always possible in\n// real life because the concrete publisher might already be a\n// subclass. In this case, you can patch the subscription logic\n// in with composition, as we did here.\nclass Editor is\n    public field events: EventManager\n    private field file: File\n\n    constructor Editor() is\n        events = new EventManager()\n\n    // Methods of business logic can notify subscribers about\n    // changes.\n    method openFile(path) is\n        this.file = new File(path)\n        events.notify(\"open\", file.name)\n\n    method saveFile() is\n        file.write()\n        events.notify(\"save\", file.name)\n\n    // ...\n\n// Here's the subscriber interface. If your programming language\n// supports functional types, you can replace the whole\n// subscriber hierarchy with a set of functions.\ninterface EventListener is\n    method update(filename)\n\n// Concrete subscribers react to updates issued by the publisher\n// they are attached to.\nclass LoggingListener implements EventListener is\n    private field log: File\n    private field message: string\n\n    constructor LoggingListener(log_filename, message) is\n        this.log = new File(log_filename)\n        this.message = message\n\n    method update(filename) is\n        log.write(replace('%s',filename,message))\n\nclass EmailAlertsListener implements EventListener is\n    private field email: string\n    private field message: string\n\n    constructor EmailAlertsListener(email, message) is\n        this.email = email\n        this.message = message\n\n    method update(filename) is\n        system.email(email, replace('%s',filename,message))\n\n// An application can configure publishers and subscribers at\n// runtime.\nclass Application is\n    method config() is\n        editor = new Editor()\n\n        logger = new LoggingListener(\n            \"/path/to/log.txt\",\n            \"Someone has opened the file: %s\")\n        editor.events.subscribe(\"open\", logger)\n\n        emailAlerts = new EmailAlertsListener(\n            \"admin@example.com\",\n            \"Someone has changed the file: %s\")\n        editor.events.subscribe(\"save\", emailAlerts)\n</code></pre></p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Observer/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Observer pattern when changes to the state of one object may require changing other objects, and the actual set of objects is unknown beforehand or changes dynamically.</p> <p>You can often experience this problem when working with classes of the graphical user interface. For example, you created custom button classes, and you want to let the clients hook some custom code to your buttons so that it fires whenever a user presses a button.</p> <p>The Observer pattern lets any object that implements the subscriber interface subscribe for event notifications in publisher objects. You can add the subscription mechanism to your buttons, letting the clients hook up their custom code via custom subscriber classes.</p> </li> <li> <p>Use the pattern when some objects in your app must observe others, but only for a limited time or in specific cases.     \u2003The subscription list is dynamic, so subscribers can join or leave the list whenever they need to.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Observer/#how-to-implement","title":"How to Implement","text":"<ol> <li>Look over your business logic and try to break it down into two parts: the core functionality, independent from other code, will act as the publisher; the rest will turn into a set of subscriber classes.</li> <li>Declare the subscriber interface. At a bare minimum, it should declare a single\u2003<code>update</code>\u2003method.</li> <li>Declare the publisher interface and describe a pair of methods for adding a subscriber object to and removing it from the list. Remember that publishers must work with subscribers only via the subscriber interface.</li> <li> <p>Decide where to put the actual subscription list and the implementation of subscription methods. Usually, this code looks the same for all types of publishers, so the obvious place to put it is in an abstract class derived directly from the publisher interface. Concrete publishers extend that class, inheriting the subscription behavior.</p> <p>However, if you\u2019re applying the pattern to an existing class hierarchy, consider an approach based on composition: put the subscription logic into a separate object, and make all real publishers use it.</p> </li> <li> <p>Create concrete publisher classes. Each time something important happens inside a publisher, it must notify all its subscribers.</p> </li> <li> <p>Implement the update notification methods in concrete subscriber classes. Most subscribers would need some context data about the event. It can be passed as an argument of the notification method.</p> <p>But there\u2019s another option. Upon receiving a notification, the subscriber can fetch any data directly from the notification. In this case, the publisher must pass itself via the update method. The less flexible option is to link a publisher to the subscriber permanently via the constructor.</p> </li> <li> <p>The client must create all necessary subscribers and register them with proper publishers.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Observer/#pros-and-cons","title":"Pros and Cons","text":"Pros Cons Open Closed Principle. You can introduce new subscriber classes without having to change the publisher\u2019s code (and vice versa if there\u2019s a publisher interface). Subscribers are notified in random order. \u2003You can establish relations between objects at runtime.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Observer/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li> <p>Chain of Responsibility,\u2003Command,\u2003Mediator\u2003and\u2003Observer\u2003address various ways of connecting senders and receivers of requests:</p> <ul> <li>Chain of Responsibility\u2003passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.</li> <li>Command\u2003establishes unidirectional connections between senders and receivers.</li> <li>Mediator\u2003eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.</li> <li>Observer\u2003lets receivers dynamically subscribe to and unsubscribe from receiving requests.</li> <li>The difference between\u2003Mediator\u2003and\u2003Observer\u2003is often elusive. In most cases, you can implement either of these patterns; but sometimes you can apply both simultaneously. Let\u2019s see how we can do that.</li> </ul> <p>The primary goal of\u2003Mediator\u2003is to eliminate mutual dependencies among a set of system components. Instead, these components become dependent on a single mediator object. The goal of\u2003Observer\u2003is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.</p> <p>There\u2019s a popular implementation of the\u2003Mediator\u2003pattern that relies on\u2003Observer. The mediator object plays the role of publisher, and the components act as subscribers which subscribe to and unsubscribe from the mediator\u2019s events. When\u2003Mediator\u2003is implemented this way, it may look very similar to\u2003Observer.</p> <p>When you\u2019re confused, remember that you can implement the Mediator pattern in other ways. For example, you can permanently link all the components to the same mediator object. This implementation won\u2019t resemble\u2003Observer\u2003but will still be an instance of the Mediator pattern.</p> <p>Now imagine a program where all components have become publishers, allowing dynamic connections between each other. There won\u2019t be a centralized mediator object, only a distributed set of observers.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Prototype/","title":"Prototype","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Prototype/#prototype","title":"Prototype","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Prototype/#intent","title":"Intent","text":"<p>Prototype\u2003is a creational design pattern that lets you copy existing objects without making your code dependent on their\u2003classes.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Prototype/#problem","title":"Problem","text":"<p>Say you have an object, and you want to create an exact copy of it. How would you do it? First, you have to create a new object of the same class. Then you have to go through all the fields of the original object and copy their values over to the new object.</p> <p>Nice! But there\u2019s a catch. Not all objects can be copied that way because some of the object\u2019s fields may be private and not visible from outside of the object itself.</p> <p></p> <p>Copying an object \u201cfrom the outside\u201d\u2003isn\u2019t\u2003always\u2003possible.</p> <p>There\u2019s one more problem with the direct approach. Since you have to know the object\u2019s class to create a duplicate, your code becomes dependent on that class. If the extra dependency doesn\u2019t scare you, there\u2019s another catch. Sometimes you only know the interface that the object follows, but not its concrete class, when, for example, a parameter in a method accepts any objects that follow some interface.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Prototype/#solution","title":"Solution","text":"<p>The Prototype pattern delegates the cloning process to the actual objects that are being cloned. The pattern declares a common interface for all objects that support cloning. This interface lets you clone an object without coupling your code to the class of that object. Usually, such an interface contains just a single\u2003<code>clone</code>\u2003method.</p> <p>The implementation of the\u2003<code>clone</code>\u2003method is very similar in all classes. The method creates an object of the current class and carries over all of the field values of the old object into the new one. You can even copy private fields because most programming languages let objects access private fields of other objects that belong to the same class.</p> <p>An object that supports cloning is called a\u2003prototype. When your objects have dozens of fields and hundreds of possible configurations, cloning them might serve as an alternative to subclassing.</p> <p></p> <p>Pre-built prototypes can be an alternative to\u2003subclassing.</p> <p>Here\u2019s how it works: you create a set of objects, configured in various ways. When you need an object like the one you\u2019ve configured, you just clone a prototype instead of constructing a new object from scratch.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Prototype/#real-world-analogy","title":"Real-World Analogy","text":"<p>In real life, prototypes are used for performing various tests before starting mass production of a product. However, in this case, prototypes don\u2019t participate in any actual production, playing a passive role instead.</p> <p></p> <p>The division of a\u2003cell.</p> <p>Since industrial prototypes don\u2019t really copy themselves, a much closer analogy to the pattern is the process of mitotic cell division (biology, remember?). After mitotic division, a pair of identical cells is formed. The original cell acts as a prototype and takes an active role in creating the copy.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Prototype/#structure","title":"Structure","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Prototype/#basic-implementation","title":"Basic implementation","text":"<ol> <li>The\u2003Prototype\u2003interface declares the cloning methods. In most cases, it\u2019s a single\u2003<code>clone</code>\u2003method.</li> <li>The\u2003Concrete Prototype\u2003class implements the cloning method. In addition to copying the original object\u2019s data to the clone, this method may also handle some edge cases of the cloning process related to cloning linked objects, untangling recursive dependencies,\u2003etc.</li> <li>The\u2003Client\u2003can produce a copy of any object that follows the prototype interface.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Prototype/#prototype-registry-implementation","title":"Prototype registry implementation","text":"<ol> <li>The\u2003Prototype Registry\u2003provides an easy way to access frequently-used prototypes. It stores a set of pre-built objects that are ready to be copied. The simplest prototype registry is a\u2003<code>name \u2192 prototype</code>\u2003hash map. However, if you need better search criteria than a simple name, you can build a much more robust version of the registry.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Prototype/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Prototype\u2003pattern lets you produce exact copies of geometric objects, without coupling the code to their classes.</p> <p></p> <p>Cloning a set of objects that belong to a class\u2003hierarchy.</p> <p>All shape classes follow the same interface, which provides a cloning method. A subclass may call the parent\u2019s cloning method before copying its own field values to the resulting object.</p> <pre><code>// Base prototype.\nabstract class Shape is\n    field X: int\n    field Y: int\n    field color: string\n\n    // A regular constructor.\n    constructor Shape() is\n        // ...\n\n    // The prototype constructor. A fresh object is initialized\n    // with values from the existing object.\n    constructor Shape(source: Shape) is\n        this()\n        this.X = source.X\n        this.Y = source.Y\n        this.color = source.color\n\n    // The clone operation returns one of the Shape subclasses.\n    abstract method clone():Shape\n\n// Concrete prototype. The cloning method creates a new object\n// in one go by calling the constructor of the current class and\n// passing the current object as the constructor's argument.\n// Performing all the actual copying in the constructor helps to\n// keep the result consistent: the constructor will not return a\n// result until the new object is fully built; thus, no object\n// can have a reference to a partially-built clone.\nclass Rectangle extends Shape is\n    field width: int\n    field height: int\n\n    constructor Rectangle(source: Rectangle) is\n        // A parent constructor call is needed to copy private\n        // fields defined in the parent class.\n        super(source)\n        this.width = source.width\n        this.height = source.height\n\n    method clone():Shape is\n        return new Rectangle(this)\n\nclass Circle extends Shape is\n    field radius: int\n\n    constructor Circle(source: Circle) is\n        super(source)\n        this.radius = source.radius\n\n    method clone():Shape is\n        return new Circle(this)\n\n// Somewhere in the client code.\nclass Application is\n    field shapes: array of Shape\n\n    constructor Application() is\n        Circle circle = new Circle()\n        circle.X = 10\n        circle.Y = 10\n        circle.radius = 20\n        shapes.add(circle)\n\n        Circle anotherCircle = circle.clone()\n        shapes.add(anotherCircle)\n        // The `anotherCircle` variable contains an exact copy\n        // of the `circle` object.\n\n        Rectangle rectangle = new Rectangle()\n        rectangle.width = 10\n        rectangle.height = 20\n        shapes.add(rectangle)\n\n    method businessLogic() is\n        // Prototype rocks because it lets you produce a copy of\n        // an object without knowing anything about its type.\n        Array shapesCopy = new Array of Shapes.\n\n        // For instance, we don't know the exact elements in the\n        // shapes array. All we know is that they are all\n        // shapes. But thanks to polymorphism, when we call the\n        // `clone` method on a shape the program checks its real\n        // class and runs the appropriate clone method defined\n        // in that class. That's why we get proper clones\n        // instead of a set of simple Shape objects.\n        foreach (s in shapes) do\n            shapesCopy.add(s.clone())\n\n        // The `shapesCopy` array contains exact copies of the\n        // `shape` array's children.\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Prototype/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Prototype pattern when your code shouldn\u2019t depend on the concrete classes of objects that you need to copy.     This happens a lot when your code works with objects passed to you from 3rd-party code via some interface. The concrete classes of these objects are unknown, and you couldn\u2019t depend on them even if you wanted to.</p> <p>The Prototype pattern provides the client code with a general interface for working with all objects that support cloning. This interface makes the client code independent from the concrete classes of objects that it clones.</p> </li> <li> <p>Use the pattern when you want to reduce the number of subclasses that only differ in the way they initialize their respective objects.     \u2003Suppose you have a complex class that requires a laborious configuration before it can be used. There are several common ways to configure this class, and this code is scattered through your app. To reduce the duplication, you create several subclasses and put every common configuration code into their constructors. You solved the duplication problem, but now you have lots of dummy subclasses.</p> <p>The Prototype pattern lets you use a set of pre-built objects configured in various ways as prototypes. Instead of instantiating a subclass that matches some configuration, the client can simply look for an appropriate prototype and clone it.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Prototype/#how-to-implement","title":"How to Implement","text":"<ol> <li>Create the prototype interface and declare the\u2003<code>clone</code>\u2003method in it. Or just add the method to all classes of an existing class hierarchy, if you have one.</li> <li> <p>A prototype class must define the alternative constructor that accepts an object of that class as an argument. The constructor must copy the values of all fields defined in the class from the passed object into the newly created instance. If you\u2019re changing a subclass, you must call the parent constructor to let the superclass handle the cloning of its private fields.</p> <p>If your programming language doesn\u2019t support method overloading, you won\u2019t be able to create a separate \u201cprototype\u201d constructor. Thus, copying the object\u2019s data into the newly created clone will have to be performed within the\u2003<code>clone</code>\u2003method. Still, having this code in a regular constructor is safer because the resulting object is returned fully configured right after you call the\u2003<code>new</code>\u2003operator.</p> </li> <li> <p>The cloning method usually consists of just one line: running a\u2003<code>new</code>\u2003operator with the prototypical version of the constructor. Note, that every class must explicitly override the cloning method and use its own class name along with the\u2003<code>new</code>\u2003operator. Otherwise, the cloning method may produce an object of a parent class.</p> </li> <li> <p>Optionally, create a centralized prototype registry to store a catalog of frequently used prototypes.</p> <p>You can implement the registry as a new factory class or put it in the base prototype class with a static method for fetching the prototype. This method should search for a prototype based on search criteria that the client code passes to the method. The criteria might either be a simple string tag or a complex set of search parameters. After the appropriate prototype is found, the registry should clone it and return the copy to the client.</p> <p>Finally, replace the direct calls to the subclasses\u2019 constructors with calls to the factory method of the prototype registry.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Prototype/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can clone objects without coupling to their concrete classes. Cloning complex objects that have circular references might be very tricky. You can get rid of repeated initialization code in favor of cloning pre-built prototypes. You can produce complex objects more conveniently. You get an alternative to inheritance when dealing with configuration presets for complex objects.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Prototype/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).</li> <li>Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.</li> <li>Prototype can help when you need to save copies of Commands into history.</li> <li>Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.</li> <li>Prototype isn\u2019t based on inheritance, so it doesn\u2019t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. Factory Method is based on inheritance but doesn\u2019t require an initialization step.</li> <li>Sometimes Prototype can be a simpler alternative to Memento. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn\u2019t have links to external resources, or the links are easy to re-establish.</li> <li>Abstract Factory, Builders and Prototype can all be implemented as Singleton.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Proxy/","title":"Proxy","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Proxy/#proxy","title":"Proxy","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Proxy/#intent","title":"Intent","text":"<p>Proxy\u2003is a structural design pattern that lets you provide a substitute or placeholder for another object. A proxy controls access to the original object, allowing you to perform something either before or after the request gets through to the original\u2003object.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Proxy/#problem","title":"Problem","text":"<p>Why would you want to control access to an object? Here is an example: you have a massive object that consumes a vast amount of system resources. You need it from time to time, but not always.</p> <p></p> <p>Database queries can be really\u2003slow.</p> <p>You could implement lazy initialization: create this object only when it\u2019s actually needed. All of the object\u2019s clients would need to execute some deferred initialization code. Unfortunately, this would probably cause a lot of code duplication.</p> <p>In an ideal world, we\u2019d want to put this code directly into our object\u2019s class, but that isn\u2019t always possible. For instance, the class may be part of a closed 3rd-party library.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Proxy/#solution","title":"Solution","text":"<p>The Proxy pattern suggests that you create a new proxy class with the same interface as an original service object. Then you update your app so that it passes the proxy object to all of the original object\u2019s clients. Upon receiving a request from a client, the proxy creates a real service object and delegates all the work to it.</p> <p></p> <p>The proxy disguises itself as a database object. It can handle lazy initialization and result caching without the client or the real database object even\u2003knowing.</p> <p>But what\u2019s the benefit? If you need to execute something either before or after the primary logic of the class, the proxy lets you do this without changing that class. Since the proxy implements the same interface as the original class, it can be passed to any client that expects a real service object.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Proxy/#real-world-analogy","title":"Real-World Analogy","text":"<p>Credit cards can be used for payments just the same as\u2003cash.</p> <p>A credit card is a proxy for a bank account, which is a proxy for a bundle of cash. Both implement the same interface: they can be used for making a payment. A consumer feels great because there\u2019s no need to carry loads of cash around. A shop owner is also happy since the income from a transaction gets added electronically to the shop\u2019s bank account without the risk of losing the deposit or getting robbed on the way to the bank.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Proxy/#structure","title":"Structure","text":"<ol> <li> <p>The\u2003Service Interface\u2003declares the interface of the Service. The proxy must follow this interface to be able to disguise itself as a service object.</p> </li> <li> <p>The\u2003Service\u2003is a class that provides some useful business logic.</p> </li> <li> <p>The\u2003Proxy\u2003class has a reference field that points to a service object. After the proxy finishes its processing (e.g., lazy initialization, logging, access control, caching,\u2003etc.), it passes the request to the service object.</p> <p>Usually, proxies manage the full lifecycle of their service objects.</p> </li> <li> <p>The\u2003Client\u2003should work with both services and proxies via the same interface. This way you can pass a proxy into any code that expects a service object.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Proxy/#pseudocode","title":"Pseudocode","text":"<p>This example illustrates how the\u2003Proxy\u2003pattern can help to introduce lazy initialization and caching to a 3rd-party YouTube integration library.</p> <p></p> <p>Caching results of a service with a\u2003proxy.</p> <p>The library provides us with the video downloading class. However, it\u2019s very inefficient. If the client application requests the same video multiple times, the library just downloads it over and over, instead of caching and reusing the first downloaded file.</p> <p>The proxy class implements the same interface as the original downloader and delegates it all the work. However, it keeps track of the downloaded files and returns the cached result when the app requests the same video multiple times. <pre><code>// The interface of a remote service.\ninterface ThirdPartyYouTubeLib is\n    method listVideos()\n    method getVideoInfo(id)\n    method downloadVideo(id)\n\n// The concrete implementation of a service connector. Methods\n// of this class can request information from YouTube. The speed\n// of the request depends on a user's internet connection as\n// well as YouTube's. The application will slow down if a lot of\n// requests are fired at the same time, even if they all request\n// the same information.\nclass ThirdPartyYouTubeClass implements ThirdPartyYouTubeLib is\n    method listVideos() is\n        // Send an API request to YouTube.\n\n    method getVideoInfo(id) is\n        // Get metadata about some video.\n\n    method downloadVideo(id) is\n        // Download a video file from YouTube.\n\n// To save some bandwidth, we can cache request results and keep\n// them for some time. But it may be impossible to put such code\n// directly into the service class. For example, it could have\n// been provided as part of a third party library and/or defined\n// as `final`. That's why we put the caching code into a new\n// proxy class which implements the same interface as the\n// service class. It delegates to the service object only when\n// the real requests have to be sent.\nclass CachedYouTubeClass implements ThirdPartyYouTubeLib is\n    private field service: ThirdPartyYouTubeLib\n    private field listCache, videoCache\n    field needReset\n\n    constructor CachedYouTubeClass(service: ThirdPartyYouTubeLib) is\n        this.service = service\n\n    method listVideos() is\n        if (listCache == null || needReset)\n            listCache = service.listVideos()\n        return listCache\n\n    method getVideoInfo(id) is\n        if (videoCache == null || needReset)\n            videoCache = service.getVideoInfo(id)\n        return videoCache\n\n    method downloadVideo(id) is\n        if (!downloadExists(id) || needReset)\n            service.downloadVideo(id)\n\n// The GUI class, which used to work directly with a service\n// object, stays unchanged as long as it works with the service\n// object through an interface. We can safely pass a proxy\n// object instead of a real service object since they both\n// implement the same interface.\nclass YouTubeManager is\n    protected field service: ThirdPartyYouTubeLib\n\n    constructor YouTubeManager(service: ThirdPartyYouTubeLib) is\n        this.service = service\n\n    method renderVideoPage(id) is\n        info = service.getVideoInfo(id)\n        // Render the video page.\n\n    method renderListPanel() is\n        list = service.listVideos()\n        // Render the list of video thumbnails.\n\n    method reactOnUserInput() is\n        renderVideoPage()\n        renderListPanel()\n\n// The application can configure proxies on the fly.\nclass Application is\n    method init() is\n        aYouTubeService = new ThirdPartyYouTubeClass()\n        aYouTubeProxy = new CachedYouTubeClass(aYouTubeService)\n        manager = new YouTubeManager(aYouTubeProxy)\n        manager.reactOnUserInput()     \n</code></pre></p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Proxy/#applicability","title":"Applicability","text":"<p>There are dozens of ways to utilize the Proxy pattern. Let\u2019s go over the most popular uses.</p> <ul> <li>Lazy initialization (virtual proxy). This is when you have a heavyweight service object that wastes system resources by being always up, even though you only need it from time to time.     Instead of creating the object when the app launches, you can delay the object\u2019s initialization to a time when it\u2019s really needed.</li> <li>Access control (protection proxy). This is when you want only specific clients to be able to use the service object; for instance, when your objects are crucial parts of an operating system and clients are various launched applications (including malicious ones).     The proxy can pass the request to the service object only if the client\u2019s credentials match some criteria.</li> <li>Local execution of a remote service (remote proxy). This is when the service object is located on a remote server.     \u2003In this case, the proxy passes the client request over the network, handling all of the nasty details of working with the network.</li> <li>Logging requests (logging proxy). This is when you want to keep a history of requests to the service object.     The proxy can log each request before passing it to the service.</li> <li>Caching request results (caching proxy). This is when you need to cache results of client requests and manage the life cycle of this cache, especially if results are quite large.     The proxy can implement caching for recurring requests that always yield the same results. The proxy may use the parameters of requests as the cache keys.</li> <li> <p>Smart reference. This is when you need to be able to dismiss a heavyweight object once there are no clients that use it.     The proxy can keep track of clients that obtained a reference to the service object or its results. From time to time, the proxy may go over the clients and check whether they are still active. If the client list gets empty, the proxy might dismiss the service object and free the underlying system resources.</p> <p>The proxy can also track whether the client had modified the service object. Then the unchanged objects may be reused by other clients.</p> </li> </ul> <ol> <li> <p>If there\u2019s no pre-existing service interface, create one to make proxy and service objects interchangeable. Extracting the interface from the service class isn\u2019t always possible, because you\u2019d need to change all of the service\u2019s clients to use that interface. Plan B is to make the proxy a subclass of the service class, and this way it\u2019ll inherit the interface of the service.</p> </li> <li> <p>Create the proxy class. It should have a field for storing a reference to the service. Usually, proxies create and manage the whole life cycle of their services. On rare occasions, a service is passed to the proxy via a constructor by the client.</p> </li> <li> <p>Implement the proxy methods according to their purposes. In most cases, after doing some work, the proxy should delegate the work to the service object.</p> </li> <li> <p>Consider introducing a creation method that decides whether the client gets a proxy or a real service. This can be a simple static method in the proxy class or a full-blown factory method.</p> </li> <li> <p>Consider implementing lazy initialization for the service object.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Proxy/#how-to-implement","title":"How to Implement","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Proxy/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can control the service object without clients knowing about it. The code may become more complicated since you need to introduce a lot of new classes. You can manage the lifecycle of the service object when clients don\u2019t care about it. The response from the service might get delayed. The proxy works even if the service object isn\u2019t ready or is not available. Open Closed Principle. You can introduce new proxies without changing the service or clients.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Proxy/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.</li> <li>Facade is similar to Proxy in that both buffer a complex entity and initialize it on its own. Unlike Facade, Proxy has the same interface as its service object, which makes them interchangeable.</li> <li>Decorator and Proxy have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a Proxy usually manages the life cycle of its service object on its own, whereas the composition of Decorators is always controlled by the client.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Singleton/","title":"Singleton","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Singleton/#singleton","title":"Singleton","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Singleton/#intent","title":"Intent","text":"<p>Singleton\u2003is a creational design pattern that lets you ensure that a class has only one instance, while providing a global access point to this\u2003instance.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Singleton/#problem","title":"Problem","text":"<p>The Singleton pattern solves two problems at the same time, violating the\u2003Single Responsibility Principle:</p> <ol> <li> <p>Ensure that a class has just a single instance. Why would anyone want to control how many instances a class has? The most common reason for this is to control access to some shared resource\u2014for example, a database or a file.</p> <p>Here\u2019s how it works: imagine that you created an object, but after a while decided to create a new one. Instead of receiving a fresh object, you\u2019ll get the one you already created.</p> <p>Note that this behavior is impossible to implement with a regular constructor since a constructor call\u2003must\u2003always return a new object by design.</p> </li> </ol> <p></p> <p>Clients may not even realize that they\u2019re working with the same object all the\u2003time.</p> <ol> <li> <p>Provide a global access point to that instance. Remember those global variables that you (all right, me) used to store some essential objects? While they\u2019re very handy, they\u2019re also very unsafe since any code can potentially overwrite the contents of those variables and crash the app.</p> <p>Just like a global variable, the Singleton pattern lets you access some object from anywhere in the program. However, it also protects that instance from being overwritten by other code.</p> <p>There\u2019s another side to this problem: you don\u2019t want the code that solves problem 1 to be scattered all over your program. It\u2019s much better to have it within one class, especially if the rest of your code already depends on it.</p> </li> </ol> <p>Nowadays, the Singleton pattern has become so popular that people may call something a\u2003singleton\u2003even if it solves just one of the listed problems.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Singleton/#solution","title":"Solution","text":"<p>All implementations of the Singleton have these two steps in common:</p> <ul> <li>Make the default constructor private, to prevent other objects from using the\u2003<code>new</code>\u2003operator with the Singleton class.</li> <li>Create a static creation method that acts as a constructor. Under the hood, this method calls the private constructor to create an object and saves it in a static field. All following calls to this method return the cached object.</li> </ul> <p>If your code has access to the Singleton class, then it\u2019s able to call the Singleton\u2019s static method. So whenever that method is called, the same object is always returned.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Singleton/#real-world-analogy","title":"Real-World Analogy","text":"<p>The government is an excellent example of the Singleton pattern. A country can have only one official government. Regardless of the personal identities of the individuals who form governments, the title, \u201cThe Government of X\u201d, is a global point of access that identifies the group of people in charge.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Singleton/#structure","title":"Structure","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Singleton/#pseudocode","title":"Pseudocode","text":"<p>In this example, the database connection class acts as a\u2003Singleton. This class doesn\u2019t have a public constructor, so the only way to get its object is to call the\u2003<code>getInstance</code>\u2003method. This method caches the first created object and returns it in all subsequent calls.</p> <pre><code>// The Database class defines the `getInstance` method that lets\n// clients access the same instance of a database connection\n// throughout the program.\nclass Database is\n    // The field for storing the singleton instance should be\n    // declared static.\n    private static field instance: Database\n\n    // The singleton's constructor should always be private to\n    // prevent direct construction calls with the `new`\n    // operator.\n    private constructor Database() is\n        // Some initialization code, such as the actual\n        // connection to a database server.\n        // ...\n\n    // The static method that controls access to the singleton\n    // instance.\n    public static method getInstance() is\n        if (Database.instance == null) then\n            acquireThreadLock() and then\n                // Ensure that the instance hasn't yet been\n                // initialized by another thread while this one\n                // has been waiting for the lock's release.\n                if (Database.instance == null) then\n                    Database.instance = new Database()\n        return Database.instance\n\n    // Finally, any singleton should define some business logic\n    // which can be executed on its instance.\n    public method query(sql) is\n        // For instance, all database queries of an app go\n        // through this method. Therefore, you can place\n        // throttling or caching logic here.\n        // ...\n\nclass Application is\n    method main() is\n        Database foo = Database.getInstance()\n        foo.query(\"SELECT ...\")\n        // ...\n        Database bar = Database.getInstance()\n        bar.query(\"SELECT ...\")\n        // The variable `bar` will contain the same object as\n        // the variable `foo`.\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Singleton/#applicability","title":"Applicability","text":"<ul> <li> <p> Use the Singleton pattern when a class in your program should have just a single instance available to all clients; for example, a single database object shared by different parts of the program.     \u2003The Singleton pattern disables all other means of creating objects of a class except for the special creation method. This method either creates a new object or returns an existing one if it has already been created.</p> </li> <li> <p>Use the Singleton pattern when you need stricter control over global variables.     Unlike global variables, the Singleton pattern guarantees that there\u2019s just one instance of a class. Nothing, except for the Singleton class itself, can replace the cached instance.</p> <p>Note that you can always adjust this limitation and allow creating any number of Singleton instances. The only piece of code that needs changing is the body of the\u2003<code>getInstance</code>\u2003method.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Singleton/#how-to-implement","title":"How to Implement","text":"<ol> <li>Add a private static field to the class for storing the singleton instance.</li> <li>Declare a public static creation method for getting the singleton instance.</li> <li>Implement \u201clazy initialization\u201d inside the static method. It should create a new object on its first call and put it into the static field. The method should always return that instance on all subsequent calls.</li> <li>Make the constructor of the class private. The static method of the class will still be able to call the constructor, but not the other objects.</li> <li>Go over the client code and replace all direct calls to the singleton\u2019s constructor with calls to its static creation method.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Singleton/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can be sure that a class has only a single instance. Violates the\u2003Single Responsibility Principle. The pattern solves two problems at the time. You gain a global access point to that instance. The Singleton pattern can mask bad design, for instance, when the components of the program know too much about each other. The singleton object is initialized only when it\u2019s requested for the first time. The Singleton pattern can mask bad design, for instance, when the components of the program know too much about each other. The Singleton pattern can mask bad design, for instance, when the components of the program know too much about each other. The pattern requires special treatment in a multithreaded environment so that multiple threads won\u2019t create a singleton object several times. It may be difficult to Unit Test the client code of the Singleton because many test frameworks rely on inheritance when producing mock objects. Since the constructor of the singleton class is private and overriding static methods is impossible in most languages, you will need to think of a creative way to mock the singleton. Or just don\u2019t write the tests. Or don\u2019t use the Singleton pattern.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Singleton/#relationship-with-other-patterns","title":"Relationship with Other Patterns","text":"<ul> <li> <p>A\u2003Facade\u2003class can often be transformed into a\u2003Singleton\u2003since a single facade object is sufficient in most cases.</p> </li> <li> <p>Flyweight\u2003would resemble\u2003Singleton\u2003if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:</p> <ol> <li>There should be only one Singleton instance, whereas a\u2003Flyweight\u2003class can have multiple instances with different intrinsic states.</li> <li>The\u2003Singleton\u2003object can be mutable. Flyweight objects are immutable.</li> </ol> </li> <li>Abstract Factory, Builder\u2003and\u2003Prototype\u2003can all be implemented as\u2003Singleton.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/State/","title":"State","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/State/#state","title":"State","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/State/#intent","title":"Intent","text":"<p>State\u2003is a behavioral design pattern that lets an object alter its behavior when its internal state changes. It appears as if the object changed its\u2003class.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/State/#problem","title":"Problem","text":"<p>The State pattern is closely related to the concept of a\u2003Finite-State Machine\u2003.</p> <p></p> <p>Finite-State\u2003Machine.</p> <p>The main idea is that, at any given moment, there\u2019s a\u2003finite\u2003number of\u2003states\u2003which a program can be in. Within any unique state, the program behaves differently, and the program can be switched from one state to another instantaneously. However, depending on a current state, the program may or may not switch to certain other states. These switching rules, called\u2003transitions, are also finite and predetermined.</p> <p>You can also apply this approach to objects. Imagine that we have a\u2003<code>Document</code>\u2003class. A document can be in one of three states:\u2003<code>Draft</code>,\u2003<code>Moderation</code>\u2003and\u2003<code>Published</code>. The\u2003<code>publish</code>\u2003method of the document works a little bit differently in each state:</p> <ul> <li>In\u2003<code>Draft</code>, it moves the document to moderation.</li> <li>In\u2003<code>Moderation</code>, it makes the document public, but only if the current user is an administrator.</li> <li>In\u2003<code>Published</code>, it doesn\u2019t do anything at all.</li> </ul> <p></p> <p>Possible states and transitions of a document\u2003object.</p> <p>State machines are usually implemented with lots of conditional statements (<code>if</code>\u2003or\u2003<code>switch</code>) that select the appropriate behavior depending on the current state of the object. Usually, this \u201cstate\u201d is just a set of values of the object\u2019s fields. Even if you\u2019ve never heard about finite-state machines before, you\u2019ve probably implemented a state at least once. Does the following code structure ring a bell?</p> <pre><code>class Document is\n    field state: string\n    // ...\n    method publish() is\n        switch (state)\n            \"draft\":\n                state = \"moderation\"\n                break\n            \"moderation\":\n                if (currentUser.role == \"admin\")\n                    state = \"published\"\n                break\n            \"published\":\n                // Do nothing.\n                break\n    // ...\n\nThe biggest weakness of a state machine based on conditionals reveals itself once we start adding more and more states and state-dependent behaviors to the&amp;emsp;`Document`&amp;emsp;class. Most methods will contain monstrous conditionals that pick the proper behavior of a method according to the current state. Code like this is very difficult to maintain because any change to the transition logic may require changing state conditionals in every method.\n\nThe problem tends to get bigger as a project evolves. It\u2019s quite difficult to predict all possible states and transitions at the design stage. Hence, a lean state machine built with a limited set of conditionals can grow into a bloated mess over time.\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/State/#solution","title":"Solution","text":"<p>The State pattern suggests that you create new classes for all possible states of an object and extract all state-specific behaviors into these classes.</p> <p>Instead of implementing all behaviors on its own, the original object, called\u2003context, stores a reference to one of the state objects that represents its current state, and delegates all the state-related work to that object.</p> <p></p> <p>Document delegates the work to a state\u2003object.</p> <p>To transition the context into another state, replace the active state object with another object that represents that new state. This is possible only if all state classes follow the same interface and the context itself works with these objects through that interface.</p> <p>This structure may look similar to the\u2003Strategy Pattern, but there\u2019s one key difference. In the State pattern, the particular states may be aware of each other and initiate transitions from one state to another, whereas strategies almost never know about each other.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/State/#real-world-analogy","title":"Real-World Analogy","text":"<p>The buttons and switches in your smartphone behave differently depending on the current state of the device:</p> <ul> <li>When the phone is unlocked, pressing buttons leads to executing various functions.</li> <li>When the phone is locked, pressing any button leads to the unlock screen.</li> <li>When the phone\u2019s charge is low, pressing any button shows the charging screen.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/State/#structure","title":"Structure","text":"<ol> <li>Context\u2003stores a reference to one of the concrete state objects and delegates to it all state-specific work. The context communicates with the state object via the state interface. The context exposes a setter for passing it a new state object.</li> <li>The\u2003State\u2003interface declares the state-specific methods. These methods should make sense for all concrete states because you don\u2019t want some of your states to have useless methods that will never be called.</li> <li> <p>Concrete States\u2003provide their own implementations for the state-specific methods. To avoid duplication of similar code across multiple states, you may provide intermediate abstract classes that encapsulate some common behavior.</p> <p>State objects may store a backreference to the context object. Through this reference, the state can fetch any required info from the context object, as well as initiate state transitions.</p> </li> <li> <p>Both context and concrete states can set the next state of the context and perform the actual state transition by replacing the state object linked to the context.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/State/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003State\u2003pattern lets the same controls of the media player behave differently, depending on the current playback state.</p> <p></p> <p>Example of changing object behavior with state\u2003objects.</p> <p>The main object of the player is always linked to a state object that performs most of the work for the player. Some actions replace the current state object of the player with another, which changes the way the player reacts to user interactions. <pre><code>// The AudioPlayer class acts as a context. It also maintains a\n// reference to an instance of one of the state classes that\n// represents the current state of the audio player.\nclass AudioPlayer is\n    field state: State\n    field UI, volume, playlist, currentSong\n\n    constructor AudioPlayer() is\n        this.state = new ReadyState(this)\n\n        // Context delegates handling user input to a state\n        // object. Naturally, the outcome depends on what state\n        // is currently active, since each state can handle the\n        // input differently.\n        UI = new UserInterface()\n        UI.lockButton.onClick(this.clickLock)\n        UI.playButton.onClick(this.clickPlay)\n        UI.nextButton.onClick(this.clickNext)\n        UI.prevButton.onClick(this.clickPrevious)\n\n    // Other objects must be able to switch the audio player's\n    // active state.\n    method changeState(state: State) is\n        this.state = state\n\n    // UI methods delegate execution to the active state.\n    method clickLock() is\n        state.clickLock()\n    method clickPlay() is\n        state.clickPlay()\n    method clickNext() is\n        state.clickNext()\n    method clickPrevious() is\n        state.clickPrevious()\n\n    // A state may call some service methods on the context.\n    method startPlayback() is\n        // ...\n    method stopPlayback() is\n        // ...\n    method nextSong() is\n        // ...\n    method previousSong() is\n        // ...\n    method fastForward(time) is\n        // ...\n    method rewind(time) is\n        // ...\n\n// The base state class declares methods that all concrete\n// states should implement and also provides a backreference to\n// the context object associated with the state. States can use\n// the backreference to transition the context to another state.\nabstract class State is\n    protected field player: AudioPlayer\n\n    // Context passes itself through the state constructor. This\n    // may help a state fetch some useful context data if it's\n    // needed.\n    constructor State(player) is\n        this.player = player\n\n    abstract method clickLock()\n    abstract method clickPlay()\n    abstract method clickNext()\n    abstract method clickPrevious()\n\n// Concrete states implement various behaviors associated with a\n// state of the context.\nclass LockedState extends State is\n\n    // When you unlock a locked player, it may assume one of two\n    // states.\n    method clickLock() is\n        if (player.playing)\n            player.changeState(new PlayingState(player))\n        else\n            player.changeState(new ReadyState(player))\n\n    method clickPlay() is\n        // Locked, so do nothing.\n\n    method clickNext() is\n        // Locked, so do nothing.\n\n    method clickPrevious() is\n        // Locked, so do nothing.\n\n// They can also trigger state transitions in the context.\nclass ReadyState extends State is\n    method clickLock() is\n        player.changeState(new LockedState(player))\n\n    method clickPlay() is\n        player.startPlayback()\n        player.changeState(new PlayingState(player))\n\n    method clickNext() is\n        player.nextSong()\n\n    method clickPrevious() is\n        player.previousSong()\n\nclass PlayingState extends State is\n    method clickLock() is\n        player.changeState(new LockedState(player))\n\n    method clickPlay() is\n        player.stopPlayback()\n        player.changeState(new ReadyState(player))\n\n    method clickNext() is\n        if (event.doubleclick)\n            player.nextSong()\n        else\n            player.fastForward(5)\n\n    method clickPrevious() is\n        if (event.doubleclick)\n            player.previous()\n        else\n            player.rewind(5)\n</code></pre></p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/State/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the State pattern when you have an object that behaves differently depending on its current state, the number of states is enormous, and the state-specific code changes frequently.   The pattern suggests that you extract all state-specific code into a set of distinct classes. As a result, you can add new states or change existing ones independently of each other, reducing the maintenance cost.</p> </li> <li> <p>Use the pattern when you have a class polluted with massive conditionals that alter how the class behaves according to the current values of the class\u2019s fields.   The State pattern lets you extract branches of these conditionals into methods of corresponding state classes. While doing so, you can also clean temporary fields and helper methods involved in state-specific code out of your main class.</p> </li> <li> <p>Use State when you have a lot of duplicate code across similar states and transitions of a condition-based state machine.   The State pattern lets you compose hierarchies of state classes and reduce duplication by extracting common code into abstract base classes.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/State/#how-to-implement","title":"How to Implement","text":"<ol> <li>Decide what class will act as the context. It could be an existing class which already has the state-dependent code; or a new class, if the state-specific code is distributed across multiple classes.</li> <li>Declare the state interface. Although it may mirror all the methods declared in the context, aim only for those that may contain state-specific behavior.</li> <li> <p>For every actual state, create a class that derives from the state interface. Then go over the methods of the context and extract all code related to that state into your newly created class.</p> <p>While moving the code to the state class, you might discover that it depends on private members of the context. There are several workarounds:</p> <ul> <li>Make these fields or methods public.</li> <li>Turn the behavior you\u2019re extracting into a public method in the context and call it from the state class. This way is ugly but quick, and you can always fix it later.</li> <li>Nest the state classes into the context class, but only if your programming language supports nesting classes. 4.  In the context class, add a reference field of the state interface type and a public setter that allows overriding the value of that field. 5.  Go over the method of the context again and replace empty state conditionals with calls to corresponding methods of the state object. 6.  To switch the state of the context, create an instance of one of the state classes and pass it to the context. You can do this within the context itself, or in various states, or in the client. Wherever this is done, the class becomes dependent on the concrete state class that it instantiates.</li> </ul> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/State/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons Single Responsibility Principle. Organize the code related to particular states into separate classes. Applying the pattern can be overkill if a state machine has only a few states or rarely changes. Open Closed Principle. Introduce new states without changing existing state classes or the context. Simplify the code of the context by eliminating bulky state machine conditionals.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/State/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Bridge, State, Strategy Pattern (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn\u2019t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.</li> <li>State can be considered as an extension of Strategy Pattern. Both patterns are based on composition: they change the behavior of the context by delegating some work to helper objects. Strategy Pattern makes these objects completely independent and unaware of each other. However, State doesn\u2019t restrict dependencies between concrete states, letting them alter the state of the context at will.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Strategy/","title":"Strategy","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Strategy/#strategy","title":"Strategy","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Strategy/#intent","title":"Intent","text":"<p>Strategy\u2003is a behavioral design pattern that lets you define a family of algorithms, put each of them into a separate class, and make their objects\u2003interchangeable.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Strategy/#problem","title":"Problem","text":"<p>One day you decided to create a navigation app for casual travelers. The app was centered around a beautiful map which helped users quickly orient themselves in any city.</p> <p>One of the most requested features for the app was automatic route planning. A user should be able to enter an address and see the fastest route to that destination displayed on the map.</p> <p>The first version of the app could only build the routes over roads. People who traveled by car were bursting with joy. But apparently, not everybody likes to drive on their vacation. So with the next update, you added an option to build walking routes. Right after that, you added another option to let people use public transport in their routes.</p> <p>However, that was only the beginning. Later you planned to add route building for cyclists. And even later, another option for building routes through all of a city\u2019s tourist attractions.</p> <p></p> <p>The code of the navigator became\u2003bloated.</p> <p>While from a business perspective the app was a success, the technical part caused you many headaches. Each time you added a new routing algorithm, the main class of the navigator doubled in size. At some point, the beast became too hard to maintain.</p> <p>Any change to one of the algorithms, whether it was a simple bug fix or a slight adjustment of the street score, affected the whole class, increasing the chance of creating an error in already-working code.</p> <p>In addition, teamwork became inefficient. Your teammates, who had been hired right after the successful release, complain that they spend too much time resolving merge conflicts. Implementing a new feature requires you to change the same huge class, conflicting with the code produced by other people.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Strategy/#solution","title":"Solution","text":"<p>The Strategy pattern suggests that you take a class that does something specific in a lot of different ways and extract all of these algorithms into separate classes called\u2003strategies.</p> <p>The original class, called\u2003context, must have a field for storing a reference to one of the strategies. The context delegates the work to a linked strategy object instead of executing it on its own.</p> <p>The context isn\u2019t responsible for selecting an appropriate algorithm for the job. Instead, the client passes the desired strategy to the context. In fact, the context doesn\u2019t know much about strategies. It works with all strategies through the same generic interface, which only exposes a single method for triggering the algorithm encapsulated within the selected strategy.</p> <p>This way the context becomes independent of concrete strategies, so you can add new algorithms or modify existing ones without changing the code of the context or other strategies.</p> <p></p> <p>Route planning\u2003strategies.</p> <p>In our navigation app, each routing algorithm can be extracted to its own class with a single\u2003<code>buildRoute</code>\u2003method. The method accepts an origin and destination and returns a collection of the route\u2019s checkpoints.</p> <p>Even though given the same arguments, each routing class might build a different route, the main navigator class doesn\u2019t really care which algorithm is selected since its primary job is to render a set of checkpoints on the map. The class has a method for switching the active routing strategy, so its clients, such as the buttons in the user interface, can replace the currently selected routing behavior with another one.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Strategy/#real-world-analogy","title":"Real-World Analogy","text":"<p>Various strategies for getting to the\u2003airport.</p> <p>Imagine that you have to get to the airport. You can catch a bus, order a cab, or get on your bicycle. These are your transportation strategies. You can pick one of the strategies depending on factors such as budget or time constraints.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Strategy/#structure","title":"Structure","text":"<ol> <li> <p>The\u2003Context\u2003maintains a reference to one of the concrete strategies and communicates with this object only via the strategy interface.</p> </li> <li> <p>The\u2003Strategy\u2003interface is common to all concrete strategies. It declares a method the context uses to execute a strategy.</p> </li> <li> <p>Concrete Strategies\u2003implement different variations of an algorithm the context uses.</p> </li> <li> <p>The context calls the execution method on the linked strategy object each time it needs to run the algorithm. The context doesn\u2019t know what type of strategy it works with or how the algorithm is executed.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Strategy/#pseudocode","title":"Pseudocode","text":"<p>In this example, the context uses multiple\u2003strategies\u2003to execute various arithmetic operations.</p> <pre><code>// The strategy interface declares operations common to all\n// supported versions of some algorithm. The context uses this\n// interface to call the algorithm defined by the concrete\n// strategies.\ninterface Strategy is\n    method execute(a, b)\n\n// Concrete strategies implement the algorithm while following\n// the base strategy interface. The interface makes them\n// interchangeable in the context.\nclass ConcreteStrategyAdd implements Strategy is\n    method execute(a, b) is\n        return a + b\n\nclass ConcreteStrategySubtract implements Strategy is\n    method execute(a, b) is\n        return a - b\n\nclass ConcreteStrategyMultiply implements Strategy is\n    method execute(a, b) is\n        return a * b\n\n// The context defines the interface of interest to clients.\nclass Context is\n    // The context maintains a reference to one of the strategy\n    // objects. The context doesn't know the concrete class of a\n    // strategy. It should work with all strategies via the\n    // strategy interface.\n    private strategy: Strategy\n\n    // Usually the context accepts a strategy through the\n    // constructor, and also provides a setter so that the\n    // strategy can be switched at runtime.\n    method setStrategy(Strategy strategy) is\n        this.strategy = strategy\n\n    // The context delegates some work to the strategy object\n    // instead of implementing multiple versions of the\n    // algorithm on its own.\n    method executeStrategy(int a, int b) is\n        return strategy.execute(a, b)\n\n// The client code picks a concrete strategy and passes it to\n// the context. The client should be aware of the differences\n// between strategies in order to make the right choice.\nclass ExampleApplication is\n    method main() is\n        Create context object.\n\n        Read first number.\n        Read last number.\n        Read the desired action from user input.\n\n        if (action == addition) then\n            context.setStrategy(new ConcreteStrategyAdd())\n\n        if (action == subtraction) then\n            context.setStrategy(new ConcreteStrategySubtract())\n\n        if (action == multiplication) then\n            context.setStrategy(new ConcreteStrategyMultiply())\n\n        result = context.executeStrategy(First number, Second number)\n\n        Print result.\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Strategy/#applicability","title":"Applicability","text":"<ul> <li>Use the Strategy pattern when you want to use different variants of an algorithm within an object and be able to switch from one algorithm to another during runtime.   The Strategy pattern lets you indirectly alter the object\u2019s behavior at runtime by associating it with different sub-objects which can perform specific sub-tasks in different ways.</li> <li>Use the Strategy when you have a lot of similar classes that only differ in the way they execute some behavior. \u2003  The Strategy pattern lets you extract the varying behavior into a separate class hierarchy and combine the original classes into one, thereby reducing duplicate code.</li> <li>Use the pattern to isolate the business logic of a class from the implementation details of algorithms that may not be as important in the context of that logic.   The Strategy pattern lets you isolate the code, internal data, and dependencies of various algorithms from the rest of the code. Various clients get a simple interface to execute the algorithms and switch them at runtime.</li> <li>Use the pattern when your class has a massive conditional statement that switches between different variants of the same algorithm.   The Strategy pattern lets you do away with such a conditional by extracting all algorithms into separate classes, all of which implement the same interface. The original object delegates execution to one of these objects, instead of implementing all variants of the algorithm.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Strategy/#how-to-implement","title":"How to Implement","text":"<ol> <li>In the context class, identify an algorithm that\u2019s prone to frequent changes. It may also be a massive conditional that selects and executes a variant of the same algorithm at runtime.</li> <li>Declare the strategy interface common to all variants of the algorithm.</li> <li>One by one, extract all algorithms into their own classes. They should all implement the strategy interface.</li> <li>In the context class, add a field for storing a reference to a strategy object. Provide a setter for replacing values of that field. The context should work with the strategy object only via the strategy interface. The context may define an interface which lets the strategy access its data.</li> <li>Clients of the context must associate it with a suitable strategy that matches the way they expect the context to perform its primary job.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Strategy/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can swap algorithms used inside an object at runtime. If you only have a couple of algorithms and they rarely change, there\u2019s no real reason to overcomplicate the program with new classes and interfaces that come along with the pattern. You can isolate the implementation details of an algorithm from the code that uses it. Clients must be aware of the differences between strategies to be able to select a proper one. You can replace inheritance with composition. A lot of modern programming languages have functional type support that lets you implement different versions of an algorithm inside a set of anonymous functions. Then you could use these functions exactly as you\u2019d have used the strategy objects, but without bloating your code with extra classes and interfaces. Open Closed Principle. You can introduce new strategies without having to change the context.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Strategy/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn\u2019t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.</li> <li>Command and Strategy may look similar because you can use both to parameterize an object with some action. However, they have very different intents.<ul> <li>You can use Command to convert any operation into an object. The operation\u2019s parameters become fields of that object. The conversion lets you defer execution of the operation, queue it, store the history of commands, send commands to remote services, etc.</li> <li>On the other hand, Strategy usually describes different ways of doing the same thing, letting you swap these algorithms within a single context class.</li> </ul> </li> <li>Decorator lets you change the skin of an object, while Strategy lets you change the guts.</li> <li>Template Method is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. Strategy is based on composition: you can alter parts of the object\u2019s behavior by supplying it with different strategies that correspond to that behavior. Template Method works at the class level, so it\u2019s static. Strategy works on the object level, letting you switch behaviors at runtime.</li> <li>State can be considered as an extension of Strategy. Both patterns are based on composition: they change the behavior of the context by delegating some work to helper objects. Strategy makes these objects completely independent and unaware of each other. However, State doesn\u2019t restrict dependencies between concrete states, letting them alter the state of the context at will.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Template%20Method/","title":"Template Method","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Template%20Method/#template-method","title":"Template Method","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Template%20Method/#intent","title":"Intent","text":"<p>Template Method\u2003is a behavioral design pattern that defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its\u2003structure.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Template%20Method/#problem","title":"Problem","text":"<p>Imagine that you\u2019re creating a data mining application that analyzes corporate documents. Users feed the app documents in various formats (PDF, DOC, CSV), and it tries to extract meaningful data from these docs in a uniform format.</p> <p>The first version of the app could work only with DOC files. In the following version, it was able to support CSV files. A month later, you \u201ctaught\u201d it to extract data from PDF files.</p> <p></p> <p>Data mining classes contained a lot of duplicate\u2003code.</p> <p>At some point, you noticed that all three classes have a lot of similar code. While the code for dealing with various data formats was entirely different in all classes, the code for data processing and analysis is almost identical. Wouldn\u2019t it be great to get rid of the code duplication, leaving the algorithm structure intact?</p> <p>There was another problem related to client code that used these classes. It had lots of conditionals that picked a proper course of action depending on the class of the processing object. If all three processing classes had a common interface or a base class, you\u2019d be able to eliminate the conditionals in client code and use polymorphism when calling methods on a processing object.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Template%20Method/#solution","title":"Solution","text":"<p>The Template Method pattern suggests that you break down an algorithm into a series of steps, turn these steps into methods, and put a series of calls to these methods inside a single\u2003template method.\u2003The steps may either be\u2003<code>abstract</code>, or have some default implementation. To use the algorithm, the client is supposed to provide its own subclass, implement all abstract steps, and override some of the optional ones if needed (but not the template method itself).</p> <p>Let\u2019s see how this will play out in our data mining app. We can create a base class for all three parsing algorithms. This class defines a template method consisting of a series of calls to various document-processing steps.</p> <p></p> <p>Template method breaks the algorithm into steps, allowing subclasses to override these steps but not the actual\u2003method.</p> <p>At first, we can declare all steps\u2003<code>abstract</code>, forcing the subclasses to provide their own implementations for these methods. In our case, subclasses already have all necessary implementations, so the only thing we might need to do is adjust signatures of the methods to match the methods of the superclass.</p> <p>Now, let\u2019s see what we can do to get rid of the duplicate code. It looks like the code for opening/closing files and extracting/parsing data is different for various data formats, so there\u2019s no point in touching those methods. However, implementation of other steps, such as analyzing the raw data and composing reports, is very similar, so it can be pulled up into the base class, where subclasses can share that code.</p> <p>As you can see, we\u2019ve got two types of steps:</p> <ul> <li>abstract steps\u2003must be implemented by every subclass</li> <li>optional steps\u2003already have some default implementation, but still can be overridden if needed</li> </ul> <p>There\u2019s another type of step, called\u2003hooks. A hook is an optional step with an empty body. A template method would work even if a hook isn\u2019t overridden. Usually, hooks are placed before and after crucial steps of algorithms, providing subclasses with additional extension points for an algorithm.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Template%20Method/#real-world-analogy","title":"Real-World Analogy","text":"<p>A typical architectural plan can be slightly altered to better fit the client\u2019s\u2003needs.</p> <p>The template method approach can be used in mass housing construction. The architectural plan for building a standard house may contain several extension points that would let a potential owner adjust some details of the resulting house.</p> <p>Each building step, such as laying the foundation, framing, building walls, installing plumbing and wiring for water and electricity,\u2003etc., can be slightly changed to make the resulting house a little bit different from others.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Template%20Method/#structure","title":"Structure","text":"<ol> <li> <p>The\u2003Abstract Class\u2003declares methods that act as steps of an algorithm, as well as the actual template method which calls these methods in a specific order. The steps may either be declared\u2003<code>abstract</code>\u2003or have some default implementation.</p> </li> <li> <p>Concrete Classes\u2003can override all of the steps, but not the template method itself.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Template%20Method/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Template Method\u2003pattern provides a \u201cskeleton\u201d for various branches of artificial intelligence in a simple strategy video game.</p> <p></p> <p>AI classes of a simple video\u2003game.</p> <p>All races in the game have almost the same types of units and buildings. Therefore you can reuse the same AI structure for various races, while being able to override some of the details. With this approach, you can override the orcs\u2019 AI to make it more aggressive, make humans more defense-oriented, and make monsters unable to build anything. Adding a new race to the game would require creating a new AI subclass and overriding the default methods declared in the base AI class.</p> <pre><code>// The abstract class defines a template method that contains a\n// skeleton of some algorithm composed of calls, usually to\n// abstract primitive operations. Concrete subclasses implement\n// these operations, but leave the template method itself\n// intact.\nclass GameAI is\n    // The template method defines the skeleton of an algorithm.\n    method turn() is\n        collectResources()\n        buildStructures()\n        buildUnits()\n        attack()\n\n    // Some of the steps may be implemented right in a base\n    // class.\n    method collectResources() is\n        foreach (s in this.builtStructures) do\n            s.collect()\n\n    // And some of them may be defined as abstract.\n    abstract method buildStructures()\n    abstract method buildUnits()\n\n    // A class can have several template methods.\n    method attack() is\n        enemy = closestEnemy()\n        if (enemy == null)\n            sendScouts(map.center)\n        else\n            sendWarriors(enemy.position)\n\n    abstract method sendScouts(position)\n    abstract method sendWarriors(position)\n\n// Concrete classes have to implement all abstract operations of\n// the base class but they must not override the template method\n// itself.\nclass OrcsAI extends GameAI is\n    method buildStructures() is\n        if (there are some resources) then\n            // Build farms, then barracks, then stronghold.\n\n    method buildUnits() is\n        if (there are plenty of resources) then\n            if (there are no scouts)\n                // Build peon, add it to scouts group.\n            else\n                // Build grunt, add it to warriors group.\n\n    // ...\n\n    method sendScouts(position) is\n        if (scouts.length &gt; 0) then\n            // Send scouts to position.\n\n    method sendWarriors(position) is\n        if (warriors.length &gt; 5) then\n            // Send warriors to position.\n\n// Subclasses can also override some operations with a default\n// implementation.\nclass MonstersAI extends GameAI is\n    method collectResources() is\n        // Monsters don't collect resources.\n\n    method buildStructures() is\n        // Monsters don't build structures.\n\n    method buildUnits() is\n        // Monsters don't build units.\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Template%20Method/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Template Method pattern when you want to let clients extend only particular steps of an algorithm, but not the whole algorithm or its structure.     The Template Method lets you turn a monolithic algorithm into a series of individual steps which can be easily extended by subclasses while keeping intact the structure defined in a superclass.</p> </li> <li> <p>Use the pattern when you have several classes that contain almost identical algorithms with some minor differences. As a result, you might need to modify all classes when the algorithm changes.     When you turn such an algorithm into a template method, you can also pull up the steps with similar implementations into a superclass, eliminating code duplication. Code that varies between subclasses can remain in subclasses.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Template%20Method/#how-to-implement","title":"How to Implement","text":"<ol> <li> <p>Analyze the target algorithm to see whether you can break it into steps. Consider which steps are common to all subclasses and which ones will always be unique.</p> </li> <li> <p>Create the abstract base class and declare the template method and a set of abstract methods representing the algorithm\u2019s steps. Outline the algorithm\u2019s structure in the template method by executing corresponding steps. Consider making the template method\u2003<code>final</code>\u2003to prevent subclasses from overriding it.</p> </li> <li> <p>It\u2019s okay if all the steps end up being abstract. However, some steps might benefit from having a default implementation. Subclasses don\u2019t have to implement those methods.</p> </li> <li> <p>Think of adding hooks between the crucial steps of the algorithm.</p> </li> <li> <p>For each variation of the algorithm, create a new concrete subclass. It\u2003must\u2003implement all of the abstract steps, but\u2003may\u2003also override some of the optional ones.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Template%20Method/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can let clients override only certain parts of a large algorithm, making them less affected by changes that happen to other parts of the algorithm. Some clients may be limited by the provided skeleton of an algorithm. You can pull the duplicate code into a superclass. You might violate the Liskov Substitution Principle by suppressing a default step implementation via a subclass. Template methods tend to be harder to maintain the more steps they have.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Template%20Method/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.</li> <li>Template Method is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. Strategy is based on composition: you can alter parts of the object\u2019s behavior by supplying it with different strategies that correspond to that behavior. Template Method works at the class level, so it\u2019s static. Strategy works on the object level, letting you switch behaviors at runtime.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Visitor/","title":"Visitor","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Visitor/#visitor","title":"Visitor","text":"","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Visitor/#intent","title":"Intent","text":"<p>Visitor\u2003is a behavioral design pattern that lets you separate algorithms from the objects on which they\u2003operate.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Visitor/#problem","title":"Problem","text":"<p>Imagine that your team develops an app which works with geographic information structured as one colossal graph. Each node of the graph may represent a complex entity such as a city, but also more granular things like industries, sightseeing areas,\u2003etc. The nodes are connected with others if there\u2019s a road between the real objects that they represent. Under the hood, each node type is represented by its own class, while each specific node is an object.</p> <p></p> <p>Exporting the graph into\u2003XML.</p> <p>At some point, you got a task to implement exporting the graph into XML format. At first, the job seemed pretty straightforward. You planned to add an export method to each node class and then leverage recursion to go over each node of the graph, executing the export method. The solution was simple and elegant: thanks to polymorphism, you weren\u2019t coupling the code which called the export method to concrete classes of nodes.</p> <p>Unfortunately, the system architect refused to allow you to alter existing node classes. He said that the code was already in production and he didn\u2019t want to risk breaking it because of a potential bug in your changes.</p> <p></p> <p>The XML export method had to be added into all node classes, which bore the risk of breaking the whole application if any bugs slipped through along with the\u2003change.</p> <p>Besides, he questioned whether it makes sense to have the XML export code within the node classes. The primary job of these classes was to work with geodata. The XML export behavior would look alien there.</p> <p>There was another reason for the refusal. It was highly likely that after this feature was implemented, someone from the marketing department would ask you to provide the ability to export into a different format, or request some other weird stuff. This would force you to change those precious and fragile classes again.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Visitor/#solution","title":"Solution","text":"<p>The Visitor pattern suggests that you place the new behavior into a separate class called\u2003visitor, instead of trying to integrate it into existing classes. The original object that had to perform the behavior is now passed to one of the visitor\u2019s methods as an argument, providing the method access to all necessary data contained within the object.</p> <p>Now, what if that behavior can be executed over objects of different classes? For example, in our case with XML export, the actual implementation will probably be a little bit different across various node classes. Thus, the visitor class may define not one, but a set of methods, each of which could take arguments of different types, like this:</p> <pre><code>class ExportVisitor implements Visitor is\n    method doForCity(City c) { ... }\n    method doForIndustry(Industry f) { ... }\n    method doForSightSeeing(SightSeeing ss) { ... }\n    // ...\n</code></pre> <p>But how exactly would we call these methods, especially when dealing with the whole graph? These methods have different signatures, so we can\u2019t use polymorphism. To pick a proper visitor method that\u2019s able to process a given object, we\u2019d need to check its class. Doesn\u2019t this sound like a nightmare?</p> <pre><code>foreach (Node node in graph)\n    if (node instanceof City)\n        exportVisitor.doForCity((City) node)\n    if (node instanceof Industry)\n        exportVisitor.doForIndustry((Industry) node)\n    // ...\n}\n</code></pre> <p>You might ask, why don\u2019t we use method overloading? That\u2019s when you give all methods the same name, even if they support different sets of parameters. Unfortunately, even assuming that our programming language supports it at all (as Java and C# do), it won\u2019t help us. Since the exact class of a node object is unknown in advance, the overloading mechanism won\u2019t be able to determine the correct method to execute. It\u2019ll default to the method that takes an object of the base\u2003<code>Node</code>\u2003class.</p> <p>However, the Visitor pattern addresses this problem. It uses a technique called\u2003Double Dispatch, which helps to execute the proper method on an object without cumbersome conditionals. Instead of letting the client select a proper version of the method to call, how about we delegate this choice to objects we\u2019re passing to the visitor as an argument? Since the objects know their own classes, they\u2019ll be able to pick a proper method on the visitor less awkwardly. They \u201caccept\u201d a visitor and tell it what visiting method should be executed.</p> <pre><code>// Client code\nforeach (Node node in graph)\n    node.accept(exportVisitor)\n\n// City\nclass City is\n    method accept(Visitor v) is\n        v.doForCity(this)\n    // ...\n\n// Industry\nclass Industry is\n    method accept(Visitor v) is\n        v.doForIndustry(this)\n    // ...\n</code></pre> <p>I confess. We had to change the node classes after all. But at least the change is trivial and it lets us add further behaviors without altering the code once again.</p> <p>Now, if we extract a common interface for all visitors, all existing nodes can work with any visitor you introduce into the app. If you find yourself introducing a new behavior related to nodes, all you have to do is implement a new visitor class.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Visitor/#real-world-analogy","title":"Real-World Analogy","text":"<p>A good insurance agent is always ready to offer different policies to various types of\u2003organizations.</p> <p>Imagine a seasoned insurance agent who\u2019s eager to get new customers. He can visit every building in a neighborhood, trying to sell insurance to everyone he meets. Depending on the type of organization that occupies the building, he can offer specialized insurance policies:</p> <ul> <li>If it\u2019s a residential building, he sells medical insurance.</li> <li>If it\u2019s a bank, he sells theft insurance.</li> <li>If it\u2019s a coffee shop, he sells fire and flood insurance.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Visitor/#structure","title":"Structure","text":"<ol> <li> <p>The\u2003Visitor\u2003interface declares a set of visiting methods that can take concrete elements of an object structure as arguments. These methods may have the same names if the program is written in a language that supports overloading, but the type of their parameters must be different.</p> </li> <li> <p>Each\u2003Concrete Visitor\u2003implements several versions of the same behaviors, tailored for different concrete element classes.</p> </li> <li> <p>The\u2003Element\u2003interface declares a method for \u201caccepting\u201d visitors. This method should have one parameter declared with the type of the visitor interface.</p> </li> <li> <p>Each\u2003Concrete Element\u2003must implement the acceptance method. The purpose of this method is to redirect the call to the proper visitor\u2019s method corresponding to the current element class. Be aware that even if a base element class implements this method, all subclasses must still override this method in their own classes and call the appropriate method on the visitor object.</p> </li> <li> <p>The\u2003Client\u2003usually represents a collection or some other complex object (for example, a\u2003Composite\u2003tree). Usually, clients aren\u2019t aware of all the concrete element classes because they work with objects from that collection via some abstract interface.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Visitor/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Visitor\u2003pattern adds XML export support to the class hierarchy of geometric shapes.</p> <p></p> <p>Exporting various types of objects into XML format via a visitor\u2003object.</p> <pre><code>// The element interface declares an `accept` method that takes\n// the base visitor interface as an argument.\ninterface Shape is\n    method move(x, y)\n    method draw()\n    method accept(v: Visitor)\n\n// Each concrete element class must implement the `accept`\n// method in such a way that it calls the visitor's method that\n// corresponds to the element's class.\nclass Dot implements Shape is\n    // ...\n\n    // Note that we're calling `visitDot`, which matches the\n    // current class name. This way we let the visitor know the\n    // class of the element it works with.\n    method accept(v: Visitor) is\n        v.visitDot(this)\n\nclass Circle implements Shape is\n    // ...\n    method accept(v: Visitor) is\n        v.visitCircle(this)\n\nclass Rectangle implements Shape is\n    // ...\n    method accept(v: Visitor) is\n        v.visitRectangle(this)\n\nclass CompoundShape implements Shape is\n    // ...\n    method accept(v: Visitor) is\n        v.visitCompoundShape(this)\n\n// The Visitor interface declares a set of visiting methods that\n// correspond to element classes. The signature of a visiting\n// method lets the visitor identify the exact class of the\n// element that it's dealing with.\ninterface Visitor is\n    method visitDot(d: Dot)\n    method visitCircle(c: Circle)\n    method visitRectangle(r: Rectangle)\n    method visitCompoundShape(cs: CompoundShape)\n\n// Concrete visitors implement several versions of the same\n// algorithm, which can work with all concrete element classes.\n//\n// You can experience the biggest benefit of the Visitor pattern\n// when using it with a complex object structure such as a\n// Composite tree. In this case, it might be helpful to store\n// some intermediate state of the algorithm while executing the\n// visitor's methods over various objects of the structure.\nclass XMLExportVisitor implements Visitor is\n    method visitDot(d: Dot) is\n        // Export the dot's ID and center coordinates.\n\n    method visitCircle(c: Circle) is\n        // Export the circle's ID, center coordinates and\n        // radius.\n\n    method visitRectangle(r: Rectangle) is\n        // Export the rectangle's ID, left-top coordinates,\n        // width and height.\n\n    method visitCompoundShape(cs: CompoundShape) is\n        // Export the shape's ID as well as the list of its\n        // children's IDs.\n\n// The client code can run visitor operations over any set of\n// elements without figuring out their concrete classes. The\n// accept operation directs a call to the appropriate operation\n// in the visitor object.\nclass Application is\n    field allShapes: array of Shapes\n\n    method export() is\n        exportVisitor = new XMLExportVisitor()\n\n        foreach (shape in allShapes) do\n            shape.accept(exportVisitor)\n</code></pre> <p>If you wonder why we need the\u2003<code>accept</code>\u2003method in this example, my article\u2003Visitor and Double Dispatch\u2003addresses this question in detail.</p>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Visitor/#applicability","title":"Applicability","text":"<ul> <li>Use the Visitor when you need to perform an operation on all elements of a complex object structure (for example, an object tree).     The Visitor pattern lets you execute an operation over a set of objects with different classes by having a visitor object implement several variants of the same operation, which correspond to all target classes.</li> <li>Use the Visitor to clean up the business logic of auxiliary behaviors.     The pattern lets you make the primary classes of your app more focused on their main jobs by extracting all other behaviors into a set of visitor classes.</li> <li>Use the pattern when a behavior makes sense only in some classes of a class hierarchy, but not in others.     You can extract this behavior into a separate visitor class and implement only those visiting methods that accept objects of relevant classes, leaving the rest empty.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Visitor/#how-to-implement","title":"How to Implement","text":"<ol> <li> <p>Declare the visitor interface with a set of \u201cvisiting\u201d methods, one per each concrete element class that exists in the program.</p> </li> <li> <p>Declare the element interface. If you\u2019re working with an existing element class hierarchy, add the abstract \u201cacceptance\u201d method to the base class of the hierarchy. This method should accept a visitor object as an argument.</p> </li> <li> <p>Implement the acceptance methods in all concrete element classes. These methods must simply redirect the call to a visiting method on the incoming visitor object which matches the class of the current element.</p> </li> <li> <p>The element classes should only work with visitors via the visitor interface. Visitors, however, must be aware of all concrete element classes, referenced as parameter types of the visiting methods.</p> </li> <li> <p>For each behavior that can\u2019t be implemented inside the element hierarchy, create a new concrete visitor class and implement all of the visiting methods.</p> <p>You might encounter a situation where the visitor will need access to some private members of the element class. In this case, you can either make these fields or methods public, violating the element\u2019s encapsulation, or nest the visitor class in the element class. The latter is only possible if you\u2019re lucky to work with a programming language that supports nested classes.</p> </li> <li> <p>The client must create visitor objects and pass them into elements via \u201cacceptance\u201d methods.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Visitor/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons Open Closed Principle. You can introduce a new behavior that can work with objects of different classes without changing these classes. \u2003You need to update all visitors each time a class gets added to or removed from the element hierarchy. Single Responsibility Principle. You can move multiple versions of the same behavior into the same class. Visitors might lack the necessary access to the private fields and methods of the elements that they\u2019re supposed to work with. A visitor object can accumulate some useful information while working with various objects. This might be handy when you want to traverse some complex object structure, such as an object tree, and apply the visitor to each object of this structure.","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Clean%20Code/Design%20Patterns/Visitor/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>You can treat Visitor as a powerful version of the Command pattern. Its objects can execute operations over various objects of different classes.</li> <li>You can use Visitor to execute an operation over an entire object tree tree.</li> <li>You can use Visitor along with Iterator to traverse a complex data structure and execute some operation over its elements, even if they all have different classes.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"Software%20Engineering/Design%20Patterns/Model-View-Controller%20%28MVC%29/","title":"Model View Controller (MVC)","text":""},{"location":"Software%20Engineering/Design%20Patterns/Model-View-Controller%20%28MVC%29/#model","title":"Model","text":"<p>Manages the Data, independant from the user interface</p>"},{"location":"Software%20Engineering/Design%20Patterns/Model-View-Controller%20%28MVC%29/#view","title":"View","text":"<p>The visual representation of a model. Does not handle input</p>"},{"location":"Software%20Engineering/Design%20Patterns/Model-View-Controller%20%28MVC%29/#controller","title":"Controller","text":"<p>Accepts input and converts it to commands for the model or view.</p>"},{"location":"Software%20Engineering/Design%20Patterns/Model-View-ViewModel%20%28MVVM%29/","title":"Model View ViewModel (MVVM)","text":""},{"location":"Software%20Engineering/Design%20Patterns/Model-View-ViewModel%20%28MVVM%29/#model","title":"Model","text":"<p>The domain model of the application (oop)</p>"},{"location":"Software%20Engineering/Design%20Patterns/Model-View-ViewModel%20%28MVVM%29/#view","title":"View","text":"<p>The visual representation of the model.</p>"},{"location":"Software%20Engineering/Design%20Patterns/Model-View-ViewModel%20%28MVVM%29/#viewmodel","title":"ViewModel","text":"<p>Abstraction of the view with public properties and commands. The View direclty has bindings on the properties of the view model.</p>"},{"location":"Software%20Engineering/EAA/Unit%20of%20Work/","title":"Unit of Work","text":""},{"location":"Software%20Engineering/EAA/Unit%20of%20Work/#unit-of-work","title":"Unit of Work","text":"<p>Maintains a list of objects affected by a business transaction and coordinates the writing out of changes and the resolution of concurrency problems.</p> <p>For a full description see P of EAA page 184</p> <p></p> <p>When you\u2019re pulling data in and out of a database, it\u2019s important to keep track of what you\u2019ve changed; otherwise, that data won\u2019t be written back into the database. Similarly you have to insert new objects you create and remove any objects you delete.</p> <p>You can change the database with each change to your object model, but this can lead to lots of very small database calls, which ends up being very slow. Furthermore it requires you to have a transaction open for the whole interaction, which is impractical if you have a business transaction that spans multiple requests. The situation is even worse if you need to keep track of the objects you\u2019ve read so you can avoid inconsistent reads.</p> <p>A Unit of Work keeps track of everything you do during a business transaction that can affect the database. When you\u2019re done, it figures out everything that needs to be done to alter the database as a result of your work.</p>"},{"location":"Software%20Engineering/EAA/Unit%20of%20Work/#implementation-and-integration-in-net","title":"Implementation and Integration in .NET","text":"<p>During our implementation in a project we did several iterations on a unit of work using dependency injection. The following is the concept we finalised on:</p> <pre><code>public&amp;emsp;class&amp;emsp;UnitOfWork&amp;emsp;:&amp;emsp;IUnitOfWork  \n{  \n&amp;emsp;&amp;emsp;private&amp;emsp;readonly&amp;emsp;DataStoreContext&amp;emsp;dataStoreContext;\n&amp;emsp;&amp;emsp;private&amp;emsp;readonly&amp;emsp;CreateRepository&amp;emsp;createRepository;\n&amp;emsp;&amp;emsp;\n&amp;emsp;&amp;emsp;public&amp;emsp;UnitOfWork(\n\t&amp;emsp;&amp;emsp;DataStoreContext&amp;emsp;dataStoreContext,\n&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;CreateRepository&amp;emsp;createRepository)\n  {\n&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;this.dataStoreContext&amp;emsp;=&amp;emsp;dataStoreContext;\n&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;this.createRepository&amp;emsp;=&amp;emsp;createRepository;&amp;emsp;&amp;emsp;\n  }  \n&amp;emsp;&amp;emsp;\n&amp;emsp;&amp;emsp;public&amp;emsp;delegate&amp;emsp;IRepository&amp;emsp;CreateRepository(DataStoreContext&amp;emsp;context);&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;\n&amp;emsp;&amp;emsp;\n&amp;emsp;&amp;emsp;public&amp;emsp;IRepository&amp;emsp;Repository \n\t&amp;emsp;&amp;emsp;=&gt;&amp;emsp;this.createRepository(this.dataStoreContext);  \n&amp;emsp;&amp;emsp;public&amp;emsp;async&amp;emsp;Task&amp;emsp;Commit()&amp;emsp;=&gt;&amp;emsp;await&amp;emsp;this.dataStoreContext.SaveChangesAsync();}\n</code></pre> <p>And the registration in the DI.</p> <pre><code>services.AddTransient&lt;UnitOfWork.CreateRepository&gt;(  \n&amp;emsp;&amp;emsp;&amp;emsp;sp&amp;emsp;=&gt;&amp;emsp;context&amp;emsp;=&gt;&amp;emsp;new&amp;emsp;Repository(context,&amp;emsp;sp.GetRequiredService&lt;IObjectSerializer&gt;()));\n</code></pre> <p>This enables us to created the repositories in DI where all the dependencies are resolved, but they all can share the same context so the unit of work can do all actions in one transaction.</p> <p>We also create a factory for the Unit of Work, which creates the context.</p>"},{"location":"Software%20Engineering/Technology/Docker/","title":"Docker","text":""},{"location":"Software%20Engineering/Technology/Docker/#connecting-from-container-to-host","title":"Connecting from Container to host","text":"<p>One problem I faced was to connect to the host from a container. (It was because of a live logging application)</p> <p>I achieved the desired result by doing adding the extra_hosts section in my compose file: <pre><code>services:\n\texample:\n\t...\n\t\textra_hosts:\n\t\t  - logserver.local: host-gateway\n</code></pre></p> <p>With this I can call <code>logserver.local</code> inside of my container and it gets routed to the localhost.</p> <p>If you want to configure it so that host-gateway points to a specific IP address you can configure it in the <code>/etc/docker/daemon.json</code> <pre><code>{ \"host-gateway-ip\": \"&lt;desiredIP&gt;\" }\n</code></pre></p> <p>This can be especially useful if you install docker without docker-desktop on WSL. Then you can route your host-gateway to the virtual network-interface connecting to windows.</p>"},{"location":"Software%20Engineering/Technology/Docker/#synchronizing-timezone-of-host-with-container","title":"Synchronizing Timezone of Host with Container","text":"<p>Docker containers are by default in the timezone ETC/UTC, if you need to have it synchronized to the local machine then you will find multiple options on the internet:</p>"},{"location":"Software%20Engineering/Technology/Docker/#1-set-the-tz-variable","title":"1. Set the TZ variable","text":"<p>In a <code>docker-compose.yml</code>: <pre><code>services:\n# ...\n# Container Definition in docker.compose.yaml\n  environments:\n    - TZ=Europe/Berlin\n</code></pre></p> <p>As single command: <pre><code>docker run -rm -e TZ=Europe/Berlin debian:latest date\n</code></pre></p> Pro Contra Works for most cases Does not work if timezone needs to be updated without recreating the container Easy to set up"},{"location":"Software%20Engineering/Technology/Docker/#2-bind-the-system-time-files-to-the-container","title":"2. Bind the system time files to the container","text":"<p>In a <code>docker-compose.yml</code> <pre><code>services:\n# ...\n# Container Definition in docker.compose.yaml\n  volumes:\n    - /etc/timezone:/etc/timezone:ro\n    - /etc/localtime:/etc/localtime:ro\n</code></pre></p> Pro Contra Timezone is set correctly localtime does not work correctly Time is synchronized to the host continously ### 3. Combination This solution combines the two concepts and sets the TZ Variable on every start of the container. For that we need to add a script to the Dockerfile. <pre><code>ENTRYPOINT [\"/bin/bash\", \"startupScript.sh\"]\n</code></pre> <p>In the script we set the TZ and then startup the application: <pre><code>#!/bin/bash  \nif timezone=$(cat /etc/timezone 2&gt;/dev/null); then  \n    export TZ=\"$timezone\"  \n    echo \"Using Timezone $timezone\"  \nfi  \n./Application # this is the command to run your application\n</code></pre></p> <p>If we do it like this, then every time we restart the container the timezone is synchronized with the host.</p>"},{"location":"Software%20Engineering/Technology/GitVersion/","title":"GitVersion","text":"<p>Official Website</p> <p>https://gitversion.net/</p>","tags":["git","ci","versioning"]},{"location":"Software%20Engineering/Technology/GitVersion/#setup","title":"Setup","text":"<p>Install gitversion (from https://gitversion.net/docs/usage/cli/installation) <pre><code>dotnet tool install --global GitVersion.Tool --version 5.*\n</code></pre></p> <p>Initialize via wizard: <pre><code>dotnet-gitversion init\n</code></pre></p> <p>Configure branch specific information using template from https://gitversion.net/docs/reference/configuration#:~:text=a%20build%20server.-,Branch%20configuration,-Then%20we%20have</p>","tags":["git","ci","versioning"]},{"location":"Software%20Engineering/Technology/GitVersion/#example-setup","title":"Example Setup","text":"<pre><code>mode: ContinuousDelivery  \nignore:  \n  sha: []  \nmerge-message-formats: {}  \nbranches:  \n  main:  \n    regex: ^master$|^main$  \n    mode: ContinuousDelivery  \n    tag: ''  \n    increment: Patch  \n    prevent-increment-of-merged-branch-version: true  \n    track-merge-target: false  \n    source-branches: [ 'develop', 'release' ]  \n    tracks-release-branches: false  \n    is-release-branch: false  \n    is-mainline: true  \n    pre-release-weight: 55000  \n  develop:  \n    regex: ^dev(elop)?(ment)?$  \n    mode: ContinuousDeployment  \n    tag: dev  \n    increment: Minor  \n    prevent-increment-of-merged-branch-version: false  \n    track-merge-target: true  \n    source-branches: []  \n    tracks-release-branches: true  \n    is-release-branch: false  \n    is-mainline: false  \n    pre-release-weight: 0  \n  release:  \n    regex: ^releases?[/-]  \n    mode: ContinuousDelivery  \n    tag: beta  \n    increment: None  \n    prevent-increment-of-merged-branch-version: true  \n    track-merge-target: false  \n    source-branches: [ 'develop', 'main', 'support', 'release' ]  \n    tracks-release-branches: false  \n    is-release-branch: true  \n    is-mainline: false  \n    pre-release-weight: 30000  \n  feature:  \n    regex: ^features?[/-]  \n    mode: ContinuousDelivery  \n    tag: useBranchName  \n    increment: Inherit  \n    prevent-increment-of-merged-branch-version: false  \n    track-merge-target: false  \n    source-branches: [ 'develop', 'main', 'release', 'feature', 'support', 'hotfix' ]  \n    tracks-release-branches: false  \n    is-release-branch: false  \n    is-mainline: false  \n    pre-release-weight: 30000  \n  pull-request:  \n    regex: ^(pull|pull\\-requests|pr)[/-]  \n    mode: ContinuousDelivery  \n    tag: PullRequest  \n    increment: Inherit  \n    prevent-increment-of-merged-branch-version: false  \n    tag-number-pattern: '[/-](?&lt;number&gt;\\d+)[-/]'  \n    track-merge-target: false  \n    source-branches: [ 'develop', 'main', 'release', 'feature', 'support', 'hotfix' ]  \n    tracks-release-branches: false  \n    is-release-branch: false  \n    is-mainline: false  \n    pre-release-weight: 30000  \n  hotfix:  \n    regex: ^hotfix(es)?[/-]  \n    mode: ContinuousDelivery  \n    tag: beta  \n    increment: Patch  \n    prevent-increment-of-merged-branch-version: false  \n    track-merge-target: false  \n    source-branches: [ 'develop', 'main', 'support' ]  \n    tracks-release-branches: false  \n    is-release-branch: false  \n    is-mainline: false  \n    pre-release-weight: 30000  \n  support:  \n    regex: ^support[/-]  \n    mode: ContinuousDelivery  \n    tag: ''  \n    increment: Patch  \n    prevent-increment-of-merged-branch-version: true  \n    track-merge-target: false  \n    source-branches: [ 'main' ]  \n    tracks-release-branches: false  \n    is-release-branch: false  \n    is-mainline: true  \n    pre-release-weight: 55000\n</code></pre>","tags":["git","ci","versioning"]},{"location":"Software%20Engineering/Technology/GitVersion/#usage","title":"Usage","text":"","tags":["git","ci","versioning"]},{"location":"Software%20Engineering/Technology/GitVersion/#show-all-possible-variables","title":"Show all possible Variables","text":"<p><pre><code>dotnet-gitversion\n</code></pre> Example output: <pre><code>{\n  \"Major\": 0,\n  \"Minor\": 8,\n  \"Patch\": 0,\n  \"PreReleaseTag\": \"\",\n  \"PreReleaseTagWithDash\": \"\",\n  \"PreReleaseLabel\": \"\",\n  \"PreReleaseLabelWithDash\": \"\",\n  \"PreReleaseNumber\": null,\n  \"WeightedPreReleaseNumber\": 60000,\n  \"BuildMetaData\": null,\n  \"BuildMetaDataPadded\": \"\",\n  \"FullBuildMetaData\": \"Branch.develop.Sha.a5cf5c881143995e3549a786eb89ab388a1f0fab\",\n  \"MajorMinorPatch\": \"0.8.0\",\n  \"SemVer\": \"0.8.0\",\n  \"LegacySemVer\": \"0.8.0\",\n  \"LegacySemVerPadded\": \"0.8.0\",\n  \"AssemblySemVer\": \"0.8.0.0\",\n  \"AssemblySemFileVer\": \"0.8.0.0\",\n  \"FullSemVer\": \"0.8.0\",\n  \"InformationalVersion\": \"0.8.0+Branch.develop.Sha.a5cf5c881143995e3549a786eb89ab388a1f0fab\",\n  \"BranchName\": \"develop\",\n  \"EscapedBranchName\": \"develop\",\n  \"Sha\": \"a5cf5c881143995e3549a786eb89ab388a1f0fab\",\n  \"ShortSha\": \"a5cf5c8\",\n  \"NuGetVersionV2\": \"0.8.0\",\n  \"NuGetVersion\": \"0.8.0\",\n  \"NuGetPreReleaseTagV2\": \"\",\n  \"NuGetPreReleaseTag\": \"\",\n  \"VersionSourceSha\": \"a5cf5c881143995e3549a786eb89ab388a1f0fab\",\n  \"CommitsSinceVersionSource\": 0,\n  \"CommitsSinceVersionSourcePadded\": \"0000\",\n  \"UncommittedChanges\": 1,\n  \"CommitDate\": \"2024-05-21\"\n}\n</code></pre></p>","tags":["git","ci","versioning"]},{"location":"Software%20Engineering/Technology/GitVersion/#show-single-variable","title":"Show single variable","text":"<pre><code>dotnet-gitversion /showvariable FullSemVer\n</code></pre> <p>Example output <pre><code>0.9.0-zweitesFeature.1+0\n</code></pre></p>","tags":["git","ci","versioning"]},{"location":"Software%20Engineering/Technology/Message%20Queues/","title":"Message Queues","text":"<p>Source:</p> <p>https://www.baeldung.com/cs/message-queues</p>"},{"location":"Software%20Engineering/Technology/Message%20Queues/#1-introduction","title":"1. Introduction","text":"<p>A response to a request in a real-world application is not always instantaneous. We often assume that our applications would process everything instantaneously, or in a REST API, we often believe that we discard all unsuccessful requests, but the reality is slightly different. We can often process these unsuccessful requests later, or we can also send responses asynchronously.</p> <p>In this tutorial, we\u2019ll take a look at how we can leverage message queues to achieve this.</p>"},{"location":"Software%20Engineering/Technology/Message%20Queues/#2-asynchronous-and-synchronous-communication","title":"2. Asynchronous and Synchronous Communication","text":"<p>Asynchronous communication is a mode of communication where the sender and receiver are not required to be active simultaneously. It is often referred to as the fire-and-forget model of communication. Emails are a good example of asynchronous communication. A person can choose to read all their emails instantaneously or accumulate them to be read later at once. Similarly, a sender can send an email and move on to other tasks, without expecting an instantaneous reply.</p> <p>A telephone call can be an example of synchronous communication, where the sender and receiver interact in real-time, requiring both parties to be actively present and engaged simultaneously.</p> <p>Here is a diagram to illustrate the difference between asynchronous and synchronous communication:</p> <p></p>"},{"location":"Software%20Engineering/Technology/Message%20Queues/#3-definition-of-message-queues","title":"3. Definition of Message Queues","text":"<p>We\u2019ll start by understanding the meaning of messages. In the context of a real-world software application, a message represents a piece of information that the application needs to process. This piece of information could be processed by another system or it can be an actual payload, like files or metadata that trigger some processing in another sub-system. Queues help in processing these messages sequentially.\u2003A message queue is like a buffer that receives messages in a specific order and forwards them to the concerned sub-system or application in the same order.</p> <p>Message queues decouple the sender and recipient, allowing them to operate independently and at their own pace. Consumers retrieve messages from the queue when they are ready to process them. They can retrieve and process messages independently and at their own pace, allowing for asynchronous processing.</p>"},{"location":"Software%20Engineering/Technology/Message%20Queues/#4-examples-of-usage-of-message-queues","title":"4. Examples of Usage of Message Queues","text":"<p>Let\u2019s try to understand the scenarios in which message queues can be used through an example. Let\u2019s say we have a web form that requires some input. We might need to insert this data into a database or put it into another system for some marketing automation.</p> <p>These tasks if done in sync, can hamper the user experience as they might add some latency or slowness to the process. Thus, we can treat the inputs as messages and utilize a queue to process these messages based on our requirements. Meanwhile, the user can be redirected to another screen, displaying a predefined acknowledgment message.</p>"},{"location":"Software%20Engineering/Technology/Message%20Queues/#5-common-terminologies-in-message-queues","title":"5. Common Terminologies in Message Queues","text":"<p>Let\u2019s go through some common terms used while working with message queues:</p>"},{"location":"Software%20Engineering/Technology/Message%20Queues/#51-producer","title":"5.1. Producer","text":"<p>The producer, also known as the sender, generates and sends messages to the message queue.\u2003It creates and publishes messages that contain data, requests, or tasks to be processed by the consumer. The producer\u2019s role is to enqueue the messages into the message queue without waiting for an immediate response. A producer can be a software application, service, or any component that generates and sends messages.</p>"},{"location":"Software%20Engineering/Technology/Message%20Queues/#52-consumer","title":"5.2. Consumer","text":"<p>The consumer, also known as the receiver, retrieves and processes messages from the message queue.\u2003It performs the necessary actions or operations based on the content of the messages. This can involve data processing, executing tasks, triggering workflows, or generating responses. Consumers can be separate software applications, services, or components designed to process specific messages or perform particular actions.</p>"},{"location":"Software%20Engineering/Technology/Message%20Queues/#53-topic","title":"5.3. Topic","text":"<p>In the context of message queues, a topic refers to a mechanism that enables categorizing or grouping messages based on a specific subject or theme. It allows consumers to selectively subscribe to and receive messages based on their interest in specific topics. Topics enhance the flexibility and efficiency of message queues by allowing producers to categorize and target their messages while enabling consumers to consume messages based on their specific interests selectively.</p>"},{"location":"Software%20Engineering/Technology/Message%20Queues/#54-message-broker","title":"5.4. Message Broker","text":"<p>In the context of message queues, a message broker is an intermediary component that facilitates the exchange of messages between producers and consumers.\u2003It acts as a central hub or mediator within the message queue system, responsible for receiving messages from producers, storing them, and delivering them to the appropriate consumers based on specified routing and subscription rules.</p>"},{"location":"Software%20Engineering/Technology/Message%20Queues/#6-publisher-subscriber-model-in-message-queues","title":"6. Publisher-Subscriber Model in Message Queues","text":"<p>The\u2003publisher-subscriber\u2003model, also known as the pub-sub model, is a messaging pattern that facilitates communication between multiple publishers and multiple subscribers. In this model, publishers are responsible for producing messages, while subscribers receive and consume the messages based on their interests or subscriptions.</p> <p>Here\u2019s a simplified diagram illustrating the publisher-subscriber model:</p> <p></p> <p>In this diagram, Publisher 1 and Publisher 2 generate messages and publish them to the message queue. The message queue functions as an intermediary and retains the messages until the subscribers consume them. The subscribers (Subscriber 1, Subscriber 2, and Subscriber 3) subscribe to specific topics or channels of interest within the message queue. The message queue then delivers relevant messages to each subscriber based on their subscriptions, guaranteeing they receive only the messages aligned with their interests.</p> <p>The publisher-subscriber model allows for decoupling between publishers and subscribers. Publishers don\u2019t need to have direct knowledge of the subscribers, and subscribers can receive messages from multiple publishers. It provides a flexible and scalable approach for distributing messages to interested parties in a loosely coupled manner.</p>"},{"location":"Software%20Engineering/Technology/Message%20Queues/#7-benefits-of-using-message-queues","title":"7. Benefits of Using Message Queues","text":"<p>Message queues help in decoupling parts of an application. While we can have a part that accepts data from the user, another part can process the data. Thus, we can move away from a huge monolithic application to a smaller, modular approach in development. By breaking it into smaller modules, we can test each module separately, without having to worry about all other parts in a system.</p> <p>Another benefit of decoupling is that different teams can work on different parts of the system in parallel and improve development times significantly. We can also improve scalability by allowing certain processing to happen async during high traffic, without affecting user experience.</p>"},{"location":"Software%20Engineering/Technology/Message%20Queues/#8-conclusion","title":"8. Conclusion","text":"<p>In conclusion, message queues serve as a valuable tool for efficient and reliable communication in various applications. In this tutorial, we\u2019ve looked at message queues, the common terminologies used in message queues, the publisher-subscriber model, and some benefits of using message queues.</p>"},{"location":"Software%20Engineering/Technology/Protobuf/","title":"Protobuf","text":"<p>Source</p> <p>https://protobuf.dev/overview/</p> <p>It\u2019s like JSON, except it\u2019s smaller and faster, and it generates native language bindings. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.</p> <p>Protocol buffers are a combination of the definition language (created in\u2003<code>.proto</code>\u2003files), the code that the proto compiler generates to interface with data, language-specific runtime libraries, and the serialization format for data that is written to a file (or sent across a network connection).</p>"},{"location":"Software%20Engineering/Technology/Protobuf/#what-problems-do-protocol-buffers-solve","title":"What Problems do Protocol Buffers Solve?","text":"<p>Protocol buffers provide a serialization format for packets of typed, structured data that are up to a few megabytes in size. The format is suitable for both ephemeral network traffic and long-term data storage. Protocol buffers can be extended with new information without invalidating existing data or requiring code to be updated.</p> <p>Protocol buffers are the most commonly-used data format at Google. They are used extensively in inter-server communications as well as for archival storage of data on disk. Protocol buffer\u2003messages\u2003and\u2003services\u2003are described by engineer-authored\u2003<code>.proto</code>\u2003files. The following shows an example\u2003<code>message</code>:</p> <pre><code>message Person {\n  optional string name = 1;\n  optional int32 id = 2;\n  optional string email = 3;\n}\n</code></pre>"},{"location":"Software%20Engineering/Technology/gRPC/","title":"gRPC","text":""},{"location":"Software%20Engineering/Technology/gRPC/#grpc","title":"gRPC","text":"<p>Source</p> <p>https://grpc.io/docs/</p>"},{"location":"Software%20Engineering/Technology/gRPC/#overview","title":"Overview","text":"<p>In gRPC, a client application can directly call a method on a server application on a different machine as if it were a local object, making it easier for you to create distributed applications and services. As in many RPC systems, gRPC is based around the idea of defining a service, specifying the methods that can be called remotely with their parameters and return types. On the server side, the server implements this interface and runs a gRPC server to handle client calls. On the client side, the client has a stub (referred to as just a client in some languages) that provides the same methods as the server.</p> <p></p>"},{"location":"Software%20Engineering/Technology/gRPC/#service-definitions","title":"Service definitions","text":"<p>Like many RPC systems, gRPC is based around the idea of defining a service, specifying the methods that can be called remotely with their parameters and return types. By default, gRPC uses\u2003Protobuf\u2003as the Interface Definition Language (IDL) for describing both the service interface and the structure of the payload messages. It is possible to use other alternatives if desired</p> <pre><code>service HelloService {\n  rpc SayHello (HelloRequest) returns (HelloResponse);\n}\n\nmessage HelloRequest {\n  string greeting = 1;\n}\n\nmessage HelloResponse {\n  string reply = 1;\n}\n</code></pre> <p>gRPC lets you define four kinds of service method:</p> <ul> <li> <p>Unary RPCs where the client sends a single request to the server and gets a single response back, just like a normal function call.  <pre><code>rpc SayHello(HelloRequest) returns (HelloResponse);\n</code></pre></p> </li> <li> <p>Server streaming RPCs where the client sends a request to the server and gets a stream to read a sequence of messages back. The client reads from the returned stream until there are no more messages. gRPC guarantees message ordering within an individual RPC call.</p> </li> </ul> <pre><code>rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);\n</code></pre> <ul> <li>Client streaming RPCs where the client writes a sequence of messages and sends them to the server, again using a provided stream. Once the client has finished writing the messages, it waits for the server to read them and return its response. Again gRPC guarantees message ordering within an individual RPC call.</li> </ul> <pre><code>rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);\n</code></pre> <ul> <li>Bidirectional streaming RPCs where both sides send a sequence of messages using a read-write stream. The two streams operate independently, so clients and servers can read and write in whatever order they like: for example, the server could wait to receive all the client messages before writing its responses, or it could alternately read a message then write a message, or some other combination of reads and writes. The order of messages in each stream is preserved.</li> </ul> <pre><code>rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);\n</code></pre>"},{"location":"Software%20Engineering/Technology/gRPC/#lifecycle","title":"Lifecycle","text":"<p>In this section, you\u2019ll take a closer look at what happens when a gRPC client calls a gRPC server method. For complete implementation details, see the language-specific pages.</p>"},{"location":"Software%20Engineering/Technology/gRPC/#unary-rpc","title":"Unary RPC","text":"<p>First consider the simplest type of RPC where the client sends a single request and gets back a single response.</p> <ol> <li>Once the client calls a stub method, the server is notified that the RPC has been invoked with the client\u2019s\u2003metadata\u2003for this call, the method name, and the specified\u2003deadline\u2003if applicable.</li> <li>The server can then either send back its own initial metadata (which must be sent before any response) straight away, or wait for the client\u2019s request message. Which happens first, is application-specific.</li> <li>Once the server has the client\u2019s request message, it does whatever work is necessary to create and populate a response. The response is then returned (if successful) to the client together with status details (status code and optional status message) and optional trailing metadata.</li> <li>If the response status is OK, then the client gets the response, which completes the call on the client side.</li> </ol>"},{"location":"Software%20Engineering/Technology/gRPC/#server-streaming-rpc","title":"Server streaming RPC","text":"<p>A server-streaming RPC is similar to a unary RPC, except that the server returns a stream of messages in response to a client\u2019s request. After sending all its messages, the server\u2019s status details (status code and optional status message) and optional trailing metadata are sent to the client. This completes processing on the server side. The client completes once it has all the server\u2019s messages.</p>"},{"location":"Software%20Engineering/Technology/gRPC/#client-streaming-rpc","title":"Client streaming RPC","text":"<p>A client-streaming RPC is similar to a unary RPC, except that the client sends a stream of messages to the server instead of a single message. The server responds with a single message (along with its status details and optional trailing metadata), typically but not necessarily after it has received all the client\u2019s messages.</p>"},{"location":"Software%20Engineering/Technology/gRPC/#bidirectional-streaming-rpc","title":"Bidirectional streaming RPC","text":"<p>In a bidirectional streaming RPC, the call is initiated by the client invoking the method and the server receiving the client metadata, method name, and deadline. The server can choose to send back its initial metadata or wait for the client to start streaming messages.</p> <p>Client- and server-side stream processing is application specific. Since the two streams are independent, the client and server can read and write messages in any order. For example, a server can wait until it has received all of a client\u2019s messages before writing its messages, or the server and client can play \u201cping-pong\u201d \u2013 the server gets a request, then sends back a response, then the client sends another request based on the response, and so on.</p>"},{"location":"Software%20Engineering/Technology/gRPC/#deadlinestimeouts","title":"Deadlines/Timeouts","text":"<p>gRPC allows clients to specify how long they are willing to wait for an RPC to complete before the RPC is terminated with a\u2003<code>DEADLINE_EXCEEDED</code>\u2003error. On the server side, the server can query to see if a particular RPC has timed out, or how much time is left to complete the RPC.</p> <p>Specifying a deadline or timeout is language specific: some language APIs work in terms of timeouts (durations of time), and some language APIs work in terms of a deadline (a fixed point in time) and may or may not have a default deadline.</p>"},{"location":"Software%20Engineering/Technology/gRPC/#rpc-termination","title":"RPC termination","text":"<p>In gRPC, both the client and server make independent and local determinations of the success of the call, and their conclusions may not match. This means that, for example, you could have an RPC that finishes successfully on the server side (\u201cI have sent all my responses!\u201d) but fails on the client side (\u201cThe responses arrived after my deadline!\u201d). It\u2019s also possible for a server to decide to complete before a client has sent all its requests.</p>"},{"location":"Software%20Engineering/Technology/gRPC/#cancelling-an-rpc","title":"Cancelling an RPC","text":"<p>Either the client or the server can cancel an RPC at any time. A cancellation terminates the RPC immediately so that no further work is done.</p>"},{"location":"Software%20Engineering/Technology/gRPC/#warning","title":"Warning","text":"<p>Changes made before a cancellation are not rolled back.</p>"},{"location":"Software%20Engineering/Technology/gRPC/#metadata","title":"Metadata","text":"<p>Metadata is information about a particular RPC call (such as\u2003authentication details) in the form of a list of key-value pairs, where the keys are strings and the values are typically strings, but can be binary data.</p> <p>Keys are case insensitive and consist of ASCII letters, digits, and special characters\u2003<code>-</code>,\u2003<code>_</code>,\u2003<code>.</code>\u2003and must not start with\u2003<code>grpc-</code>\u2003(which is reserved for gRPC itself). Binary-valued keys end in\u2003<code>-bin</code>\u2003while ASCII-valued keys do not.</p> <p>User-defined metadata is not used by gRPC, which allows the client to provide information associated with the call to the server and vice versa.</p> <p>Access to metadata is language dependent.</p>"},{"location":"Software%20Engineering/Technology/gRPC/#channels","title":"Channels","text":"<p>A gRPC channel provides a connection to a gRPC server on a specified host and port. It is used when creating a client stub. Clients can specify channel arguments to modify gRPC\u2019s default behavior, such as switching message compression on or off. A channel has state, including\u2003<code>connected</code>\u2003and\u2003<code>idle</code>.</p> <p>How gRPC deals with closing a channel is language dependent. Some languages also permit querying channel state.</p>"},{"location":"UI%20%26%20UX/Interaktive%20Systeme/","title":"Index","text":"<ul> <li>Entwurfsprinzipien</li> </ul>"},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/","title":"Entwurfsprinzipien","text":"<p>Achtung</p> <p>Dieser Abschnitt ist zur Zeit noch in Arbeit.</p> <p>Quelle</p> <p>Die Inhalte basieren zum Gro\u00dfteil auf den Folien aus der Vorlesung \u201cInteraktive Systeme\u201d von Andreas Heil (aheil.de) Dessen Quelle ist das Buch \u201cPreim, B. und Dachselt, R. (2010) Interaktive Systeme: Band 1: Grundlagen, Graphical User Interfaces, Informationsvisualisierung. 2. Aufl. Berlin: Springer. Abschnitt 6.2\u201d</p> <p>Prinzipien f\u00fcr allgemeine und kognitive Aspekte sind:</p> <ol> <li>Kenntnis potenzieller Benutzer und ihrer Aufgaben</li> <li>Unterst\u00fctzung beim Aufbau mentaler Modelle</li> <li>Terminologie der Benutzer verwenden</li> <li>Reduktion der kognitiven Belastung</li> </ol> <p>Prinzipien, die die Benutzungsschnittstelle betreffen:</p> <ol> <li>Strukturierung der Benutzungsschnittstelle,  </li> <li>Kombination visueller und textueller Elemente,  </li> <li>Sichtbarkeit von Systemzust\u00e4nden und m\u00f6glichen Aktionen,  </li> <li>Angemessene R\u00fcckkopplung,</li> <li>Konsistenz,  </li> <li>Abbruch und R\u00fcckg\u00e4ngigmachen von Aktionen,  </li> <li>Ber\u00fccksichtigung von Fehlern,  </li> <li>Erwartungskonformes Verhalten und  </li> <li>Adaptierbarkeit der Schnittstelle </li> </ol>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Abbruch%20und%20R%C3%BCckg%C3%A4ngigmachen%20von%20Aktionen/","title":"Abbruch und R\u00fcckg\u00e4ngigmachen von Aktionen","text":"<p>Info</p> <p>Bei zeitaufw\u00e4ndigen Aufgaben wichtig</p> <ul> <li>Undo sollte f\u00fcr mehrere Aktionen m\u00f6glich sein</li> <li>Scrollen h\u00e4ufig nicht r\u00fcckg\u00e4ngig machbar (sollte auch eine History besitzen)</li> <li>Redo ebenfalls wichtig, falls versehentliches Undo</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Adaptierbarkeit%20der%20Schnittstelle/","title":"Adaptierbarkeit der Schnittstelle","text":"<ul> <li>Nutzer*innen haben oft unterschiedliche Vorlieben</li> <li>Anpassung der Nutzeroberfl\u00e4che als Nutzer*in m\u00f6glich</li> <li>Speicherung der Anpassungen in den User Profiles</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Adaptierbarkeit%20der%20Schnittstelle/#kritik-an-adaptierbarkeit","title":"Kritik an Adaptierbarkeit","text":"<ul> <li>Nutzer*innen verschwenden evtl. viel Zeit mit unn\u00f6tigen Anpassungen</li> <li>Anpassungen k\u00f6nnen Produktivit\u00e4t negativ beeinflussen</li> <li>Schwierigerer Support</li> <li>Entwicklung konzentriert sich auf viel Anpassungsm\u00f6glichkeiten statt gute Oberfl\u00e4che von vorne herein zu gestalten.</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Angemessene%20R%C3%BCckkopplung/","title":"Angemessene R\u00fcckkopplung","text":"<ul> <li>Unmittelbare Reaktion wichtig</li> <li>Anwendung muss reagieren</li> <li>Aktionen &gt; 5s sollte quantitativ dar\u00fcber informieren</li> </ul> <p>Achtung</p> <ul> <li>Skalierbare R\u00fcckkopplung wesentlich</li> <li>(zu viel Feedback ist ebenfalls nicht produktiv, zu hohe kognitive Belastung)</li> <li>Bei erstmaliger Erledigung noch akzeptabel, nicht mehr f\u00fcr erfahrene Benutzer</li> <li>Meldung \u00fcber kritische Fehler ausreichend</li> <li>\u201eNo news is good news\u201c, Nachricht nur im \u201eKrisenfall\u201c</li> <li>Umfang der R\u00fcckmeldung sollte sich im Idealfall dem individuellen Kenntnisstand des</li> <li>Benutzers anpassen</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Angemessene%20R%C3%BCckkopplung/#problem","title":"Problem","text":"<p>Manchmal haben die Entwickler die neuesten Rechner</p>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Ber%C3%BCcksichtigung%20von%20Fehlern/","title":"Ber\u00fccksichtigung von Fehlern","text":"<ul> <li>Zerlegung von komplexen Aufgaben in \u00fcbersichtliche Aufgaben hilft, Fehler zu vermeiden</li> <li>Unterst\u00fctzt die Wahrnehmung und Interpretation des Systemzustands</li> <li>Benutzungsschnittstelle sollte nie in einen Zustand geraten, in dem der Benutzer \u00fcberhaupt keine M\u00f6glichkeit sieht, die Arbeit sinnvoll fortzusetzen</li> <li>Nie Arbeitsergebnisse verlieren</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Chunking/","title":"Chunking","text":"<ul> <li>Zusammenfassen elementarer Informationen</li> <li>Bei unvermeidbaren Wartezeiten, Feedback geben</li> <li>Tests zum Verstehen realer Nutzungskontexte</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Erwartungskonformes%20Verhalten/","title":"Erwartungskonformes Verhalten","text":"<ul> <li>Prinzip des \u201eminimalen Erstaunens\u201c</li> <li>exploratives Lernen</li> <li>Verh\u00e4lt sich entsprechend den Mentalen Modellen</li> <li>Eine Anwendung sollte sich vorhersehbar verhalten</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Kenntnis%20potenzieller%20Benutzer%20und%20ihrer%20Aufgaben/","title":"Kenntnis potenzieller Benutzer und ihrer Aufgaben","text":"<ul> <li>Grundlegendes Prinzip, Voraussetzung f\u00fcr die Anwendung aller anderen Prinzipien</li> <li>Prinzip muss von Anfang an beachtet werden</li> <li>Entwickler muss sich umfassend \u00fcber Benutzer informieren<ul> <li>Repr\u00e4sentative Menge an Benutzern</li> <li>Benutzer sollten repr\u00e4sentativ sein</li> <li>Befragung hinsichtlich Vorstellungen und Bed\u00fcrfnisse</li> </ul> </li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Kenntnis%20potenzieller%20Benutzer%20und%20ihrer%20Aufgaben/#methoden","title":"Methoden","text":"<ul> <li>Beobachtungen</li> <li>Interviews und Gruppeninterviews</li> <li>Schriftliche Befragungen</li> <li>Besuch von Benutzern \u201cvor Ort\u201d</li> <li>Analyse von T\u00e4tigkeiten (Workflow Analysis)</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Kenntnis%20potenzieller%20Benutzer%20und%20ihrer%20Aufgaben/#probleme","title":"Probleme","text":"<ul> <li>Kontakt Benutzer zu Entwickler oft von Auftraggeber nicht erw\u00fcnscht</li> <li>Vertraulichkeit von Informationen</li> <li>Entwickler verstehen das komplexe Arbeitsumfeld der Benutzer nicht</li> <li>Entwickler m\u00fcssen antizipieren, was erforderlich ist</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Kombination%20visueller%20und%20textueller%20Elemente/","title":"Kombination visueller und textueller Elemente","text":"<ul> <li>z.B Button mit text und Icon</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Konsistenz/","title":"Konsistenz","text":"<ul> <li>Sprachliche Konsistenz (Terminologie von Men\u00fceintr\u00e4gen, etc.)</li> <li>Strukturelle Konsistenz (Anordnung, Reihenfolge)</li> <li>Grafische Konsistenz (Farben, Fonts, 3D-Effekte, Linienstile)</li> <li>Interaktionskonsistenz (Verhalten bei Bet\u00e4tigung von Maustasten, Funktionstasten, Mausbuttons)</li> <li>Konsistenz zwischen Programmen</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Reduktion%20der%20kognitiven%20Belastung/","title":"Reduktion der kognitiven Belastung","text":"<ul> <li>Wartezeiten und Verz\u00f6gerungen auf ein Minimum reduzieren</li> <li>Feedback geben</li> <li>Angst bei der Benutzung vermeiden<ul> <li>vgl. exploratives Lernen in der ACT-Theorie</li> <li>robuste Systeme entwickeln</li> </ul> </li> <li>Wut vermeiden<ul> <li>insb. bei der Nutzung durch Experten</li> </ul> </li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Reduktion%20der%20kognitiven%20Belastung/#methoden","title":"Methoden","text":"<ul> <li>Chunking</li> <li>Wichtige Informationen, Systemzust\u00e4nde, Modi persistent anzeigen (vgl. Systemzustand)</li> <li>Weniger wichtige Informationen ausblenden</li> <li>Komplexe Aktionen in einzelne Schritte zerlegen (Teilziele)</li> <li>Gestaltung von Hilfen, direkt nutzbar</li> <li>Vereinfachung von Hilfetexten, Systemausgaben und Fehlerdialogen</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Reduktion%20der%20kognitiven%20Belastung/#probleme","title":"Probleme","text":"<ul> <li>Aufmerksamkeit und Arbeitsged\u00e4chtnis sind beschr\u00e4nkt</li> <li>Starke Belastung des Arbeitsged\u00e4chtnis bei der Nutzung interaktiver Systeme</li> <li>Hohe Belastung bei komplexen Dialogen und Formularen</li> <li>Urspr\u00fcngliches Ziel wird vergessen</li> <li>Wartezeiten f\u00fchren zu Vergessen der Ziele und dadurch zu Fehlern</li> <li>Zu einfache Benutzungsschnittstellen k\u00f6nnen professionelle Benutzer/Experten einschr\u00e4nken</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Sichtbarkeit%20von%20Systemzust%C3%A4nden%20und%20m%C3%B6glichen%20Aktionen/","title":"Sichtbarkeit von Systemzust\u00e4nden und m\u00f6glichen Aktionen","text":"<ul> <li>Verschiedene Modi erkennbar anzeigen</li> <li>Ausblenden von nicht aktivierbaren Dialogelementen</li> <li>Zul\u00e4ssige Wertbereiche anzeigen (numerische Werte)</li> <li>Erkl\u00e4rung, warum etwas nicht m\u00f6glich ist</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Strukturierung%20der%20Benutzungsschnittstelle/","title":"Strukturierung der Benutzungsschnittstelle","text":"<ul> <li>Zusammenfassen von Bedienelementen in Gruppen</li> <li>Zusammengeh\u00f6rige Informationen (Chunks) werden visuell besonders effizient verarbeitet (Chunking)</li> <li>Problem: Eine ideale L\u00f6sung gibt es nicht</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Strukturierung%20der%20Benutzungsschnittstelle/#methoden","title":"Methoden","text":"<ul> <li>Strukturierung auf Detailebene (Untermen\u00fcs, Gliederungen)</li> <li>Zusammengeh\u00f6rige Elemente von einem Rahmen umgeben</li> <li>\u00dcbersichtliche Anordnung</li> <li>Benennung von zusammengeh\u00f6rigen Elementen</li> <li>Zusammenfassung in Werkzeugleisten</li> <li>Beachtung der Gestaltgesetze</li> <li>Zusammenarbeit mit Designer</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Terminologie%20der%20Benutzer%20verwenden/","title":"Terminologie der Benutzer verwenden","text":"<ul> <li>Benutzungsschnittstellen sollen Sprache des Benutzers sprechen</li> <li>Fachsprache der Benutzer konsequent und korrekt verwenden</li> <li>Antizipation der Denkweise des Benutzers</li> <li>Klare, eindeutige Icons</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Terminologie%20der%20Benutzer%20verwenden/#benutzungsschnittstellen-sollen-sprache-des-benutzers-sprechen","title":"Benutzungsschnittstellen sollen Sprache des Benutzers sprechen","text":"<ul> <li>Kein Fachjargon der Entwickler</li> <li>Kein ungebr\u00e4uchliches Vokabular</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Terminologie%20der%20Benutzer%20verwenden/#fachsprache-der-benutzer-konsequent-und-korrekt-verwenden","title":"Fachsprache der Benutzer konsequent und korrekt verwenden","text":"<ul> <li>Benutzer denken nicht in Men\u00fcpunkten sondern Aufgaben</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Terminologie%20der%20Benutzer%20verwenden/#klare-eindeutige-icons","title":"Klare, eindeutige Icons","text":"<ul> <li>Geeignete Metaphern nutzen</li> <li>Dom\u00e4nenspezifische Darstellungen nutzen</li> <li>Zielgruppengerichtete Formulierungen (z.B. Manager vs. Jugendliche)</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Terminologie%20der%20Benutzer%20verwenden/#methoden","title":"Methoden","text":"<ul> <li>Auf wichtige Begriffe, Symbole und grafische Darstellungen achten (\u00c4hnlich der Identifizierung von geeigneten Metaphern)</li> <li>Terminologie auch in Diskussion mit Anwendern nutzen</li> <li>Grafische Prototypen und informelle Szenario-Beschreibungen</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Terminologie%20der%20Benutzer%20verwenden/#probleme","title":"Probleme","text":"<ul> <li>Bei Diskussion mit Benutzern Abstand zu den formalen Notationen der Entwickler nehmen</li> <li>Nutzung von unpassenden oder missverst\u00e4ndlichen Begriffen</li> <li>Benutzer wird nicht \u201cernst genommen\u201d</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Unterst%C3%BCtzung%20beim%20Aufbau%20mentaler%20Modelle/","title":"Unterst\u00fctzung beim Aufbau mentaler Modelle","text":"<ul> <li>Wenn Menschen etwas lernen, versuchen sie es zu verstehen (Modellentwicklung)</li> <li>Ziele des Prinzips<ul> <li>Lernaufwand verringern</li> <li>Zahl der Fehler verringern</li> <li>langfristiges Behandeln von Bedienhandlungen</li> </ul> </li> <li>Schwer zu Lernen, was im Widerspruch zu Bekanntem steht</li> <li>Bekannte Metaphern verwenden</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Unterst%C3%BCtzung%20beim%20Aufbau%20mentaler%20Modelle/#methoden","title":"Methoden","text":"<ul> <li>Orientierung an Terminologien und Abl\u00e4ufen in bekannten Anwendungen (vgl. n\u00e4chstes Prinzip)</li> <li>Konsistenz im Layout, in der Terminologie, in der Bildung von Abk\u00fcrzungen, in der Gestaltung von Piktogrammen, Icons, Darstellungen</li> <li>Tests zur Analyse, welche Assoziationen der Benutzer bei der Systemnutzung entwickelt</li> </ul>","tags":["is"]},{"location":"UI%20%26%20UX/Interaktive%20Systeme/Entwurfsprinzipien/Unterst%C3%BCtzung%20beim%20Aufbau%20mentaler%20Modelle/#probleme","title":"Probleme","text":"<ul> <li>Modellgenerierung nur schwer absch\u00e4tzbar</li> <li>Auswertung der Tests (s.o.) anspruchsvoll und aufwendig. Muss intensiv diskutiert werden, um falsche Konzepte zu erkennen</li> </ul>","tags":["is"]},{"location":"hidden/","title":"Index","text":"","tags":["DigitalGarden"]},{"location":"hidden/#momolems-digital-garden","title":"Momolems Digital Garden","text":"<p>This is where my knowledge grows</p> <p>This far I managed to include some notes on the topics CleanCode, UI &amp; UX and Cooking I want to expand these topics with everything I know</p>","tags":["DigitalGarden"]},{"location":"hidden/#clean-code","title":"Clean Code","text":"<p>CleanCode</p> <ul> <li>Clean Code Developer</li> <li>Design Patterns</li> </ul>","tags":["DigitalGarden"]},{"location":"hidden/#ui-ux","title":"UI &amp; UX","text":"<p>Entwurfsmuster</p>","tags":["DigitalGarden"]},{"location":"hidden/#cooking","title":"Cooking","text":"<p>Baghali Polo</p>","tags":["DigitalGarden"]},{"location":"hidden/Abbruch%20und%20R%C3%BCckg%C3%A4ngigmachen%20von%20Aktionen/","title":"Abbruch und R\u00fcckg\u00e4ngigmachen von Aktionen","text":"<p>Info</p> <p>Bei zeitaufw\u00e4ndigen Aufgaben wichtig</p> <ul> <li>Undo sollte f\u00fcr mehrere Aktionen m\u00f6glich sein</li> <li>Scrollen h\u00e4ufig nicht r\u00fcckg\u00e4ngig machbar (sollte auch eine History besitzen)</li> <li>Redo ebenfalls wichtig, falls versehentliches Undo</li> </ul>","tags":["is"]},{"location":"hidden/Abstract%20Factory/","title":"Abstract Factory","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Abstract%20Factory/#abstract-factory","title":"Abstract Factory","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Abstract%20Factory/#intent","title":"Intent","text":"<p>Abstract Factory\u2003is a creational design pattern that lets you produce families of related objects without specifying their concrete\u2003classes.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Abstract%20Factory/#problem","title":"Problem","text":"<p>Imagine that you\u2019re creating a furniture shop simulator. Your code consists of classes that represent:</p> <ol> <li> <p>A family of related products, say:\u2003<code>Chair</code>\u2003+\u2003<code>Sofa</code>\u2003+\u2003<code>CoffeeTable</code>.</p> </li> <li> <p>Several variants of this family. For example, products\u2003<code>Chair</code>\u2003+\u2003<code>Sofa</code>\u2003+\u2003<code>CoffeeTable</code>\u2003are available in these variants:\u2003<code>Modern</code>,\u2003<code>Victorian</code>,\u2003<code>ArtDeco</code>.</p> </li> </ol> <p></p> <p>Product families and their\u2003variants.</p> <p>You need a way to create individual furniture objects so that they match other objects of the same family. Customers get quite mad when they receive non-matching furniture.</p> <p></p> <p>A Modern-style sofa doesn\u2019t match Victorian-style\u2003chairs.</p> <p>Also, you don\u2019t want to change existing code when adding new products or families of products to the program. Furniture vendors update their catalogs very often, and you wouldn\u2019t want to change the core code each time it happens.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Abstract%20Factory/#solution","title":"Solution","text":"<p>The first thing the Abstract Factory pattern suggests is to explicitly declare interfaces for each distinct product of the product family (e.g., chair, sofa or coffee table). Then you can make all variants of products follow those interfaces. For example, all chair variants can implement the\u2003<code>Chair</code>\u2003interface; all coffee table variants can implement the\u2003<code>CoffeeTable</code>\u2003interface, and so on.</p> <p></p> <p>All variants of the same object must be moved to a single class\u2003hierarchy.</p> <p>The next move is to declare the\u2003Abstract Factory\u2014an interface with a list of creation methods for all products that are part of the product family (for example,\u2003<code>createChair</code>,\u2003<code>createSofa</code>\u2003and\u2003<code>createCoffeeTable</code>). These methods must return\u2003abstract\u2003product types represented by the interfaces we extracted previously:\u2003<code>Chair</code>,\u2003<code>Sofa</code>,\u2003<code>CoffeeTable</code>\u2003and so on.</p> <p></p> <p>Each concrete factory corresponds to a specific product\u2003variant.</p> <p>Now, how about the product variants? For each variant of a product family, we create a separate factory class based on the\u2003<code>AbstractFactory</code>\u2003interface. A factory is a class that returns products of a particular kind. For example, the\u2003<code>ModernFurnitureFactory</code>\u2003can only create\u2003<code>ModernChair</code>,\u2003<code>ModernSofa</code>\u2003and\u2003<code>ModernCoffeeTable</code>\u2003objects.</p> <p>The client code has to work with both factories and products via their respective abstract interfaces. This lets you change the type of a factory that you pass to the client code, as well as the product variant that the client code receives, without breaking the actual client code.</p> <p></p> <p>The client shouldn\u2019t care about the concrete class of the factory it works\u2003with.</p> <p>Say the client wants a factory to produce a chair. The client doesn\u2019t have to be aware of the factory\u2019s class, nor does it matter what kind of chair it gets. Whether it\u2019s a Modern model or a Victorian-style chair, the client must treat all chairs in the same manner, using the abstract\u2003<code>Chair</code>\u2003interface. With this approach, the only thing that the client knows about the chair is that it implements the\u2003<code>sitOn</code>\u2003method in some way. Also, whichever variant of the chair is returned, it\u2019ll always match the type of sofa or coffee table produced by the same factory object.</p> <p>There\u2019s one more thing left to clarify: if the client is only exposed to the abstract interfaces, what creates the actual factory objects? Usually, the application creates a concrete factory object at the initialization stage. Just before that, the app must select the factory type depending on the configuration or the environment settings.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Abstract%20Factory/#structure","title":"Structure","text":"<ol> <li> <p>Abstract Products\u2003declare interfaces for a set of distinct but related products which make up a product family.</p> </li> <li> <p>Concrete Products\u2003are various implementations of abstract products, grouped by variants. Each abstract product (chair/sofa) must be implemented in all given variants (Victorian/Modern).</p> </li> <li> <p>The\u2003Abstract Factory\u2003interface declares a set of methods for creating each of the abstract products.</p> </li> <li> <p>Concrete Factories\u2003implement creation methods of the abstract factory. Each concrete factory corresponds to a specific variant of products and creates only those product variants.</p> </li> <li> <p>Although concrete factories instantiate concrete products, signatures of their creation methods must return corresponding\u2003abstract\u2003products. This way the client code that uses a factory doesn\u2019t get coupled to the specific variant of the product it gets from a factory. The\u2003Client\u2003can work with any concrete factory/product variant, as long as it communicates with their objects via abstract interfaces.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Abstract%20Factory/#pseudocode","title":"Pseudocode","text":"<p>This example illustrates how the\u2003Abstract Factory\u2003pattern can be used for creating cross-platform UI elements without coupling the client code to concrete UI classes, while keeping all created elements consistent with a selected operating system.</p> <p></p> <p>The cross-platform UI classes\u2003example.</p> <p>The same UI elements in a cross-platform application are expected to behave similarly, but look a little bit different under different operating systems. Moreover, it\u2019s your job to make sure that the UI elements match the style of the current operating system. You wouldn\u2019t want your program to render macOS controls when it\u2019s executed in Windows.</p> <p>The Abstract Factory interface declares a set of creation methods that the client code can use to produce different types of UI elements. Concrete factories correspond to specific operating systems and create the UI elements that match that particular OS.</p> <p>It works like this: when an application launches, it checks the type of the current operating system. The app uses this information to create a factory object from a class that matches the operating system. The rest of the code uses this factory to create UI elements. This prevents the wrong elements from being created.</p> <p>With this approach, the client code doesn\u2019t depend on concrete classes of factories and UI elements as long as it works with these objects via their abstract interfaces. This also lets the client code support other factories or UI elements that you might add in the future.</p> <p>As a result, you don\u2019t need to modify the client code each time you add a new variation of UI elements to your app. You just have to create a new factory class that produces these elements and slightly modify the app\u2019s initialization code so it selects that class when appropriate.</p> <pre><code>// The abstract factory interface declares a set of methods that\n// return different abstract products. These products are called\n// a family and are related by a high-level theme or concept.\n// Products of one family are usually able to collaborate among\n// themselves. A family of products may have several variants,\n// but the products of one variant are incompatible with the\n// products of another variant.\ninterface GUIFactory is\n    method createButton():Button\n    method createCheckbox():Checkbox\n\n// Concrete factories produce a family of products that belong\n// to a single variant. The factory guarantees that the\n// resulting products are compatible. Signatures of the concrete\n// factory's methods return an abstract product, while inside\n// the method a concrete product is instantiated.\nclass WinFactory implements GUIFactory is\n    method createButton():Button is\n        return new WinButton()\n    method createCheckbox():Checkbox is\n        return new WinCheckbox()\n\n// Each concrete factory has a corresponding product variant.\nclass MacFactory implements GUIFactory is\n    method createButton():Button is\n        return new MacButton()\n    method createCheckbox():Checkbox is\n        return new MacCheckbox()\n\n// Each distinct product of a product family should have a base\n// interface. All variants of the product must implement this\n// interface.\ninterface Button is\n    method paint()\n\n// Concrete products are created by corresponding concrete\n// factories.\nclass WinButton implements Button is\n    method paint() is\n        // Render a button in Windows style.\n\nclass MacButton implements Button is\n    method paint() is\n        // Render a button in macOS style.\n\n// Here's the base interface of another product. All products\n// can interact with each other, but proper interaction is\n// possible only between products of the same concrete variant.\ninterface Checkbox is\n    method paint()\n\nclass WinCheckbox implements Checkbox is\n    method paint() is\n        // Render a checkbox in Windows style.\n\nclass MacCheckbox implements Checkbox is\n    method paint() is\n        // Render a checkbox in macOS style.\n\n// The client code works with factories and products only\n// through abstract types: GUIFactory, Button and Checkbox. This\n// lets you pass any factory or product subclass to the client\n// code without breaking it.\nclass Application is\n    private field factory: GUIFactory\n    private field button: Button\n    constructor Application(factory: GUIFactory) is\n        this.factory = factory\n    method createUI() is\n        this.button = factory.createButton()\n    method paint() is\n        button.paint()\n\n// The application picks the factory type depending on the\n// current configuration or environment settings and creates it\n// at runtime (usually at the initialization stage).\nclass ApplicationConfigurator is\n    method main() is\n        config = readApplicationConfigFile()\n\n        if (config.OS == \"Windows\") then\n            factory = new WinFactory()\n        else if (config.OS == \"Mac\") then\n            factory = new MacFactory()\n        else\n            throw new Exception(\"Error! Unknown operating system.\")\n\n        Application app = new Application(factory)\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/Abstract%20Factory/#applicability","title":"Applicability","text":"<ul> <li>Use the Abstract Factory when your code needs to work with various families of related products, but you don\u2019t want it to depend on the concrete classes of those products\u2014they might be unknown beforehand or you simply want to allow for future extensibility.     The Abstract Factory provides you with an interface for creating objects from each class of the product family. As long as your code creates objects via this interface, you don\u2019t have to worry about creating the wrong variant of a product which doesn\u2019t match the products already created by your app.<ul> <li>Consider implementing the Abstract Factory when you have a class with a set of\u2003Factory\u2003that blur its primary responsibility.</li> <li>In a well-designed program\u2003each class is responsible only for one thing. When a class deals with multiple product types, it may be worth extracting its factory methods into a stand-alone factory class or a full-blown Abstract Factory implementation.</li> </ul> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Abstract%20Factory/#how-to-implement","title":"How to Implement","text":"<ol> <li>Map out a matrix of distinct product types versus variants of these products.</li> <li>Declare abstract product interfaces for all product types. Then make all concrete product classes implement these interfaces.</li> <li>Declare the abstract factory interface with a set of creation methods for all abstract products.</li> <li>Implement a set of concrete factory classes, one for each product variant.</li> <li>Create factory initialization code somewhere in the app. It should instantiate one of the concrete factory classes, depending on the application configuration or the current environment. Pass this factory object to all classes that construct products.</li> <li>Scan through the code and find all direct calls to product constructors. Replace them with calls to the appropriate creation method on the factory object.W</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Abstract%20Factory/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can be sure that the products you\u2019re getting from a factory are compatible with each other. The code may become more complicated than it should be, since a lot of new interfaces and classes are introduced along with the pattern. You avoid tight coupling between concrete products and client code. Single Responsibility Principle. You can extract the product creation code into one place, making the code easier to support. Open Closed Principle. You can introduce new variants of products without breaking existing client code.","tags":["cleancode_designpatterns"]},{"location":"hidden/Abstract%20Factory/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).</li> <li>Builder focuses on constructing complex objects step by step. Abstract Factory specializes in creating families of related objects. Abstract Factory returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.</li> <li>Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.</li> <li>Abstract Factory can serve as an alternative to Facade when you only want to hide the way the subsystem objects are created from the client code.</li> <li>You can use Abstract Factory along with Bridge. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.</li> <li>Abstract Factory, Builder and Prototype can all be implemented as Singleton.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Adapter/","title":"Adapter","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Adapter/#adapter","title":"Adapter","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Adapter/#intent","title":"Intent","text":"<p>Adapter\u2003is a structural design pattern that allows objects with incompatible interfaces to\u2003collaborate.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Adapter/#problem","title":"Problem","text":"<p>Imagine that you\u2019re creating a stock market monitoring app. The app downloads the stock data from multiple sources in XML format and then displays nice-looking charts and diagrams for the user.</p> <p>At some point, you decide to improve the app by integrating a smart 3rd-party analytics library. But there\u2019s a catch: the analytics library only works with data in JSON format.</p> <p></p> <p>You can\u2019t use the analytics library \u201cas is\u201d because it expects the data in a format that\u2019s incompatible with your\u2003app.</p> <p>You could change the library to work with XML. However, this might break some existing code that relies on the library. And worse, you might not have access to the library\u2019s source code in the first place, making this approach impossible.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Adapter/#solution","title":"Solution","text":"<p>You can create an\u2003adapter. This is a special object that converts the interface of one object so that another object can understand it.</p> <p>An adapter wraps one of the objects to hide the complexity of conversion happening behind the scenes. The wrapped object isn\u2019t even aware of the adapter. For example, you can wrap an object that operates in meters and kilometers with an adapter that converts all of the data to imperial units such as feet and miles.</p> <p>Adapters can not only convert data into various formats but can also help objects with different interfaces collaborate. Here\u2019s how it works:</p> <ol> <li>The adapter gets an interface, compatible with one of the existing objects.</li> <li>Using this interface, the existing object can safely call the adapter\u2019s methods.</li> <li>Upon receiving a call, the adapter passes the request to the second object, but in a format and order that the second object expects.</li> </ol> <p>Sometimes it\u2019s even possible to create a two-way adapter that can convert the calls in both directions.</p> <p></p> <p>Let\u2019s get back to our stock market app. To solve the dilemma of incompatible formats, you can create XML-to-JSON adapters for every class of the analytics library that your code works with directly. Then you adjust your code to communicate with the library only via these adapters. When an adapter receives a call, it translates the incoming XML data into a JSON structure and passes the call to the appropriate methods of a wrapped analytics object.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Adapter/#real-world-analogy","title":"Real-World Analogy","text":"<p>A suitcase before and after a trip\u2003abroad.</p> <p>When you travel from the US to Europe for the first time, you may get a surprise when trying to charge your laptop. The power plug and sockets standards are different in different countries. That\u2019s why your US plug won\u2019t fit a German socket. The problem can be solved by using a power plug adapter that has the American-style socket and the European-style plug.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Adapter/#structure","title":"Structure","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Adapter/#object-adapter","title":"Object adapter","text":"<p>This implementation uses the object composition principle: the adapter implements the interface of one object and wraps the other one. It can be implemented in all popular programming languages.</p> <p></p> <ol> <li> <p>The\u2003Client\u2003is a class that contains the existing business logic of the program.</p> </li> <li> <p>The\u2003Client Interface\u2003describes a protocol that other classes must follow to be able to collaborate with the client code.</p> </li> <li> <p>The\u2003Service\u2003is some useful class (usually 3rd-party or legacy). The client can\u2019t use this class directly because it has an incompatible interface.</p> </li> <li> <p>The\u2003Adapter\u2003is a class that\u2019s able to work with both the client and the service: it implements the client interface, while wrapping the service object. The adapter receives calls from the client via the adapter interface and translates them into calls to the wrapped service object in a format it can understand.</p> </li> <li> <p>The client code doesn\u2019t get coupled to the concrete adapter class as long as it works with the adapter via the client interface. Thanks to this, you can introduce new types of adapters into the program without breaking the existing client code. This can be useful when the interface of the service class gets changed or replaced: you can just create a new adapter class without changing the client code.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Adapter/#class-adapter","title":"Class adapter","text":"<p>This implementation uses inheritance: the adapter inherits interfaces from both objects at the same time. Note that this approach can only be implemented in programming languages that support multiple inheritance, such as C++.</p> <p></p> <ol> <li>The\u2003Class Adapter\u2003doesn\u2019t need to wrap any objects because it inherits behaviors from both the client and the service. The adaptation happens within the overridden methods. The resulting adapter can be used in place of an existing client class.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Adapter/#pseudocode","title":"Pseudocode","text":"<p>This example of the\u2003Adapter\u2003pattern is based on the classic conflict between square pegs and round holes.</p> <p></p> <p>Adapting square pegs to round\u2003holes.</p> <p>The Adapter pretends to be a round peg, with a radius equal to a half of the square\u2019s diameter (in other words, the radius of the smallest circle that can accommodate the square peg).</p> <pre><code>// Say you have two classes with compatible interfaces:\n// RoundHole and RoundPeg.\nclass RoundHole is\n    constructor RoundHole(radius) { ... }\n\n    method getRadius() is\n        // Return the radius of the hole.\n\n    method fits(peg: RoundPeg) is\n        return this.getRadius() &gt;= peg.getRadius()\n\nclass RoundPeg is\n    constructor RoundPeg(radius) { ... }\n\n    method getRadius() is\n        // Return the radius of the peg.\n\n// But there's an incompatible class: SquarePeg.\nclass SquarePeg is\n    constructor SquarePeg(width) { ... }\n\n    method getWidth() is\n        // Return the square peg width.\n\n// An adapter class lets you fit square pegs into round holes.\n// It extends the RoundPeg class to let the adapter objects act\n// as round pegs.\nclass SquarePegAdapter extends RoundPeg is\n    // In reality, the adapter contains an instance of the\n    // SquarePeg class.\n    private field peg: SquarePeg\n\n    constructor SquarePegAdapter(peg: SquarePeg) is\n        this.peg = peg\n\n    method getRadius() is\n        // The adapter pretends that it's a round peg with a\n        // radius that could fit the square peg that the adapter\n        // actually wraps.\n        return peg.getWidth() * Math.sqrt(2) / 2\n\n// Somewhere in client code.\nhole = new RoundHole(5)\nrpeg = new RoundPeg(5)\nhole.fits(rpeg) // true\n\nsmall_sqpeg = new SquarePeg(5)\nlarge_sqpeg = new SquarePeg(10)\nhole.fits(small_sqpeg) // this won't compile (incompatible types)\n\nsmall_sqpeg_adapter = new SquarePegAdapter(small_sqpeg)\nlarge_sqpeg_adapter = new SquarePegAdapter(large_sqpeg)\nhole.fits(small_sqpeg_adapter) // true\nhole.fits(large_sqpeg_adapter) // false\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/Adapter/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Adapter class when you want to use some existing class, but its interface isn\u2019t compatible with the rest of your code.     \u2003The Adapter pattern lets you create a middle-layer class that serves as a translator between your code and a legacy class, a 3rd-party class or any other class with a weird interface.</p> </li> <li> <p>Use the pattern when you want to reuse several existing subclasses that lack some common functionality that can\u2019t be added to the superclass.     \u2003You could extend each subclass and put the missing functionality into new child classes. However, you\u2019ll need to duplicate the code across all of these new classes, which\u2003smells really bad.</p> <p>The much more elegant solution would be to put the missing functionality into an adapter class. Then you would wrap objects with missing features inside the adapter, gaining needed features dynamically. For this to work, the target classes must have a common interface, and the adapter\u2019s field should follow that interface. This approach looks very similar to the\u2003Decorator\u2003pattern.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Adapter/#how-to-implement","title":"How to Implement","text":"<ol> <li>Make sure that you have at least two classes with incompatible interfaces:<ul> <li>A useful\u2003service\u2003class, which you can\u2019t change (often 3rd-party, legacy or with lots of existing dependencies).</li> <li>One or several\u2003client\u2003classes that would benefit from using the service class.</li> </ul> </li> <li>Declare the client interface and describe how clients communicate with the service.</li> <li>Create the adapter class and make it follow the client interface. Leave all the methods empty for now.</li> <li>Add a field to the adapter class to store a reference to the service object. The common practice is to initialize this field via the constructor, but sometimes it\u2019s more convenient to pass it to the adapter when calling its methods.</li> <li>One by one, implement all methods of the client interface in the adapter class. The adapter should delegate most of the real work to the service object, handling only the interface or data format conversion.</li> <li>Clients should use the adapter via the client interface. This will let you change or extend the adapters without affecting the client code.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Adapter/#pros-and-cons","title":"Pros and Cons","text":"Pros Cons Single Responsibility Principle. You can separate the interface or data conversion code from the primary business logic of the program. The overall complexity of the code increases because you need to introduce a set of new interfaces and classes. Sometimes it\u2019s simpler just to change the service class so that it matches the rest of your code. Open Closed Principle. You can introduce new types of adapters into the program without breaking the existing client code, as long as they work with the adapters through the client interface.","tags":["cleancode_designpatterns"]},{"location":"hidden/Adapter/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.</li> <li>Adapter changes the interface of an existing object, while Decorator enhances an object without changing its interface. In addition, Decorator supports recursive composition, which isn\u2019t possible when you use Adapter.</li> <li>Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.</li> <li>Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.</li> <li>Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn\u2019t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Adaptierbarkeit%20der%20Schnittstelle/","title":"Adaptierbarkeit der Schnittstelle","text":"<ul> <li>Nutzer*innen haben oft unterschiedliche Vorlieben</li> <li>Anpassung der Nutzeroberfl\u00e4che als Nutzer*in m\u00f6glich</li> <li>Speicherung der Anpassungen in den User Profiles</li> </ul>","tags":["is"]},{"location":"hidden/Adaptierbarkeit%20der%20Schnittstelle/#kritik-an-adaptierbarkeit","title":"Kritik an Adaptierbarkeit","text":"<ul> <li>Nutzer*innen verschwenden evtl. viel Zeit mit unn\u00f6tigen Anpassungen</li> <li>Anpassungen k\u00f6nnen Produktivit\u00e4t negativ beeinflussen</li> <li>Schwierigerer Support</li> <li>Entwicklung konzentriert sich auf viel Anpassungsm\u00f6glichkeiten statt gute Oberfl\u00e4che von vorne herein zu gestalten.</li> </ul>","tags":["is"]},{"location":"hidden/Angemessene%20R%C3%BCckkopplung/","title":"Angemessene R\u00fcckkopplung","text":"<ul> <li>Unmittelbare Reaktion wichtig</li> <li>Anwendung muss reagieren</li> <li>Aktionen &gt; 5s sollte quantitativ dar\u00fcber informieren</li> </ul> <p>Achtung</p> <ul> <li>Skalierbare R\u00fcckkopplung wesentlich</li> <li>(zu viel Feedback ist ebenfalls nicht produktiv, zu hohe kognitive Belastung)</li> <li>Bei erstmaliger Erledigung noch akzeptabel, nicht mehr f\u00fcr erfahrene Benutzer</li> <li>Meldung \u00fcber kritische Fehler ausreichend</li> <li>\u201eNo news is good news\u201c, Nachricht nur im \u201eKrisenfall\u201c</li> <li>Umfang der R\u00fcckmeldung sollte sich im Idealfall dem individuellen Kenntnisstand des</li> <li>Benutzers anpassen</li> </ul>","tags":["is"]},{"location":"hidden/Angemessene%20R%C3%BCckkopplung/#problem","title":"Problem","text":"<p>Manchmal haben die Entwickler die neuesten Rechner</p>","tags":["is"]},{"location":"hidden/Automated%20Integrationtests/","title":"Automated Integrationtests","text":"","tags":["cleancode"]},{"location":"hidden/Automated%20Integrationtests/#automated-integrationtests","title":"Automated Integrationtests","text":"<p>Warum? Integrationstests stellen sicher dass der Code tut was er soll. Diese wiederkehrende T\u00e4tigkeit nicht zu automatisieren w\u00e4re Zeitverschwendung.</p> <p>Die fundamentale Voraussetzung f\u00fcr jegliche \u00c4nderungen am Code haben wir bereits im\u2003Roten Grad\u2003durch den Einsatz eines Versionskontrollsystems gelegt. Wir k\u00f6nnen ohne Sorge \u00c4nderungen am Code vornehmen, ganze Dateien und Verzeichnisse l\u00f6schen, durch das Versionskontrollsystem ist alles wieder abrufbar.</p> <p>Wenn wir nun \u00c4nderungen am Code vornehmen, sollten wir uns sicher sein, dass wir dabei nichts kaputt machen. Und diese Sicherheit k\u00f6nnen wir nur erlangen, wenn wir nach der \u00c4nderung testen, ob die Anwendung sich noch so verh\u00e4lt wie zuvor. Diese Tests nach jeder \u00c4nderung per Hand durchzuf\u00fchren w\u00e4re nicht praktikabel, wir m\u00fcssen sie automatisieren. Ein gro\u00dfes \u00dcbel der Softwareentwicklung ist die Angst, bei \u00c4nderungen am Code etwas zu \u00fcbersehen, ein Detail nicht zu ber\u00fccksichtigen, und dadurch einen Fehler zu verursachen in Code der vorher funktionierte. Dabei spielt es in der Regel sogar nicht mal eine Rolle, ob die \u00c4nderungen dazu f\u00fchren sollen, dass der Code verbessert wird (Refaktorisieren) oder zus\u00e4tzliche Anforderungen umgesetzt werden sollen. Solange wir nach Durchf\u00fchren einer \u00c4nderung nicht sicher sind, dass alles noch so funktioniert wie zuvor, bleibt die Angst. Diese f\u00fchrt dazu, dass wir Code im Zweifelsfall so belassen, wie er ist, denn er funktioniert ja. Notwendige Refaktorisierungen werden unterlassen, aus Angst Fehler zu machen.</p> <p>Damit wir uns auch in schon laufenden Projekten (sogenannte\u2003Brownfield\u2003Projekte, im Gegensatz zu\u2003Greenfield\u2003\u201eauf der gr\u00fcnen Wiese\u201c) dieses Sicherheitsnetz schaffen k\u00f6nnen, ben\u00f6tigen wir Verfahren, die auf vorhandenen Code angewendet werden k\u00f6nnen. Dazu eignen sich automatisierte Integrationstests. Sie setzen entweder ganz oben auf der Benutzerschnittstelle auf und testen die Anwendung durch alle Layer oder setzen weiter unten auf. In jedem Fall werden mehrere Funktionseinheiten im Zusammenspiel getestet.</p> <p>Bevor wir also \u00c4nderungen oder Erweiterungen am Code vornehmen, erstellen wir f\u00fcr die betroffenen Codebereiche Integrationstests. Dabei k\u00f6nnen Tools und Techniken wie WatiN, UI Automation, etc. verwendet werden. W\u00fcnschenswert sind nat\u00fcrlich auch Unit Tests, welche einzelne Funktionseinheiten isoliert testen. Dazu muss der Code allerdings Voraussetzungen erf\u00fcllen, die vermutlich nicht immer gegeben sind: der Code muss bereits das\u2003 Single Responsibility Principle\u2003ber\u00fccksichtigen. Andernfalls sind die Abh\u00e4ngigkeiten zwischen den Funktionseinheiten (Komponenten, Klassen oder Methoden) so gro\u00df, dass sie nicht isoliert getestet werden k\u00f6nnen. Das Fernziel ist nat\u00fcrlich eine Codebasis, bei der Unit Tests m\u00f6glich sind. Mehr noch: wir werden in Zukunft die Tests vor der Implementierung erstellen (Test first). Aber um durch Refaktorisierungen dorthin zu gelangen, bedarf es erst der Integrationstests, um sicherzustellen, dass die Anwendung sich noch so verh\u00e4lt wie vor der Refaktorisierung.</p>","tags":["cleancode"]},{"location":"hidden/Automated%20Unit%20Tests/","title":"Automated Unit Tests","text":"","tags":["cleancode"]},{"location":"hidden/Automated%20Unit%20Tests/#automated-unit-tests","title":"Automated Unit Tests","text":"<p>Warum? Nur automatisierte Tests werden auch wirklich konsequent ausgef\u00fchrt. Je punktgenauer sie Code testen, desto besser.</p> <p>Im\u2003Orangenen Grad\u2003haben wir Integration Tests eingef\u00fchrt, nun geht es um Unit Tests. Im Gegensatz zu Integrationstests wird bei Unit Tests eine einzelne Funktionseinheit (vor allem Klassen, aber auch Methoden oder Komponenten) isoliert getestet. Dazu ist es erforderlich, diese Funktionseinheit von ihren Abh\u00e4ngigkeiten befreien zu k\u00f6nnen. Sollen Unit Tests im Nachhinein f\u00fcr bestehenden Code erg\u00e4nzt werden, sind h\u00e4ufig Refaktorisierungen erforderlich. Wir haben durch die Integrationstests die Sicherheit, dass wir dabei keine Fehler einbauen.</p> <p>Automatisierte Tests bieten zweifachen Nutzen:</p> <ul> <li>Sie sparen Zeit</li> <li>Sie nehmen Angst</li> </ul> <p>Je st\u00e4rker eine Codebasis in Ver\u00e4nderung begriffen ist, desto eher ist die Zeitersparnis zu sp\u00fcren. Denn wo Code sich ver\u00e4ndert, muss immer wieder Neues und auch Altes (Regressionstests) getestet werden. Da spart Automatisation einfach Zeit. Und je komplexer der Code, desto gr\u00f6\u00dfer ist die Angstreduktion. Denn wenn komplexer Code ver\u00e4ndert werden soll \u2013 um Funktionalit\u00e4t hinzuzuf\u00fcgen, ihn zu optimieren oder schlicht zu korrigieren \u2013, da besteht hohe Gefahr, ungewollt Fehler einzuf\u00fchren. Kleinschrittige automatisierte Tests decken diese jedoch auf, sodass kein Grund zur Angst besteht, zu \u201everschlimmbessern\u201c.</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"hidden/Baghali%20Polo/","title":"Baghali Polo","text":"","tags":["cooking","persian"]},{"location":"hidden/Baghali%20Polo/#baghali-polo-das-mit-den-bohnen","title":"Baghali Polo (Das mit den Bohnen)","text":"","tags":["cooking","persian"]},{"location":"hidden/Baghali%20Polo/#zutaten","title":"Zutaten","text":"<ul> <li>Zwiebeln</li> <li>Gesch\u00e4hlte Bohnen</li> <li>Dill</li> <li>Tomatenmark</li> <li>Reis</li> <li>Safran</li> <li>Kurkuma</li> <li>Lammfleisch</li> </ul>","tags":["cooking","persian"]},{"location":"hidden/Baghali%20Polo/#ablauf","title":"Ablauf","text":"<p>Zuerst die Zwiebeln in \u00d6l anbraten. Anschlie\u00dfen etwas Kurkuma hinzugeben und gut verr\u00fchren. Anschlie\u00dfend mit Wasser abl\u00f6schen und das Fleisch hinzugeben. Das Fleisch muss gerade so bedeckt sein, hierbei m\u00f6glichst wenig Wasser verwenden. Ca. 30-15 Minuten vor Schluss etwas gebratenes Tomatenmark und Safran zur Fl\u00fcssigkeit hinzugeben.</p> <p>Die Bohnen mit gekochtem Wasser \u00fcbergie\u00dfen und 5 Minuten kochen lassen. Anschlie\u00dfend 5 Minuten mit Deckel ziehen lassen. Das Wasser kann hierbei nur die H\u00e4lfte der Bohnen bedecken. Nicht zu viel R\u00fchren, sonst zerbrechen die Bohnen. Die Br\u00fche f\u00fcr den Reis verwenden und diesen zun\u00e4chst ganz normal kochen. </p> <p>Wenn das ganze Wasser aus dem Reis ist, ein Hohlraum f\u00fcr die Bohnen schaffen. Hierbei nicht bis ganz nach unten, damit die Kruste nicht kaputt geht. Bohnen, Dill und etwas Zimt hinzugeben. Drei kleine L\u00f6cher mit einem Kochl\u00f6ffelstiel formen und ein bisschen kochendes Wasser hineingeben um etwas Dampf zu erzeugen. Direkt den Deckel drauf.  </p> <p>Zum Schluss etwas geschmolzene Butter hinzugeben.</p>","tags":["cooking","persian"]},{"location":"hidden/Ber%C3%BCcksichtigung%20von%20Fehlern/","title":"Ber\u00fccksichtigung von Fehlern","text":"<ul> <li>Zerlegung von komplexen Aufgaben in \u00fcbersichtliche Aufgaben hilft, Fehler zu vermeiden</li> <li>Unterst\u00fctzt die Wahrnehmung und Interpretation des Systemzustands</li> <li>Benutzungsschnittstelle sollte nie in einen Zustand geraten, in dem der Benutzer \u00fcberhaupt keine M\u00f6glichkeit sieht, die Arbeit sinnvoll fortzusetzen</li> <li>Nie Arbeitsergebnisse verlieren</li> </ul>","tags":["is"]},{"location":"hidden/Beware%20of%20Premature%20Optimization/","title":"Beware of Premature Optimization","text":"","tags":["cleancode"]},{"location":"hidden/Beware%20of%20Premature%20Optimization/#beware-of-premature-optimization","title":"Beware of Premature Optimization","text":"<p>Warum? Optimierungen kosten immer viel Aufwand. Wer Vorsicht walten l\u00e4sst, spart oft wertvolle Ressourcen f\u00fcr das, was dem Kunden wirklich n\u00fctzt.</p> <p>Rules of Optimization:</p> <p>Rule 1: Don\u2019t do it.</p> <p>Rule 2 (for experts only): Don\u2019t do it yet.</p> <p>~ M.A. Jackson</p> <p>More computing sins are committed in the name of efficiency (without necessarily achieving it) than for any other single reason \u2013 including blind stupidity. ~ W.A. Wulf</p> <p>Im Vordergrund steht immer die Verst\u00e4ndlichkeit von Code. Optimierter Code ist aber oft alles andere als lesbar. Indem er auf das absolut Notwendige in k\u00fcrzester Form reduziert ist, mag er zwar die funktionalen und nicht funktionalen Anforderungen des Kunden erf\u00fcllen \u2013 doch er spiegelt sie meist nicht mehr verst\u00e4ndlich wider. Das ist kontraproduktiv im Sinne der meist gew\u00fcnschten Langlebigkeit einer Software. Donald Knuth schrieb bereits 1974: </p> <p>\u201eWe should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.\u201c </p> <p>(Knuth, Donald.\u2003Structured Programming with go to Statements, ACM Journal Computing Surveys, Vol 6, No. 4, Dec. 1974. p.268.)</p> <p>Die Pfadfinderregel ist also nicht so gemeint, dass immer weiter nach Codeoptimierungen gestrebt werden sollte. Sie bezieht sich vielmehr auf deren Gegenteil: Verst\u00e4ndlichkeit und Wandelbarkeit.</p> <p>Wenn es dem Clean Code Developer also in den Fingern zuckt, weil er denkt, er k\u00f6nne doch noch ein Qu\u00e4ntchen Performance durch eine Optimierung herausholen, dann sollte er mindestens zweimal \u00fcberlegen. Zum einen w\u00fcrde er dadurch die Verst\u00e4ndlichkeit verschlechtern, zum anderen aber ist es wahrscheinlich, dass solche Optimierung aus mehreren Gr\u00fcnden gar nicht n\u00f6tig ist. Ist die Performanceschw\u00e4che nicht nur punktuell und ein Sonderfall, wird sich die n\u00e4chste gr\u00f6\u00dfere Refaktorisierung ihrer wahrscheinlich ohnehin annehmen, denn dann liegt ihr ein grunds\u00e4tzliches Strukturproblem zugrunde. Oder die n\u00e4chste Hardwaregeneration b\u00fcgelt den Performanceknick aus. Oder der Kunde f\u00fchlt sich durch ihn gar nicht gest\u00f6rt. Ohnehin muss der Kunde die Forderung nach der Optimierung gestellt haben. Keine Codever\u00e4nderung ohne vom Kunden erwarteten Nutzen. Denn nur f\u00fcr ihn ist er bereit zu zahlen.</p> <p>Der Regel, sich im Zweifelsfall gegen Optimierungen zu entscheiden, liegt somit eine noch fundamentalere zugrunde: YAGNI \u2013\u2003You ain\u2019t gonna need it. Sie ist in ihrer vollen Auspr\u00e4gung allerdings erst Bestandteil des\u2003Blauer Grad</p> <p>PS: Wenn denn entgegen allen Warnungen und Bedenken gerade eine Performanceoptimierung unumg\u00e4nglich ist, dann sollte sie immer nur aufgrund einer detaillierten Analyse mit einem Profiler begonnen werden. Denn nur wer mit einem Profiler nachvollziehbar Performance-Engp\u00e4sse lokalisiert hat, kann w\u00e4hrend und nach der Optimierung pr\u00fcfen, ob und inwiefern er sie geweitet hat.</p>","tags":["cleancode"]},{"location":"hidden/Blauer%20Grad/","title":"Blauer Grad","text":"","tags":["cleancode"]},{"location":"hidden/Blauer%20Grad/#blauer-grad","title":"Blauer Grad","text":"","tags":["cleancode"]},{"location":"hidden/Blauer%20Grad/#prinzipien","title":"Prinzipien","text":"<ul> <li>Design and Implementation do not Overlapp</li> <li>Implementation Reflects Design</li> <li>YAGNI</li> </ul>","tags":["cleancode"]},{"location":"hidden/Blauer%20Grad/#praktiken","title":"Praktiken","text":"<ul> <li>Design before Implementation</li> <li>Continuous Delivery</li> <li>Iterative Development</li> <li>Incremental Development</li> <li>Component Orientation</li> <li>Test First</li> </ul>","tags":["cleancode"]},{"location":"hidden/Boy%20Scout%20Rule/","title":"Boy Scout Rule","text":"","tags":["cleancode"]},{"location":"hidden/Boy%20Scout%20Rule/#boy-scout-rule","title":"Boy Scout Rule","text":"<p>Warum? Jede Besch\u00e4ftigung mit einem Gegenstand macht ihn zumindest ein klein wenig besser. Ganz ohne b\u00fcrokratische Planung. Fundament und Graswurzelansatz f\u00fcr mehr Qualit\u00e4t.</p> <p>Das Clean Code Developer Wertesystem l\u00e4sst sich nicht mit einem Mal etablieren. Daf\u00fcr braucht es Zeit. Vor allem, da ein Clean Code Developer selten auf einer gr\u00fcnen Wiese und auch noch allein arbeitet, ist es schwer, die Prinzipien auf eine gesamte Codebasis anzuwenden. Wir glauben daher, dass es wichtig ist, sich nicht zu hohe Ziele zu setzen. Viel realistischer und motivierender ist es, nur kleine Fortschritte anzustreben \u2013 daf\u00fcr aber kontinuierliche.</p> <p>Zum Fundament des Clean Code Development geh\u00f6rt deshalb f\u00fcr uns die Pfadfinderregel. Sie findet sich auch in\u2003Clean Code\u2003und lautet:\u2003</p> <p>Hinterlasse einen Ort immer in einem besseren Zustand als du ihn vorgefunden hast.</p> <p>Auf die Softwareentwicklung angewandt bedeutet das: Clean Code Developer hinterlassen Code immer in einem \u201ebesseren Zustand\u201c als sie ihn vorgefunden haben. Nach getaner Arbeit stimmt der Code also mit dem Clean Code Development Wertesystem mehr \u00fcberein als vorher.</p> <p>Was ein Clean Code Developer an ihm daf\u00fcr getan hat, ist situations-/codeabh\u00e4ngig \u2013 und wird nat\u00fcrlich auch durch den Grad bestimmt, an dem er arbeitet. Im Roter Grad achtet ein Clean Code Developer z.B. darauf, dass Code, der noch nicht im Repository der Versionsverwaltung war, nun auch dort abgelegt ist. Und er achtet darauf, dass Wiederholungen jeder Art \u2013 also Verletzungen des DRY-Prinzips \u2013 \u201eausgeb\u00fcgelt\u201c werden.</p> <p>Wo ein Clean Code Developer Suboptimalit\u00e4ten im Sinne des CCD-Wertesystems feststellt, bem\u00fcht er sich also stetig darum, sie zu verbessern. In kleinen Schritten. Und nat\u00fcrlich bem\u00fcht er sich, Suboptimalit\u00e4ten von vornherein zu vermeiden. Wie gesagt: immer auf der Stufe seiner Entwicklung.</p> <p>Diese Maxime steht am Anfang der Entwicklung des Clean Code Developers eingedenk der\u2003Broken Windows Theorie. Nach ihr beginnt der Verfall von Qualit\u00e4t im allgemeinen Sinn mit Kleinigkeiten, die nur lange genug unbeachtet bleiben.</p> <p>Wenn Clean Code Developer jedoch nach der Pfadfinderregel arbeiten, kommt es gar nicht erst zu \u201eBroken Windows\u201c \u2013 vorhandene werden eines nach dem anderen repariert. \u201eRisse und Unebenheiten\u201c im Code schlie\u00dft die Pfadfinderregel konsequent auf der Basis des CCD-Wertesystems, sodass sich keine weiteren \u201eAblagerungen\u201c ansammeln k\u00f6nnen. Sie wirkt damit proaktiv einer Code-Erosion entgegen. Das halten wir f\u00fcr so fundamental, dass wir sie in den roten Grad aufgenommen haben.</p>","tags":["cleancode"]},{"location":"hidden/Bridge/","title":"Bridge","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Bridge/#bridge","title":"Bridge","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Bridge/#intent","title":"Intent","text":"<p>Bridge\u2003is a structural design pattern that lets you split a large class or a set of closely related classes into two separate hierarchies\u2014abstraction and implementation\u2014which can be developed independently of each\u2003other.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Bridge/#problem","title":"Problem","text":"<p>Abstraction? Implementation?\u2003Sound scary? Stay calm and let\u2019s consider a simple example.</p> <p>Say you have a geometric\u2003<code>Shape</code>\u2003class with a pair of subclasses:\u2003<code>Circle</code>\u2003and\u2003<code>Square</code>. You want to extend this class hierarchy to incorporate colors, so you plan to create\u2003<code>Red</code>\u2003and\u2003<code>Blue</code>\u2003shape subclasses. However, since you already have two subclasses, you\u2019ll need to create four class combinations such as\u2003<code>BlueCircle</code>\u2003and\u2003<code>RedSquare</code>.</p> <p></p> <p>Number of class combinations grows in geometric\u2003progression.</p> <p>Adding new shape types and colors to the hierarchy will grow it exponentially. For example, to add a triangle shape you\u2019d need to introduce two subclasses, one for each color. And after that, adding a new color would require creating three subclasses, one for each shape type. The further we go, the worse it becomes.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Bridge/#solution","title":"Solution","text":"<p>This problem occurs because we\u2019re trying to extend the shape classes in two independent dimensions: by form and by color. That\u2019s a very common issue with class inheritance.</p> <p>The Bridge pattern attempts to solve this problem by switching from inheritance to the object composition. What this means is that you extract one of the dimensions into a separate class hierarchy, so that the original classes will reference an object of the new hierarchy, instead of having all of its state and behaviors within one class.</p> <p></p> <p>You can prevent the explosion of a class hierarchy by transforming it into several related\u2003hierarchies.</p> <p>Following this approach, we can extract the color-related code into its own class with two subclasses:\u2003<code>Red</code>\u2003and\u2003<code>Blue</code>. The\u2003<code>Shape</code>\u2003class then gets a reference field pointing to one of the color objects. Now the shape can delegate any color-related work to the linked color object. That reference will act as a bridge between the\u2003<code>Shape</code>\u2003and\u2003<code>Color</code>\u2003classes. From now on, adding new colors won\u2019t require changing the shape hierarchy, and vice versa.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Bridge/#abstraction-and-implementation","title":"Abstraction and Implementation","text":"<p>The GoF book\u2003\u2003introduces the terms\u2003Abstraction\u2003and\u2003Implementation\u2003as part of the Bridge definition. In my opinion, the terms sound too academic and make the pattern seem more complicated than it really is. Having read the simple example with shapes and colors, let\u2019s decipher the meaning behind the GoF book\u2019s scary words.</p> <p>Abstraction\u2003(also called\u2003interface) is a high-level control layer for some entity. This layer isn\u2019t supposed to do any real work on its own. It should delegate the work to the\u2003implementation\u2003layer (also called\u2003platform).</p> <p>Note that we\u2019re not talking about\u2003interfaces\u2003or\u2003abstract classes\u2003from your programming language. These aren\u2019t the same things.</p> <p>When talking about real applications, the abstraction can be represented by a graphical user interface (GUI), and the implementation could be the underlying operating system code (API) which the GUI layer calls in response to user interactions.</p> <p>Generally speaking, you can extend such an app in two independent directions:</p> <ul> <li>Have several different GUIs (for instance, tailored for regular customers or admins).</li> <li>Support several different APIs (for example, to be able to launch the app under Windows, Linux, and macOS).</li> </ul> <p>In a worst-case scenario, this app might look like a giant spaghetti bowl, where hundreds of conditionals connect different types of GUI with various APIs all over the code.</p> <p></p> <p>Making even a simple change to a monolithic codebase is pretty hard because you must understand the\u2003entire thing\u2003very well. Making changes to smaller, well-defined modules is much\u2003easier.</p> <p>You can bring order to this chaos by extracting the code related to specific interface-platform combinations into separate classes. However, soon you\u2019ll discover that there are\u2003lots\u2003of these classes. The class hierarchy will grow exponentially because adding a new GUI or supporting a different API would require creating more and more classes.</p> <p>Let\u2019s try to solve this issue with the Bridge pattern. It suggests that we divide the classes into two hierarchies:</p> <ul> <li>Abstraction: the GUI layer of the app.</li> <li>Implementation: the operating systems\u2019 APIs.</li> </ul> <p></p> <p>One of the ways to structure a cross-platform\u2003application.</p> <p>The abstraction object controls the appearance of the app, delegating the actual work to the linked implementation object. Different implementations are interchangeable as long as they follow a common interface, enabling the same GUI to work under Windows and Linux.</p> <p>As a result, you can change the GUI classes without touching the API-related classes. Moreover, adding support for another operating system only requires creating a subclass in the implementation hierarchy.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Bridge/#structure","title":"Structure","text":"<ol> <li>The\u2003Abstraction\u2003provides high-level control logic. It relies on the implementation object to do the actual low-level work.</li> <li>The\u2003Implementation\u2003declares the interface that\u2019s common for all concrete implementations. An abstraction can only communicate with an implementation object via methods that are declared here.     The abstraction may list the same methods as the implementation, but usually the abstraction declares some complex behaviors that rely on a wide variety of primitive operations declared by the implementation.</li> <li>Concrete Implementations\u2003contain platform-specific code.</li> <li>Refined Abstractions\u2003provide variants of control logic. Like their parent, they work with different implementations via the general implementation interface.</li> <li>Usually, the\u2003Client\u2003is only interested in working with the abstraction. However, it\u2019s the client\u2019s job to link the abstraction object with one of the implementation objects.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Bridge/#pseudocode","title":"Pseudocode","text":"<p>This example illustrates how the\u2003Bridge\u2003pattern can help divide the monolithic code of an app that manages devices and their remote controls. The\u2003<code>Device</code>\u2003classes act as the implementation, whereas the\u2003<code>Remote</code>s act as the abstraction.</p> <p></p> <p>The original class hierarchy is divided into two parts: devices and remote\u2003controls.</p> <p>The base remote control class declares a reference field that links it with a device object. All remotes work with the devices via the general device interface, which lets the same remote support multiple device types.</p> <p>You can develop the remote control classes independently from the device classes. All that\u2019s needed is to create a new remote subclass. For example, a basic remote control might only have two buttons, but you could extend it with additional features, such as an extra battery or a touchscreen.</p> <p>The client code links the desired type of remote control with a specific device object via the remote\u2019s constructor.</p> <pre><code>// The \"abstraction\" defines the interface for the \"control\"\n// part of the two class hierarchies. It maintains a reference\n// to an object of the \"implementation\" hierarchy and delegates\n// all of the real work to this object.\nclass RemoteControl is\n    protected field device: Device\n    constructor RemoteControl(device: Device) is\n        this.device = device\n    method togglePower() is\n        if (device.isEnabled()) then\n            device.disable()\n        else\n            device.enable()\n    method volumeDown() is\n        device.setVolume(device.getVolume() - 10)\n    method volumeUp() is\n        device.setVolume(device.getVolume() + 10)\n    method channelDown() is\n        device.setChannel(device.getChannel() - 1)\n    method channelUp() is\n        device.setChannel(device.getChannel() + 1)\n\n// You can extend classes from the abstraction hierarchy\n// independently from device classes.\nclass AdvancedRemoteControl extends RemoteControl is\n    method mute() is\n        device.setVolume(0)\n\n// The \"implementation\" interface declares methods common to all\n// concrete implementation classes. It doesn't have to match the\n// abstraction's interface. In fact, the two interfaces can be\n// entirely different. Typically the implementation interface\n// provides only primitive operations, while the abstraction\n// defines higher-level operations based on those primitives.\ninterface Device is\n    method isEnabled()\n    method enable()\n    method disable()\n    method getVolume()\n    method setVolume(percent)\n    method getChannel()\n    method setChannel(channel)\n\n// All devices follow the same interface.\nclass Tv implements Device is\n    // ...\n\nclass Radio implements Device is\n    // ...\n\n// Somewhere in client code.\ntv = new Tv()\nremote = new RemoteControl(tv)\nremote.togglePower()\n\nradio = new Radio()\nremote = new AdvancedRemoteControl(radio)\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/Bridge/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Bridge pattern when you want to divide and organize a monolithic class that has several variants of some functionality (for example, if the class can work with various database servers).     The bigger a class becomes, the harder it is to figure out how it works, and the longer it takes to make a change. The changes made to one of the variations of functionality may require making changes across the whole class, which often results in making errors or not addressing some critical side effects.</p> <p>The Bridge pattern lets you split the monolithic class into several class hierarchies. After this, you can change the classes in each hierarchy independently of the classes in the others. This approach simplifies code maintenance and minimizes the risk of breaking existing code.</p> </li> <li> <p>Use the pattern when you need to extend a class in several orthogonal (independent) dimensions.   The Bridge suggests that you extract a separate class hierarchy for each of the dimensions. The original class delegates the related work to the objects belonging to those hierarchies instead of doing everything on its own.</p> </li> <li>Use the Bridge if you need to be able to switch implementations at runtime.     Although it\u2019s optional, the Bridge pattern lets you replace the implementation object inside the abstraction. It\u2019s as easy as assigning a new value to a field.</li> </ul> <p>By the way, this last item is the main reason why so many people confuse the Bridge with the\u2003Strategy\u2003pattern. Remember that a pattern is more than just a certain way to structure your classes. It may also communicate intent and a problem being addressed.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Bridge/#how-to-implement","title":"How to Implement","text":"<ol> <li>Identify the orthogonal dimensions in your classes. These independent concepts could be: abstraction/platform, domain/infrastructure, front-end/back-end, or interface/implementation.</li> <li>See what operations the client needs and define them in the base abstraction class.</li> <li>Determine the operations available on all platforms. Declare the ones that the abstraction needs in the general implementation interface.</li> <li>For all platforms in your domain create concrete implementation classes, but make sure they all follow the implementation interface.</li> <li>Inside the abstraction class, add a reference field for the implementation type. The abstraction delegates most of the work to the implementation object that\u2019s referenced in that field.</li> <li>If you have several variants of high-level logic, create refined abstractions for each variant by extending the base abstraction class.</li> <li>The client code should pass an implementation object to the abstraction\u2019s constructor to associate one with the other. After that, the client can forget about the implementation and work only with the abstraction object.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Bridge/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can create platform-independent classes and apps. You might make the code more complicated by applying the pattern to a highly cohesive class. The client code works with high-level abstractions. It isn\u2019t exposed to the platform details. Open Closed Principle You can introduce new abstractions and implementations independently from each other. Single Responsibility Principle. You can focus on high-level logic in the abstraction and on platform details in the implementation.","tags":["cleancode_designpatterns"]},{"location":"hidden/Bridge/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.</li> <li>Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn\u2019t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.</li> <li>You can use Abstract Factory along with Bridge. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.</li> <li>You can combine Builder with Bridge: the director class plays the role of the abstraction, while different builders act as implementations.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Builder/","title":"Builder","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Builder/#builder","title":"Builder","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Builder/#intent","title":"Intent","text":"<p>Builder\u2003is a creational design pattern that lets you construct complex objects step by step. The pattern allows you to produce different types and representations of an object using the same construction\u2003code.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Builder/#problem","title":"Problem","text":"<p>Imagine a complex object that requires laborious, step-by-step initialization of many fields and nested objects. Such initialization code is usually buried inside a monstrous constructor with lots of parameters. Or even worse: scattered all over the client code.</p> <p></p> <p>You might make the program too complex by creating a subclass for every possible configuration of an\u2003object.</p> <p>For example, let\u2019s think about how to create a\u2003<code>House</code>\u2003object. To build a simple house, you need to construct four walls and a floor, install a door, fit a pair of windows, and build a roof. But what if you want a bigger, brighter house, with a backyard and other goodies (like a heating system, plumbing, and electrical wiring)?</p> <p>The simplest solution is to extend the base\u2003<code>House</code>\u2003class and create a set of subclasses to cover all combinations of the parameters. But eventually you\u2019ll end up with a considerable number of subclasses. Any new parameter, such as the porch style, will require growing this hierarchy even more.</p> <p>There\u2019s another approach that doesn\u2019t involve breeding subclasses. You can create a giant constructor right in the base\u2003<code>House</code>\u2003class with all possible parameters that control the house object. While this approach indeed eliminates the need for subclasses, it creates another problem.</p> <p></p> <p>The constructor with lots of parameters has its downside: not all the parameters are needed at all\u2003times.</p> <p>In most cases most of the parameters will be unused, making\u2003the constructor calls pretty ugly. For instance, only a fraction of houses have swimming pools, so the parameters related to swimming pools will be useless nine times out of ten.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Builder/#solution","title":"Solution","text":"<p>The Builder pattern suggests that you extract the object construction code out of its own class and move it to separate objects called\u2003builders.</p> <p></p> <p>The Builder pattern lets you construct complex objects step by step. The Builder doesn\u2019t allow other objects to access the product while it\u2019s being\u2003built.</p> <p>The pattern organizes object construction into a set of steps (<code>buildWalls</code>,\u2003<code>buildDoor</code>,\u2003etc.). To create an object, you execute a series of these steps on a builder object. The important part is that you don\u2019t need to call all of the steps. You can call only those steps that are necessary for producing a particular configuration of an object.</p> <p>Some of the construction steps might require different implementation when you need to build various representations of the product. For example, walls of a cabin may be built of wood, but the castle walls must be built with stone.</p> <p>In this case, you can create several different builder classes that implement the same set of building steps, but in a different manner. Then you can use these builders in the construction process (i.e., an ordered set of calls to the building steps) to produce different kinds of objects.</p> <p></p> <p>Different builders execute the same task in various\u2003ways.</p> <p>For example, imagine a builder that builds everything from wood and glass, a second one that builds everything with stone and iron and a third one that uses gold and diamonds. By calling the same set of steps, you get a regular house from the first builder, a small castle from the second and a palace from the third. However, this would only work if the client code that calls the building steps is able to interact with builders using a common interface.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Builder/#director","title":"Director","text":"<p>You can go further and extract a series of calls to the builder steps you use to construct a product into a separate class called\u2003director. The director class defines the order in which to execute the building steps, while the builder provides the implementation for those steps.</p> <p></p> <p>The director knows which building steps to execute to get a working\u2003product.</p> <p>Having a director class in your program isn\u2019t strictly necessary. You can always call the building steps in a specific order directly from the client code. However, the director class might be a good place to put various construction routines so you can reuse them across your program.</p> <p>In addition, the director class completely hides the details of product construction from the client code. The client only needs to associate a builder with a director, launch the construction with the director, and get the result from the builder.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Builder/#structure","title":"Structure","text":"<ol> <li>The\u2003Builder\u2003interface declares product construction steps that are common to all types of builders.</li> <li>Concrete Builders\u2003provide different implementations of the construction steps. Concrete builders may produce products that don\u2019t follow the common interface.</li> <li>Products\u2003are resulting objects. Products constructed by different builders don\u2019t have to belong to the same class hierarchy or interface.</li> <li>The\u2003Director\u2003class defines the order in which to call construction steps, so you can create and reuse specific configurations of products.</li> <li>The\u2003Client\u2003must associate one of the builder objects with the director. Usually, it\u2019s done just once, via parameters of the director\u2019s constructor. Then the director uses that builder object for all further construction. However, there\u2019s an alternative approach for when the client passes the builder object to the production method of the director. In this case, you can use a different builder each time you produce something with the director.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Builder/#pseudocode","title":"Pseudocode","text":"<p>This example of the\u2003Builder\u2003pattern illustrates how you can reuse the same object construction code when building different types of products, such as cars, and create the corresponding manuals for them.</p> <p></p> <p>The example of step-by-step construction of cars and the user guides that fit those car\u2003models.</p> <p>A car is a complex object that can be constructed in a hundred different ways. Instead of bloating the\u2003<code>Car</code>\u2003class with a huge constructor, we extracted the car assembly code into a separate car builder class. This class has a set of methods for configuring various parts of a car.</p> <p>If the client code needs to assemble a special, fine-tuned model of a car, it can work with the builder directly. On the other hand, the client can delegate the assembly to the director class, which knows how to use a builder to construct several of the most popular models of cars.</p> <p>You might be shocked, but every car needs a manual (seriously, who reads them?). The manual describes every feature of the car, so the details in the manuals vary across the different models. That\u2019s why it makes sense to reuse an existing construction process for both real cars and their respective manuals. Of course, building a manual isn\u2019t the same as building a car, and that\u2019s why we must provide another builder class that specializes in composing manuals. This class implements the same building methods as its car-building sibling, but instead of crafting car parts, it describes them. By passing these builders to the same director object, we can construct either a car or a manual.</p> <p>The final part is fetching the resulting object. A metal car and a paper manual, although related, are still very different things. We can\u2019t place a method for fetching results in the director without coupling the director to concrete product classes. Hence, we obtain the result of the construction from the builder which performed the job.</p> <pre><code>// Using the Builder pattern makes sense only when your products\n// are quite complex and require extensive configuration. The\n// following two products are related, although they don't have\n// a common interface.\nclass Car is\n    // A car can have a GPS, trip computer and some number of\n    // seats. Different models of cars (sports car, SUV,\n    // cabriolet) might have different features installed or\n    // enabled.\n\nclass Manual is\n    // Each car should have a user manual that corresponds to\n    // the car's configuration and describes all its features.\n\n// The builder interface specifies methods for creating the\n// different parts of the product objects.\ninterface Builder is\n    method reset()\n    method setSeats(...)\n    method setEngine(...)\n    method setTripComputer(...)\n    method setGPS(...)\n\n// The concrete builder classes follow the builder interface and\n// provide specific implementations of the building steps. Your\n// program may have several variations of builders, each\n// implemented differently.\nclass CarBuilder implements Builder is\n    private field car:Car\n\n    // A fresh builder instance should contain a blank product\n    // object which it uses in further assembly.\n    constructor CarBuilder() is\n        this.reset()\n\n    // The reset method clears the object being built.\n    method reset() is\n        this.car = new Car()\n\n    // All production steps work with the same product instance.\n    method setSeats(...) is\n        // Set the number of seats in the car.\n\n    method setEngine(...) is\n        // Install a given engine.\n\n    method setTripComputer(...) is\n        // Install a trip computer.\n\n    method setGPS(...) is\n        // Install a global positioning system.\n\n    // Concrete builders are supposed to provide their own\n    // methods for retrieving results. That's because various\n    // types of builders may create entirely different products\n    // that don't all follow the same interface. Therefore such\n    // methods can't be declared in the builder interface (at\n    // least not in a statically-typed programming language).\n    //\n    // Usually, after returning the end result to the client, a\n    // builder instance is expected to be ready to start\n    // producing another product. That's why it's a usual\n    // practice to call the reset method at the end of the\n    // `getProduct` method body. However, this behavior isn't\n    // mandatory, and you can make your builder wait for an\n    // explicit reset call from the client code before disposing\n    // of the previous result.\n    method getProduct():Car is\n        product = this.car\n        this.reset()\n        return product\n\n// Unlike other creational patterns, builder lets you construct\n// products that don't follow the common interface.\nclass CarManualBuilder implements Builder is\n    private field manual:Manual\n\n    constructor CarManualBuilder() is\n        this.reset()\n\n    method reset() is\n        this.manual = new Manual()\n\n    method setSeats(...) is\n        // Document car seat features.\n\n    method setEngine(...) is\n        // Add engine instructions.\n\n    method setTripComputer(...) is\n        // Add trip computer instructions.\n\n    method setGPS(...) is\n        // Add GPS instructions.\n\n    method getProduct():Manual is\n        // Return the manual and reset the builder.\n\n// The director is only responsible for executing the building\n// steps in a particular sequence. It's helpful when producing\n// products according to a specific order or configuration.\n// Strictly speaking, the director class is optional, since the\n// client can control builders directly.\nclass Director is\n    private field builder:Builder\n\n    // The director works with any builder instance that the\n    // client code passes to it. This way, the client code may\n    // alter the final type of the newly assembled product.\n    method setBuilder(builder:Builder)\n        this.builder = builder\n\n    // The director can construct several product variations\n    // using the same building steps.\n    method constructSportsCar(builder: Builder) is\n        builder.reset()\n        builder.setSeats(2)\n        builder.setEngine(new SportEngine())\n        builder.setTripComputer(true)\n        builder.setGPS(true)\n\n    method constructSUV(builder: Builder) is\n        // ...\n\n// The client code creates a builder object, passes it to the\n// director and then initiates the construction process. The end\n// result is retrieved from the builder object.\nclass Application is\n\n    method makeCar() is\n        director = new Director()\n\n        CarBuilder builder = new CarBuilder()\n        director.constructSportsCar(builder)\n        Car car = builder.getProduct()\n\n        CarManualBuilder builder = new CarManualBuilder()\n        director.constructSportsCar(builder)\n\n        // The final product is often retrieved from a builder\n        // object since the director isn't aware of and not\n        // dependent on concrete builders and products.\n        Manual manual = builder.getProduct()\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/Builder/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Builder pattern to get rid of a \u201ctelescoping constructor\u201d.      Say you have a constructor with ten optional parameters. Calling such a beast is very inconvenient; therefore, you overload the constructor and create several shorter versions with fewer parameters. These constructors still refer to the main one, passing some default values into any omitted parameters. <pre><code>class Pizza {\n    Pizza(int size) { ... }\n    Pizza(int size, boolean cheese) { ... }\n    Pizza(int size, boolean cheese, boolean pepperoni) { ... }\n    // ...\n</code></pre>     Creating such a monster is only possible in languages that support method overloading, such as C# or Java.</p> <p>The Builder pattern lets you build objects step by step, using only those steps that you really need. After implementing the pattern, you don\u2019t have to cram dozens of parameters into your constructors anymore.</p> </li> <li> <p>Use the Builder pattern when you want your code to be able to create different representations of some product (for example, stone and wooden houses).     The Builder pattern can be applied when construction of various representations of the product involves similar steps that differ only in the details.</p> <p>The base builder interface defines all possible construction steps, and concrete builders implement these steps to construct particular representations of the product. Meanwhile, the director class guides the order of construction.</p> </li> <li> <p>Use the Builder to construct Composite trees or other complex objects.      The Builder pattern lets you construct products step-by-step. You could defer execution of some steps without breaking the final product. You can even call steps recursively, which comes in handy when you need to build an object tree.</p> <p>A builder doesn\u2019t expose the unfinished product while running construction steps. This prevents the client code from fetching an incomplete result.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Builder/#how-to-implement","title":"How to Implement","text":"<ol> <li>Make sure that you can clearly define the common construction steps for building all available product representations. Otherwise, you won\u2019t be able to proceed with implementing the pattern.</li> <li>Declare these steps in the base builder interface.</li> <li> <p>Create a concrete builder class for each of the product representations and implement their construction steps.</p> <p>Don\u2019t forget about implementing a method for fetching the result of the construction. The reason why this method can\u2019t be declared inside the builder interface is that various builders may construct products that don\u2019t have a common interface. Therefore, you don\u2019t know what would be the return type for such a method. However, if you\u2019re dealing with products from a single hierarchy, the fetching method can be safely added to the base interface. </p> </li> <li> <p>Think about creating a director class. It may encapsulate various ways to construct a product using the same builder object.</p> </li> <li>The client code creates both the builder and the director objects. Before construction starts, the client must pass a builder object to the director. Usually, the client does this only once, via parameters of the director\u2019s class constructor. The director uses the builder object in all further construction. There\u2019s an alternative approach, where the builder is passed to a specific product construction method of the director.</li> <li>The construction result can be obtained directly from the director only if all products follow the same interface. Otherwise, the client should fetch the result from the builder.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Builder/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can construct objects step-by-step, defer construction steps or run steps recursively. The overall complexity of the code increases since the pattern requires creating multiple new classes. You can reuse the same construction code when building various representations of products. Single Responsibility Principle. You can isolate complex construction code from the business logic of the product.","tags":["cleancode_designpatterns"]},{"location":"hidden/Builder/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).</li> <li>Builder focuses on constructing complex objects step by step. Abstract Factory specializes in creating families of related objects. Abstract Factory returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.</li> <li>You can use Builder when creating complex Composite trees because you can program its construction steps to work recursively.</li> <li>You can combine Builder with Bridge: the director class plays the role of the abstraction, while different builders act as implementations.</li> <li>Abstract Factories, Builders and Prototypes can all be implemented as Singletons.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Chain%20of%20Responsibility/","title":"Chain of Responsibility","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Chain%20of%20Responsibility/#chain-of-responsibility","title":"Chain of Responsibility","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Chain%20of%20Responsibility/#intent","title":"Intent","text":"<p>Chain of Responsibility\u2003is a behavioral design pattern that lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the\u2003chain.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Chain%20of%20Responsibility/#problem","title":"Problem","text":"<p>Imagine that you\u2019re working on an online ordering system. You want to restrict access to the system so only authenticated users can create orders. Also, users who have administrative permissions must have full access to all orders.</p> <p>After a bit of planning, you realized that these checks must be performed sequentially. The application can attempt to authenticate a user to the system whenever it receives a request that contains the user\u2019s credentials. However, if those credentials aren\u2019t correct and authentication fails, there\u2019s no reason to proceed with any other checks.</p> <p></p> <p>The request must pass a series of checks before the ordering system itself can handle\u2003it.</p> <p>During the next few months, you implemented several more of those sequential checks.</p> <ul> <li> <p>One of your colleagues suggested that it\u2019s unsafe to pass raw data straight to the ordering system. So you added an extra validation step to sanitize the data in a request.</p> </li> <li> <p>Later, somebody noticed that the system is vulnerable to brute force password cracking. To negate this, you promptly added a check that filters repeated failed requests coming from the same IP address.</p> </li> <li> <p>Someone else suggested that you could speed up the system by returning cached results on repeated requests containing the same data. Hence, you added another check which lets the request pass through to the system only if there\u2019s no suitable cached response.</p> </li> </ul> <p></p> <p>The bigger the code grew, the messier it\u2003became.</p> <p>The code of the checks, which had already looked like a mess, became more and more bloated as you added each new feature. Changing one check sometimes affected the others. Worst of all, when you tried to reuse the checks to protect other components of the system, you had to duplicate some of the code since those components required some of the checks, but not all of them.</p> <p>The system became very hard to comprehend and expensive to maintain. You struggled with the code for a while, until one day you decided to refactor the whole thing.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Chain%20of%20Responsibility/#solution","title":"Solution","text":"<p>Like many other behavioral design patterns, the\u2003Chain of Responsibility\u2003relies on transforming particular behaviors into stand-alone objects called\u2003handlers. In our case, each check should be extracted to its own class with a single method that performs the check. The request, along with its data, is passed to this method as an argument.</p> <p>The pattern suggests that you link these handlers into a chain. Each linked handler has a field for storing a reference to the next handler in the chain. In addition to processing a request, handlers pass the request further along the chain. The request travels along the chain until all handlers have had a chance to process it.</p> <p>Here\u2019s the best part: a handler can decide not to pass the request further down the chain and effectively stop any further processing.</p> <p>In our example with ordering systems, a handler performs the processing and then decides whether to pass the request further down the chain. Assuming the request contains the right data, all the handlers can execute their primary behavior, whether it\u2019s authentication checks or caching.</p> <p></p> <p>Handlers are lined up one by one, forming a\u2003chain.</p> <p>However, there\u2019s a slightly different approach (and it\u2019s a bit more canonical) in which, upon receiving a request, a handler decides whether it can process it. If it can, it doesn\u2019t pass the request any further. So it\u2019s either only one handler that processes the request or none at all. This approach is very common when dealing with events in stacks of elements within a graphical user interface.</p> <p>For instance, when a user clicks a button, the event propagates through the chain of GUI elements that starts with the button, goes along its containers (like forms or panels), and ends up with the main application window. The event is processed by the first element in the chain that\u2019s capable of handling it. This example is also noteworthy because it shows that a chain can always be extracted from an object tree.</p> <p></p> <p>A chain can be formed from a branch of an object\u2003tree.</p> <p>It\u2019s crucial that all handler classes implement the same interface. Each concrete handler should only care about the following one having the\u2003<code>execute</code>\u2003method. This way you can compose chains at runtime, using various handlers without coupling your code to their concrete classes.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Chain%20of%20Responsibility/#real-world-analogy","title":"Real-World Analogy","text":"<p>A call to tech support can go through multiple\u2003operators.</p> <p>You\u2019ve just bought and installed a new piece of hardware on your computer. Since you\u2019re a geek, the computer has several operating systems installed. You try to boot all of them to see whether the hardware is supported. Windows detects and enables the hardware automatically. However, your beloved Linux refuses to work with the new hardware. With a small flicker of hope, you decide to call the tech-support phone number written on the box.</p> <p>The first thing you hear is the robotic voice of the autoresponder. It suggests nine popular solutions to various problems, none of which are relevant to your case. After a while, the robot connects you to a live operator.</p> <p>Alas, the operator isn\u2019t able to suggest anything specific either. He keeps quoting lengthy excerpts from the manual, refusing to listen to your comments. After hearing the phrase \u201chave you tried turning the computer off and on again?\u201d for the 10th time, you demand to be connected to a proper engineer.</p> <p>Eventually, the operator passes your call to one of the engineers, who had probably longed for a live human chat for hours as he sat in his lonely server room in the dark basement of some office building. The engineer tells you where to download proper drivers for your new hardware and how to install them on Linux. Finally, the solution! You end the call, bursting with joy.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Chain%20of%20Responsibility/#structure","title":"Structure","text":"<ol> <li>The\u2003Handler\u2003declares the interface, common for all concrete handlers. It usually contains just a single method for handling requests, but sometimes it may also have another method for setting the next handler on the chain.</li> <li> <p>The\u2003Base Handler\u2003is an optional class where you can put the boilerplate code that\u2019s common to all handler classes.</p> <p>Usually, this class defines a field for storing a reference to the next handler. The clients can build a chain by passing a handler to the constructor or setter of the previous handler. The class may also implement the default handling behavior: it can pass execution to the next handler after checking for its existence.</p> </li> <li> <p>Concrete Handlers\u2003contain the actual code for processing requests. Upon receiving a request, each handler must decide whether to process it and, additionally, whether to pass it along the chain.</p> <p>Handlers are usually self-contained and immutable, accepting all necessary data just once via the constructor.</p> </li> <li> <p>The\u2003Client\u2003may compose chains just once or compose them dynamically, depending on the application\u2019s logic. Note that a request can be sent to any handler in the chain\u2014it doesn\u2019t have to be the first one.    </p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Chain%20of%20Responsibility/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Chain of Responsibility\u2003pattern is responsible for displaying contextual help information for active GUI elements.</p> <p></p> <p>The GUI classes are built with the Composite pattern. Each element is linked to its container element. At any point, you can build a chain of elements that starts with the element itself and goes through all of its container\u2003elements.</p> <p>The application\u2019s GUI is usually structured as an object tree. For example, the\u2003<code>Dialog</code>\u2003class, which renders the main window of the app, would be the root of the object tree. The dialog contains\u2003<code>Panels</code>, which might contain other panels or simple low-level elements like\u2003<code>Buttons</code>\u2003and\u2003<code>TextFields</code>.</p> <p>A simple component can show brief contextual tooltips, as long as the component has some help text assigned. But more complex components define their own way of showing contextual help, such as showing an excerpt from the manual or opening a page in a browser.</p> <p></p> <p>That\u2019s how a help request traverses GUI\u2003objects.</p> <p>When a user points the mouse cursor at an element and presses the\u2003<code>F1</code>\u2003key, the application detects the component under the pointer and sends it a help request. The request bubbles up through all the element\u2019s containers until it reaches the element that\u2019s capable of displaying the help information.</p> <p>// The handler interface declares a method for executing a // request. interface ComponentWithContextualHelp is     method showHelp()</p> <p>// The base class for simple components. abstract class Component implements ComponentWithContextualHelp is     field tooltipText: string</p> <pre><code>    // The component's container acts as the next link in the\n    // chain of handlers.\n    protected field container: Container\n\n    // The component shows a tooltip if there's help text\n    // assigned to it. Otherwise it forwards the call to the\n    // container, if it exists.\n    method showHelp() is\n        if (tooltipText != null)\n            // Show tooltip.\n        else\n            container.showHelp()\n\n// Containers can contain both simple components and other\n// containers as children. The chain relationships are\n// established here. The class inherits showHelp behavior from\n// its parent.\nabstract class Container extends Component is\n    protected field children: array of Component\n\n    method add(child) is\n        children.add(child)\n        child.container = this\n\n// Primitive components may be fine with default help\n// implementation...\nclass Button extends Component is\n    // ...\n\n// But complex components may override the default\n// implementation. If the help text can't be provided in a new\n// way, the component can always call the base implementation\n// (see Component class).\nclass Panel extends Container is\n    field modalHelpText: string\n\n    method showHelp() is\n        if (modalHelpText != null)\n            // Show a modal window with the help text.\n        else\n            super.showHelp()\n\n// ...same as above...\nclass Dialog extends Container is\n    field wikiPageURL: string\n\n    method showHelp() is\n        if (wikiPageURL != null)\n            // Open the wiki help page.\n        else\n            super.showHelp()\n\n// Client code.\nclass Application is\n    // Every application configures the chain differently.\n    method createUI() is\n        dialog = new Dialog(\"Budget Reports\")\n        dialog.wikiPageURL = \"http://...\"\n        panel = new Panel(0, 0, 400, 800)\n        panel.modalHelpText = \"This panel does...\"\n        ok = new Button(250, 760, 50, 20, \"OK\")\n        ok.tooltipText = \"This is an OK button that...\"\n        cancel = new Button(320, 760, 50, 20, \"Cancel\")\n        // ...\n        panel.add(ok)\n        panel.add(cancel)\n        dialog.add(panel)\n\n    // Imagine what happens here.\n    method onF1KeyPress() is\n        component = this.getComponentAtMouseCoords()\n        component.showHelp()\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/Chain%20of%20Responsibility/#applicability","title":"Applicability","text":"<ul> <li>Use the Chain of Responsibility pattern when your program is expected to process different kinds of requests in various ways, but the exact types of requests and their sequences are unknown beforehand.   The pattern lets you link several handlers into one chain and, upon receiving a request, \u201cask\u201d each handler whether it can process it. This way all handlers get a chance to process the request.</li> <li>Use the pattern when it\u2019s essential to execute several handlers in a particular order.   Since you can link the handlers in the chain in any order, all requests will get through the chain exactly as you planned.</li> <li>Use the CoR pattern when the set of handlers and their order are supposed to change at runtime.   If you provide setters for a reference field inside the handler classes, you\u2019ll be able to insert, remove or reorder handlers dynamically.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Chain%20of%20Responsibility/#how-to-implement","title":"How to Implement","text":"<ol> <li> <p>Declare the handler interface and describe the signature of a method for handling requests.</p> <p>Decide how the client will pass the request data into the method. The most flexible way is to convert the request into an object and pass it to the handling method as an argument.</p> </li> <li> <p>To eliminate duplicate boilerplate code in concrete handlers, it might be worth creating an abstract base handler class, derived from the handler interface.</p> <p>This class should have a field for storing a reference to the next handler in the chain. Consider making the class immutable. However, if you plan to modify chains at runtime, you need to define a setter for altering the value of the reference field.</p> <p>You can also implement the convenient default behavior for the handling method, which is to forward the request to the next object unless there\u2019s none left. Concrete handlers will be able to use this behavior by calling the parent method.</p> </li> <li> <p>One by one create concrete handler subclasses and implement their handling methods. Each handler should make two decisions when receiving a request:</p> <ul> <li>Whether it\u2019ll process the request.</li> <li> <p>Whether it\u2019ll pass the request along the chain. 4.  The client may either assemble chains on its own or receive pre-built chains from other objects. In the latter case, you must implement some factory classes to build chains according to the configuration or environment settings. 5.  The client may trigger any handler in the chain, not just the first one. The request will be passed along the chain until some handler refuses to pass it further or until it reaches the end of the chain. 6.  Due to the dynamic nature of the chain, the client should be ready to handle the following scenarios:</p> </li> <li> <p>The chain may consist of a single link.</p> </li> <li>Some requests may not reach the end of the chain.</li> <li>Others may reach the end of the chain unhandled.</li> </ul> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Chain%20of%20Responsibility/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can control the order of request handling. Some requests may end up unhandled. Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform operations. Open Closed Principle. You can introduce new handlers into the app without breaking the existing client code.","tags":["cleancode_designpatterns"]},{"location":"hidden/Chain%20of%20Responsibility/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:<ul> <li>Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.</li> <li>Command establishes unidirectional connections between senders and receivers.</li> <li>Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.</li> <li>Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.</li> </ul> </li> <li>Chain of Responsibility is often used in conjunction with Composite. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.</li> <li> <p>Handlers in Chain of Responsibility can be implemented as Commands. In this case, you can execute a lot of different operations over the same context object, represented by a request.</p> <p>However, there\u2019s another approach, where the request itself is a Command object. In this case, you can execute the same operation in a series of different contexts linked into a chain.</p> </li> <li> <p>Chain of Responsibility and Decorator have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences.</p> <p>The CoR handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various Decorators can extend the object\u2019s behavior while keeping it consistent with the base interface. In addition, decorators aren\u2019t allowed to break the flow of the request.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Chili%20Con%20Carne/","title":"Chili Con Carne","text":"","tags":["cooking","mexican"]},{"location":"hidden/Chili%20Con%20Carne/#chili-con-carne-ala-koder","title":"Chili Con Carne (ala Koder)","text":"","tags":["cooking","mexican"]},{"location":"hidden/Chili%20Con%20Carne/#zutaten","title":"Zutaten","text":"<ul> <li>600g Hackfleisch</li> <li>3x Dosen Tomaten \u201cgesteckt\u201d</li> <li>3x Dosen Kidneybohnen</li> <li>1x Glas Chili So\u00dfe</li> <li>1x Packung \u201cChili-Con-Carne\u201d-Gew\u00fcrz</li> <li>1x Dose Wei\u00dfe Bohnen</li> <li>Suppengem\u00fcse</li> <li>Salz</li> <li>Pfeffer</li> <li>Chiligew\u00fcrz und andere Gew\u00fcrze (je nach Bedarf)</li> <li>1x Zwiebel</li> <li>optional: K\u00e4se zum Reiben und Schmand</li> </ul>","tags":["cooking","mexican"]},{"location":"hidden/Chili%20Con%20Carne/#ablauf","title":"Ablauf","text":"<ol> <li>Zwiebeln in einer Pfanne anbraten und Hackfleisch hinzugeben</li> <li>Dann alle anderen Zutaten in einen Topf geben und umr\u00fchren</li> <li>Hackfleisch ebenfalls in den Topf geben</li> </ol> <p>Optimaler Geschmack</p> <p>Am besten sollte das Gericht am Vortag zum Verzehr gekocht werden, da es die Nacht \u00fcber durchziehen muss.  Am n\u00e4chsten Tag kann das Gericht dann wieder erhitzt und serviert werden.</p>","tags":["cooking","mexican"]},{"location":"hidden/Chunking/","title":"Chunking","text":"<ul> <li>Zusammenfassen elementarer Informationen</li> <li>Bei unvermeidbaren Wartezeiten, Feedback geben</li> <li>Tests zum Verstehen realer Nutzungskontexte</li> </ul>","tags":["is"]},{"location":"hidden/Clean%20Code%20Developer/","title":"Clean Code Developer","text":"","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#clean-code-developer","title":"Clean Code Developer","text":"","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#die-grade","title":"Die Grade","text":"<ul> <li>Roter Grad</li> <li>Orangener Grad</li> <li>Gelber Grad</li> <li>Gr\u00fcner Grad</li> <li>Blauer Grad</li> <li>Wei\u00dfer Grad</li> </ul>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#wertesystem","title":"Wertesystem","text":"","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#wandelbarkeit","title":"Wandelbarkeit","text":"<p>Wir m\u00f6chten diesen Abschnitt mit einer provokant anmutenden These beginnen:</p> <p>Es gibt keine Softwarewartung!</p> <p>Wartung ist ein pro-aktiver Vorgang. In Fertigungsanlagen werden regelm\u00e4\u00dfig Teile getauscht, bevor diese kaputt sind. Sie werden getauscht, weil Erfahrungswerte zeigen, dass die Zuverl\u00e4ssigkeit beim Weiterbetrieb unter einen kritischen Wert sinken w\u00fcrde. Bevor also die ganze Anlage zum Stillstand kommt, werden die kritischen Teile rechtzeitig vorher getauscht. Jeder Autobesitzer wei\u00df, dass er regelm\u00e4\u00dfig einen \u00d6lwechsel vornehmen lassen muss. Nicht etwa, weil das \u00d6l zu dem Zeitpunkt aufgebraucht w\u00e4re, nicht einmal deshalb, weil das \u00d6l zu dem Zeitpunkt bereits v\u00f6llig wirkungslos w\u00e4re. Nein, es wird getauscht, weil Erfahrungswerte des Herstellers zeigen, dass der Motor durch den rechtzeitigen \u00d6lwechsel geschont wird und somit l\u00e4nger h\u00e4lt.</p> <p>All das gibt es bei Software nicht. Software ist so, wie sie ist. Meist enth\u00e4lt sie Fehler. Doch auch diese Fehler sind so, wie sie sind. Man kann nichts pro-aktiv unternehmen, um den Zustand der Software zu verbessern.</p> <p>Nat\u00fcrlich gibt es beim Betrieb der Software pro-aktive Handlungen. So sollte vielleicht regelm\u00e4\u00dfig gepr\u00fcft werden, ob die Logdateien noch ausreichend freien Platz auf der Festplatte lassen, ob eine Datenbank \u00fcberl\u00e4uft oder der Speicher sich zunehmend f\u00fcllt. Aber die Software an sich kann nicht pro-aktiv gewartet werden. Jegliche \u00c4nderung oder Erweiterung findet statt, um einen Fehler zu beseitigen oder neue bzw. ge\u00e4nderte Anforderungen umzusetzen.</p> <p>Damit \u00c4nderungen m\u00f6glich sind, muss die Software eine innere Struktur haben, die solche \u00c4nderungen beg\u00fcnstigt. Dies bezeichnen wir als Wandelbarkeit. Software wird in der Regel \u00fcber lange Zeitr\u00e4ume betrieben. W\u00e4hrend dieser Zeit \u00e4ndern sich die Rahmenbedingungen, m\u00fcssen Features erg\u00e4nzt werden. Im Idealfall kostet die Implementierung eines Features einen festen Betrag, der unabh\u00e4ngig davon ist, wann das Feature realisiert wird.</p> <p>In der Praxis steigt der Preis allerdings f\u00fcr ein Feature, je sp\u00e4ter es realisiert wird. Am Anfang sind Features preiswert, am Ende ist es gar nicht mehr m\u00f6glich Features zu erg\u00e4nzen, weil niemand mehr durchblickt. Die Software wird weggeworfen und neu entwickelt. Bis man an diesem Punkt ankommt, steigen die Kosten exponentiell. Das gemeine an exponentiellem Wachstum sind zwei Dinge: 1.) Anfangs erkennt man kaum, dass die Kosten anwachsen. Die Steigerungen sind moderat. 2.) Wenn man dann erkennt, dass die Kosten steigen, ist es zu sp\u00e4t. Die Steigerung schreitet dann pl\u00f6tzlich so schnell voran, dass ein Gegensteuern nicht mehr m\u00f6glich ist.</p> <p>Je einfacher die Software an ge\u00e4nderte Rahmenbedingungen angepasst werden kann, desto h\u00f6her ist ihre Wandelbarkeit. Doch Wandelbarkeit erh\u00e4lt man nicht nachtr\u00e4glich. Sie muss von vorneherein ber\u00fccksichtigt werden. Die Software muss darauf ausgelegt sein.</p> <p>Dazu ein Beispiel: Klassen sollten genau eine Verantwortlichkeit haben. Ist eine Klasse f\u00fcr mehr als eine Sache zust\u00e4ndig, ist es schwerer sie zu \u00fcberblicken. Das behindert \u00c4nderungen, denn diese bedingen, dass man den Quellcode versteht, der ge\u00e4ndert werden soll. Des weiteren steigt die Kopplung zwischen den Klassen. Pl\u00f6tzlich h\u00e4ngt alles mit allem zusammen. Dies kann nur verhindert werden, indem Funktionseinheiten eine klar definierte Verantwortlichkeit haben und man die Kopplung im Blick beh\u00e4lt. Hat man in einem Softwaresystem eine Reihe von Klassen angesammelt, die jeweils f\u00fcr mehrere Dinge verantwortlich sind, ist es im Nachhinein nur schwer m\u00f6glich, diesen Zustand zu beseitigen. Die Kopplung ist so gro\u00df, dass es schwer f\u00e4llt, einzelne Funktionseinheiten heraus zu l\u00f6sen. Sollen in diesem Dickicht neue Features realisiert werden, ist das sehr aufw\u00e4ndig. Wenn nicht rechtzeitig begonnen wird, das Dickicht zu lichten, wird die Situation mit jedem mal schlimmer. Ab einem gewissen Punkt ist es dann kaum noch m\u00f6glich, neue Features zu erg\u00e4nzen. Der Super-GAU der Softwareentwicklung.</p> <p>Wir meinen, dass es soweit nicht kommen muss. Ber\u00fccksichtigt man Wandelbarkeit von vorne herein, kann Software \u00fcber lange Zeitr\u00e4ume weiter entwickelt werden. Die Kosten pro Feature m\u00f6gen dabei im Laufe der Zeit leicht ansteigen. Aber keinesfalls exponentiell!</p>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#korrektheit","title":"Korrektheit","text":"<p>Software muss funktional korrekt sein. Ein Buchhaltungsprogramm muss die Buchungen ordnungsgem\u00e4\u00df verbuchen, eine Tabellenkalkulation muss richtig rechnen. Und auch die nicht-funktionalen Anforderungen m\u00fcssen erf\u00fcllt sein. Das Programm muss schonend mit Ressourcen wie Speicher, Prozessorzeit, Plattenplatz, etc. umgehen, die Antwortzeiten m\u00fcssen in einem definierten Rahmen liegen. Erst wenn alle Anforderungen erf\u00fcllt sind, ist die erstellte Software korrekt.</p> <p>Dass Korrektheit erforderlich ist, wird niemand bestreiten. Doch die Frage ist, was konkret daf\u00fcr getan wird. Es reicht unserer Ansicht nach nicht aus, Software nach deren Erstellung durch eine Testabteilung zu leiten, deren Aufgabe es ist, Fehler zu finden. Wir meinen, Korrektheit muss bereits w\u00e4hrend der Entwicklung ber\u00fccksichtigt werden. Bereits die Entwickler m\u00fcssen sich mit der Frage der Korrektheit auseinandersetzen. Und damit sie das \u00fcberhaupt k\u00f6nnen, muss ihnen klar sein, was die Anforderungen sind. Schon daran mangelt es zu oft. Entwickler werden beauftragt, ein Feature zu implementieren, ohne ihnen pr\u00e4zise zu sagen, was die Abnahmekriterien f\u00fcr das Feature sind. Doch hier geht es nicht darum, Schwarzer Peter zu spielen und einen Schuldigen au\u00dferhalb der Entwicklungsabteilungen zu suchen. Schlie\u00dflich ist es die Aufgabe der Entwickler, bei unklaren Anforderungen nachzufragen, statt in ihre Glaskugel zu schauen.</p> <p>Verglichen mit dem Automobilbau steht die Softwareentwicklung beim Thema Korrektheit schlecht da. Ein Auto besteht aus vielen Teilen, deren Korrektheit jeweils einzeln nachgewiesen und \u00fcberpr\u00fcft werden kann. Stellen Sie sich vor, Sie m\u00fcssten zur Fehlersuche mit einem Me\u00dfger\u00e4t in der Hand auf der Motorhaube des Autos sitzen, um dort verfolgen zu k\u00f6nnen, was sich in der Maschine abspielt. Mit Tempo 200 auf der Autobahn. Kommt Ihnen komisch vor? Ein Debugger wird in vielen F\u00e4llen genau so eingesetzt. Das halten wir f\u00fcr falsch.</p>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#produktionseffizienz","title":"Produktionseffizienz","text":"<p>Am Ende spielen nat\u00fcrlich auch die Entwicklungszeit und der Preis der Software eine Rolle. Und der ist h\u00f6her, wenn die Produktion der Software nicht effizient erfolgt. Das beginnt bei manuellen Arbeitsschritten, die nicht automatisiert werden und endet bei hohen Fehlerraten die mehrmaliges Nachbessern erfordern. In letzter Konsequenz bedeutet Produktionseffizienz, dass die Software \u00fcber Jahre oder gar Jahrzehnte weiterentwickelt werden kann, statt irgendwann wieder von vorne beginnen zu m\u00fcssen. Gleichzeitig reduziert eine hohe Produktionseffizienz die Anf\u00e4lligkeit f\u00fcr Fehler.</p> <p>Die Produktionseffizienz als Wert ist ferner wichtig, um die anderen Werte in ein ma\u00dfvolles Verh\u00e4ltnis zu setzen. Wer unendlich viel Aufwand f\u00fcr die Korrektheit treibt, macht am Ende auch etwas falsch.</p>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#kontinuierliche-verbesserung","title":"Kontinuierliche Verbesserung","text":"<p>Ohne R\u00fcckschau ist keine Weiterentwicklung m\u00f6glich. Nur wer reflektiert, wie er eine Aufgabenstellung gel\u00f6st hat, kann feststellen, ob der gew\u00e4hlte Weg einfach oder beschwerlich war. Lernen basiert auf Reflexion.</p> <p>In einer jungen Wissenschaft wie der Informatik ist es wichtig, stets neue Erkenntnisse zu ber\u00fccksichtigen. Dazu ist Reflexion auf allen Ebenen erforderlich. Angefangen beim Reflektieren \u00fcber die Implementation beim Pair Programming oder Code Review, das t\u00e4gliche Reflektieren des Teams, die Reflexion nach jeder Iteration, bis hin zur Reflexion der gesamten Branche \u00fcber ihr Tun. Ohne Reflexion keine Weiterentwicklung.</p>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#prinzipien-und-praktiken","title":"Prinzipien und Praktiken","text":"<p>Das Wertesystem leitet Clean Code Developer in ihrer t\u00e4glichen Arbeit. Es enth\u00e4lt keine Probleml\u00f6sungen, sondern definiert Rahmenbedingungen f\u00fcr Probleml\u00f6sungen. Die vier Werte sind f\u00fcr eine konkrete allt\u00e4gliche Umsetzung jedoch zu abstrakt. Daher haben wir Bausteine zusammengetragen, die jeweils mindestens einen der Werte bef\u00f6rdern. Diese konkreten Bausteine teilen wir in zwei Kategorien: Prinzipien und Praktiken.</p>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#prinzipien","title":"Prinzipien","text":"<p>Die Clean Code Developer Prinzipien sind die grundlegenden Gesetzm\u00e4\u00dfigkeiten f\u00fcr die Strukturierung von Software. Sie sind entweder zu anderen Rahmenbedingungen orthogonal oder ihnen \u00fcbergeordnet. Code sollte immer im Einklang mit einer maximalen Zahl von Prinzipien sein. Nat\u00fcrlich haben sie nicht \u201edie Macht\u201c von Naturgesetzen, denen niemand zuwiderhandeln kann. Aber sie sind mit ihnen in Bezug auf die Softwareentwicklung gleichauf in ihrer Fundamentalit\u00e4t. Wo ein Prinzip nicht eingehalten wird, tritt also nicht unbedingt sofort ein negativer Effekt ein, aber kurz- bis mittelfristig bleiben Zuwiderhandlungen nicht ohne Schmerz. Der dr\u00fcckt sich in M\u00fche beim Codeverst\u00e4ndnis aus oder im hohen Aufwand, um \u00c4nderungen einzubringen. Ultimativ ist er, wenn Software nicht mehr evolvierbar ist. Ob ein Prinzip eingehalten wurde, kann man dem Code immer ansehen.</p>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#praktiken","title":"Praktiken","text":"<p>Praktiken sind Techniken und Methoden, die st\u00e4ndig zum Einsatz kommen. Sie beschreiben, was Clean Code Developer praktisch tun. Motto der Praktiken: \u201eTue es immer so. Jeden Tag, jederzeit.\u201c Es sind handfeste Handlungsanweisungen, die manchmal des Einsatzes von Werkzeugen bed\u00fcrfen. Ob einer Praktik gefolgt wird, kann man dem Code nicht immer ansehen.</p>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#die-tugenden","title":"Die Tugenden","text":"","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#prinzipielles","title":"Prinzipielles","text":"","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#1-schatze-variation-value-variation-vv","title":"1. Sch\u00e4tze Variation (Value Variation (VV))","text":"<p>Werte: Wandelbarkeit, Kontinuierliche Verbesserung</p>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#2-tue-nur-das-notigste-do-only-what-s-neccessary-down","title":"2. Tue nur das N\u00f6tigste (Do Only What\u00b4s Neccessary (DOWN))","text":"<p>Werte: Produktionseffizienz, Wandelbarkeit</p> <ul> <li>Vorsicht vor Optimierungen! (Prinzip des\u2003roten Grades)</li> <li>YAGNI (Prinzip des\u2003blauen Grades)</li> <li>KISS (Prinzip des\u2003roten Grades)</li> </ul>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#3-isoliere-aspekte-isolate-aspects-ia","title":"3. Isoliere Aspekte (Isolate Aspects (IA))","text":"<p>Werte: </p> <ul> <li>Wandelbarkeit</li> <li>DRY</li> <li>Separation of Concerns</li> <li>Single Level of Abstraction</li> <li>Single Responsibility Principle</li> <li>Interface Segragation Principle</li> <li>Design and Implementation do not Overlapp</li> <li>Integration Operation Segregation Principle (IOSP)</li> </ul>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#4-minimiere-abhangigkeiten-minimize-dependencies-md","title":"4. Minimiere Abh\u00e4ngigkeiten (Minimize Dependencies (MD))","text":"<p>Werte:</p> <ul> <li>Wandelbarkeit</li> <li>Dependency Inversion Principle</li> <li>Information Hiding Principle</li> <li>Law of Demeter</li> <li>Tell do not ask</li> </ul>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#5-halte-versprechen-ein-honor-pledges-hp","title":"5. Halte Versprechen ein (Honor Pledges (HP))","text":"<p>Werte: </p> <ul> <li>Wandelbarkeit oder auch: Minimize Surprises</li> <li>Liskov Substitution Principle</li> <li>Principle of Least Astonishment</li> <li>Implementation spiegelt Entwurf</li> <li>Favour Composition over Inheritance (FCoI)</li> </ul>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#praktisches","title":"Praktisches","text":"","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#1-umarme-unsicherheit-embrace-uncertainty-eu","title":"1. Umarme Unsicherheit (Embrace Uncertainty (EU))","text":"<p>Werte: Wandelbarkeit, Kontinuierliche Verbesserung</p> <p>Ein Versionskontrollsystem einsetzenAutomatisierte IntegrationstestsAutomatisierte Unit TestsMockups (Testattrappen)Continuous IntegrationInversion of Control Container</p>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#2-fokussiere-focus-f","title":"2. Fokussiere (Focus (F))","text":"<p>Werte: Produktionseffizienz</p> <p>KomponentenorientierungTest firstLimit WIP // neu</p>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#3-wertschatze-qualitat-value-quality-vq","title":"3. Wertsch\u00e4tze Qualit\u00e4t (Value Quality (VQ))","text":"<p>Werte: Produktionseffizienz</p> <p>Akzeptiere nur hohe Qualit\u00e4t // neuAutomatisierte Unit TestsReviews</p>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#4-mach-fertig-get-things-done-gtd","title":"4. Mach fertig (Get Things Done (GTD))","text":"<p>Werte: Produktionseffizienz</p> <p>Iterative EntwicklungContinuous DeliveryLimit WIP</p>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#5-halte-ordnung-stay-clean-sc","title":"5. Halte Ordnung (Stay Clean (SC))","text":"<p>Werte: Wandelbarkeit, Korrektheit, Produktionseffizienz</p> <p>Die Pfadfinderregel beachtenKomplexe RefaktorisierungenEinfache Refaktorisierungsmuster anwendenStatische Codeanalyse (Metriken)Code Coverage AnalyseSource Code Konventionen // ehemals Prinzip</p>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#6-bleib-am-ball-keep-moving-km","title":"6. Bleib am Ball (Keep Moving (KM))","text":"<p>Werte: Kontinuierliche Verbesserung</p> <p>Lesen, Lesen, LesenTeilnahme an FachveranstaltungenErfahrung weitergebenT\u00e4glich reflektierenRoot Cause AnalysisMessen von FehlernIssue TrackingRegelm\u00e4\u00dfige Retrospektiven // neu</p>","tags":["cleancode"]},{"location":"hidden/Clean%20Code%20Developer/#source","title":"Source","text":"<p>Clean Code Developer</p>","tags":["cleancode"]},{"location":"hidden/Clean%20Code/","title":"Clean Code","text":"","tags":["cleancode"]},{"location":"hidden/Clean%20Code/#clean-code","title":"Clean Code","text":"<p>Clean Code sind Praktiken, welche die Qualit\u00e4t des Codes durch BestPractices verbessern sollen.</p> <p>Die Prinzipien basieren Haupts\u00e4chlich auf dem Buch Clean Code (Book) von Robert C. Martin.</p> <p>Ein Praktischer Ansatz um Clean Code zu meistern ist der Clean Code Developer</p>","tags":["cleancode"]},{"location":"hidden/Code%20Coverage%20Analysis/","title":"Code Coverage Analysis","text":"","tags":["cleancode"]},{"location":"hidden/Code%20Coverage%20Analysis/#code-coverage-analysis","title":"Code Coverage Analysis","text":"<p>Warum? Traue nur Tests, von denen du wei\u00dft, dass sie auch wirklich das Testareal abdecken.</p> <p>Unit Tests sollten nach M\u00f6glichkeit alle Pfade durch unseren Code abdecken. Nur so gewinnen wir das Vertrauen, dass der Code korrekt arbeitet. Um in Erfahrung zu bringen, welche Codebereiche bislang nicht durch Tests abgedeckt sind, bedienen wir uns der\u2003Code Coverage Analyse. Diese dient dazu, Bereiche im Code aufzudecken, die noch nicht w\u00e4hrend der automatisierten Tests ausgef\u00fchrt werden.</p> <p>Unit Tests sollten eigentlich 100% des zu testenden Codes abdecken. Zwar bedeutet das nicht automatisch, dass gen\u00fcgend Tests existieren, doch weniger als 100% Code Coverage zeigen an, dass es noch Taschen von Code gibt, \u00fcber die \u00fcberhaupt noch keine Korrektheitsaussage gemacht werden kann. 100% Codeabdeckung sind deshalb immer anzustreben.</p> <p>In der Praxis zeigt es sich jedoch, dass 100% Codeabdeckung nicht immer mit unmittelbar vertretbarem Aufwand erreicht werden k\u00f6nnen. Wie auch sonst im Leben kann die M\u00fche f\u00fcr die letzten 2,3,4 Prozent \u00fcberproportional wachsen. Deshalb kann es nach genauer Analyse der Abdeckungslage akzeptabel sein, mit weniger als 100% zufrieden zu sein.</p> <p>Unterhalb von 90% ist die Abdeckung dann allerdings so l\u00f6chrig, dass sie als unprofessionell anzusehen ist. Wer also mit automatischen Tests beginnt, sollte immer auch gleichzeitig die Codeabdeckung messen. Sonst l\u00e4sst sich keine Aussage \u00fcber die Qualit\u00e4t der Tests machen.</p> <p>F\u00fcr die Messung der Code\u00fcberdeckung gibt es zwei einfache Kennzahlen, die als C0- und C1-Kennzahlen bezeichnet werden. Die C0-Kennzahl misst die Anweisungs\u00fcberdeckung, wogegen die C1-Kennzahl die Entscheidungs\u00fcberdeckung bzw. die Zweig\u00fcberdeckung misst.</p> <pre><code>C0 = (Anzahl der getesteten Anweisungen / Anzahl der gesamten Anweisungen) * 100%\n</code></pre> <pre><code>C1 = (Anzahl der getesteten Entscheidungen bzw. Zweige / Anzahl der gesamten Entscheidungen bzw. Zweige) * 100%\n</code></pre> <p>C1 ist dabei die st\u00e4rkere Kennzahl, da 100% Entscheidungs\u00fcberdeckung bzw. Zweig\u00fcberdeckung 100% Anweisungs\u00fcberdeckung impliziert. Der Umkehrschluss gilt nicht.</p> <p>Der Anweisungs\u00fcberdeckungstest sowie der Zweig\u00fcberdeckungstest arbeiten auf Basis eines Kontrollflussgraphen w\u00e4hrend der Entscheidungs\u00fcberdeckungstest direkt auf dem Quellcode basiert. Die Testverfahren Anweisungs\u00fcberdeckungstest und Zweig\u00fcberdeckungstest sind sehr gut unter\u2003http://de.wikipedia.org/wiki/Kontrollflussorientierte_Testverfahren\u2003beschrieben.</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"hidden/Code%20Reviews/","title":"Code Reviews","text":"","tags":["cleancode"]},{"location":"hidden/Code%20Reviews/#code-reviews","title":"Code Reviews","text":"<p>Warum? Vier Augen sehen mehr als zwei. Wenn der eine Entwickler dem anderen seinen Code erkl\u00e4rt, tauchen meist Details auf, die bislang nicht bedacht wurden.</p> <p>Reviews kommen vereinfacht in zwei Spielarten daher: als kontinuierlicher Prozess beim Pair Programming, als eigenst\u00e4ndiger Prozessschritt beim Code Review. Das Ziel ist in beiden F\u00e4llen das gleiche: der Code soll von einem zweiten Entwickler begutachtet werden. Dies beugt der \u201eBetriebsblindheit\u201c vor. Schon die Tatsache dass ein Entwickler seinen Code einem anderen Entwickler vorstellt und beschreibt, f\u00fchrt zu Aha Erlebnissen.</p> <p>In der Regel wird erst durch die Diskussion mit anderen Entwicklern deutlich, wo die St\u00e4rken und Schw\u00e4chen einer Codebasis liegen. Gerade der Prozess der st\u00e4ndigen Verbesserung bedingt es, sich mit der Sichtweise anderer Entwickler auseinander zu setzen.</p> <p>Selbstverst\u00e4ndlich ist nicht nur der Quellcode eine geeignete Basis f\u00fcr Reviews. Sie bieten eine g\u00fcnstige M\u00f6glichkeit, die Ergebnisse jeder Entwicklungst\u00e4tigkeit zu \u00fcberpr\u00fcfen, sofern sie in einem \u201elesbaren\u201c Ergebnis m\u00fcnden. Neben rein informellen Reviews, wie dem Pair Programming oder der Begutachtung durch eine zweite Person gibt es auch das formale Review mit einem Reviewprozess sowie entsprechenden Rollen. Weitere bekannte Arten des Review sind z.B. Walkthrough, Technisches Review, Peer Review und Inspektion.</p> <p>Reviews erg\u00e4nzen dynamische Tests, wie z.B. den automatischen Unit Test oder den automatischen Integrationstest aus dem\u2003Gelben Grad\u2003bzw.\u2003Orangenen Grad Im Gegensatz zu diesen Tests, sind Reviews auch sehr gut geeignet, Fehler in den Anforderungen zu finden. Auch k\u00f6nnen sie bereits sehr fr\u00fch im Entwicklungsprozess eingesetzt und Fehler dadurch auch sehr fr\u00fch gefunden werden. Und um so fr\u00fcher Fehler gefunden werden, um so g\u00fcnstiger ist auch deren Beseitigung.</p> <p>An den orangen Grad schlie\u00dft sich der\u2003Gelbe Grad an.</p>","tags":["cleancode"]},{"location":"hidden/Command/","title":"Command","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Command/#command","title":"Command","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Command/#intent","title":"Intent","text":"<p>Command\u2003is a behavioral design pattern that turns a request into a stand-alone object that contains all information about the request. This transformation lets you pass requests as a method arguments, delay or queue a request\u2019s execution, and support undoable\u2003operations.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Command/#problem","title":"Problem","text":"<p>Imagine that you\u2019re working on a new text-editor app. Your current task is to create a toolbar with a bunch of buttons for various operations of the editor. You created a very neat\u2003<code>Button</code>\u2003class that can be used for buttons on the toolbar, as well as for generic buttons in various dialogs.</p> <p></p> <p>All buttons of the app are derived from the same\u2003class.</p> <p>While all of these buttons look similar, they\u2019re all supposed to do different things. Where would you put the code for the various click handlers of these buttons? The simplest solution is to create tons of subclasses for each place where the button is used. These subclasses would contain the code that would have to be executed on a button click.</p> <p></p> <p>Lots of button subclasses. What can go\u2003wrong?</p> <p>Before long, you realize that this approach is deeply flawed. First, you have an enormous number of subclasses, and that would be okay if you weren\u2019t risking breaking the code in these subclasses each time you modify the base\u2003<code>Button</code>\u2003class. Put simply, your GUI code has become awkwardly dependent on the volatile code of the business logic.</p> <p></p> <p>Several classes implement the same\u2003functionality.</p> <p>And here\u2019s the ugliest part. Some operations, such as copying/pasting text, would need to be invoked from multiple places. For example, a user could click a small \u201cCopy\u201d button on the toolbar, or copy something via the context menu, or just hit\u2003<code>Ctrl+C</code>\u2003on the keyboard.</p> <p>Initially, when our app only had the toolbar, it was okay to place the implementation of various operations into the button subclasses. In other words, having the code for copying text inside the\u2003<code>CopyButton</code>\u2003subclass was fine. But then, when you implement context menus, shortcuts, and other stuff, you have to either duplicate the operation\u2019s code in many classes or make menus dependent on buttons, which is an even worse option.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Command/#solution","title":"Solution","text":"<p>Good software design is often based on the\u2003principle of Separation of Concerns, which usually results in breaking an app into layers. The most common example: a layer for the graphical user interface and another layer for the business logic. The GUI layer is responsible for rendering a beautiful picture on the screen, capturing any input and showing results of what the user and the app are doing. However, when it comes to doing something important, like calculating the trajectory of the moon or composing an annual report, the GUI layer delegates the work to the underlying layer of business logic.</p> <p>In the code it might look like this: a GUI object calls a method of a business logic object, passing it some arguments. This process is usually described as one object sending another a\u2003request.</p> <p></p> <p>The GUI objects may access the business logic objects\u2003directly.</p> <p>The Command pattern suggests that GUI objects shouldn\u2019t send these requests directly. Instead, you should extract all of the request details, such as the object being called, the name of the method and the list of arguments into a separate\u2003command\u2003class with a single method that triggers this request.</p> <p>Command objects serve as links between various GUI and business logic objects. From now on, the GUI object doesn\u2019t need to know what business logic object will receive the request and how it\u2019ll be processed. The GUI object just triggers the command, which handles all the details.</p> <p></p> <p>Accessing the business logic layer via a\u2003command.</p> <p>The next step is to make your commands implement the same interface. Usually it has just a single execution method that takes no parameters. This interface lets you use various commands with the same request sender, without coupling it to concrete classes of commands. As a bonus, now you can switch command objects linked to the sender, effectively changing the sender\u2019s behavior at runtime.</p> <p>You might have noticed one missing piece of the puzzle, which is the request parameters. A GUI object might have supplied the business-layer object with some parameters. Since the command execution method doesn\u2019t have any parameters, how would we pass the request details to the receiver? It turns out the command should be either pre-configured with this data, or capable of getting it on its own.</p> <p></p> <p>The GUI objects delegate the work to\u2003commands.</p> <p>Let\u2019s get back to our text editor. After we apply the Command pattern, we no longer need all those button subclasses to implement various click behaviors. It\u2019s enough to put a single field into the base\u2003<code>Button</code>\u2003class that stores a reference to a command object and make the button execute that command on a click.</p> <p>You\u2019ll implement a bunch of command classes for every possible operation and link them with particular buttons, depending on the buttons\u2019 intended behavior.</p> <p>Other GUI elements, such as menus, shortcuts or entire dialogs, can be implemented in the same way. They\u2019ll be linked to a command which gets executed when a user interacts with the GUI element. As you\u2019ve probably guessed by now, the elements related to the same operations will be linked to the same commands, preventing any code duplication.</p> <p>As a result, commands become a convenient middle layer that reduces coupling between the GUI and business logic layers. And that\u2019s only a fraction of the benefits that the Command pattern can offer!</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Command/#real-world-analogy","title":"Real-World Analogy","text":"<p>Making an order in a\u2003restaurant.</p> <p>After a long walk through the city, you get to a nice restaurant and sit at the table by the window. A friendly waiter approaches you and quickly takes your order, writing it down on a piece of paper. The waiter goes to the kitchen and sticks the order on the wall. After a while, the order gets to the chef, who reads it and cooks the meal accordingly. The cook places the meal on a tray along with the order. The waiter discovers the tray, checks the order to make sure everything is as you wanted it, and brings everything to your table.</p> <p>The paper order serves as a command. It remains in a queue until the chef is ready to serve it. The order contains all the relevant information required to cook the meal. It allows the chef to start cooking right away instead of running around clarifying the order details from you directly.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Command/#structure","title":"Structure","text":"<ol> <li>The\u2003Sender\u2003class (aka\u2003invoker) is responsible for initiating requests. This class must have a field for storing a reference to a command object. The sender triggers that command instead of sending the request directly to the receiver. Note that the sender isn\u2019t responsible for creating the command object. Usually, it gets a pre-created command from the client via the constructor.</li> <li>The\u2003Command\u2003interface usually declares just a single method for executing the command.</li> <li>Concrete Commands\u2003implement various kinds of requests. A concrete command isn\u2019t supposed to perform the work on its own, but rather to pass the call to one of the business logic objects. However, for the sake of simplifying the code, these classes can be merged.     Parameters required to execute a method on a receiving object can be declared as fields in the concrete command. You can make command objects immutable by only allowing the initialization of these fields via the constructor.</li> <li>The\u2003Receiver\u2003class contains some business logic. Almost any object may act as a receiver. Most commands only handle the details of how a request is passed to the receiver, while the receiver itself does the actual work.</li> <li>The\u2003Client\u2003creates and configures concrete command objects. The client must pass all of the request parameters, including a receiver instance, into the command\u2019s constructor. After that, the resulting command may be associated with one or multiple senders.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Command/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Command\u2003pattern helps to track the history of executed operations and makes it possible to revert an operation if needed.</p> <p></p> <p>Undoable operations in a text\u2003editor.</p> <p>Commands which result in changing the State of the editor (e.g., cutting and pasting) make a backup copy of the editor\u2019s state before executing an operation associated with the command. After a command is executed, it\u2019s placed into the command history (a stack of command objects) along with the backup copy of the editor\u2019s state at that point. Later, if the user needs to revert an operation, the app can take the most recent command from the history, read the associated backup of the editor\u2019s state, and restore it.</p> <p>The client code (GUI elements, command history,\u2003etc.) isn\u2019t coupled to concrete command classes because it works with commands via the command interface. This approach lets you introduce new commands into the app without breaking any existing code.</p> <pre><code>// The base command class defines the common interface for all\n// concrete commands.\nabstract class Command is\n    protected field app: Application\n    protected field editor: Editor\n    protected field backup: text\n\n    constructor Command(app: Application, editor: Editor) is\n        this.app = app\n        this.editor = editor\n\n    // Make a backup of the editor's state.\n    method saveBackup() is\n        backup = editor.text\n\n    // Restore the editor's state.\n    method undo() is\n        editor.text = backup\n\n    // The execution method is declared abstract to force all\n    // concrete commands to provide their own implementations.\n    // The method must return true or false depending on whether\n    // the command changes the editor's state.\n    abstract method execute()\n\n// The concrete commands go here.\nclass CopyCommand extends Command is\n    // The copy command isn't saved to the history since it\n    // doesn't change the editor's state.\n    method execute() is\n        app.clipboard = editor.getSelection()\n        return false\n\nclass CutCommand extends Command is\n    // The cut command does change the editor's state, therefore\n    // it must be saved to the history. And it'll be saved as\n    // long as the method returns true.\n    method execute() is\n        saveBackup()\n        app.clipboard = editor.getSelection()\n        editor.deleteSelection()\n        return true\n\nclass PasteCommand extends Command is\n    method execute() is\n        saveBackup()\n        editor.replaceSelection(app.clipboard)\n        return true\n\n// The undo operation is also a command.\nclass UndoCommand extends Command is\n    method execute() is\n        app.undo()\n        return false\n\n// The global command history is just a stack.\nclass CommandHistory is\n    private field history: array of Command\n\n    // Last in...\n    method push(c: Command) is\n        // Push the command to the end of the history array.\n\n    // ...first out\n    method pop():Command is\n        // Get the most recent command from the history.\n\n// The editor class has actual text editing operations. It plays\n// the role of a receiver: all commands end up delegating\n// execution to the editor's methods.\nclass Editor is\n    field text: string\n\n    method getSelection() is\n        // Return selected text.\n\n    method deleteSelection() is\n        // Delete selected text.\n\n    method replaceSelection(text) is\n        // Insert the clipboard's contents at the current\n        // position.\n\n// The application class sets up object relations. It acts as a\n// sender: when something needs to be done, it creates a command\n// object and executes it.\nclass Application is\n    field clipboard: string\n    field editors: array of Editors\n    field activeEditor: Editor\n    field history: CommandHistory\n\n    // The code which assigns commands to UI objects may look\n    // like this.\n    method createUI() is\n        // ...\n        copy = function() { executeCommand(\n            new CopyCommand(this, activeEditor)) }\n        copyButton.setCommand(copy)\n        shortcuts.onKeyPress(\"Ctrl+C\", copy)\n\n        cut = function() { executeCommand(\n            new CutCommand(this, activeEditor)) }\n        cutButton.setCommand(cut)\n        shortcuts.onKeyPress(\"Ctrl+X\", cut)\n\n        paste = function() { executeCommand(\n            new PasteCommand(this, activeEditor)) }\n        pasteButton.setCommand(paste)\n        shortcuts.onKeyPress(\"Ctrl+V\", paste)\n\n        undo = function() { executeCommand(\n            new UndoCommand(this, activeEditor)) }\n        undoButton.setCommand(undo)\n        shortcuts.onKeyPress(\"Ctrl+Z\", undo)\n\n    // Execute a command and check whether it has to be added to\n    // the history.\n    method executeCommand(command) is\n        if (command.execute)\n            history.push(command)\n\n    // Take the most recent command from the history and run its\n    // undo method. Note that we don't know the class of that\n    // command. But we don't have to, since the command knows\n    // how to undo its own action.\n    method undo() is\n        command = history.pop()\n        if (command != null)\n            command.undo()\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/Command/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Command pattern when you want to parametrize objects with operations.   The Command pattern can turn a specific method call into a stand-alone object. This change opens up a lot of interesting uses: you can pass commands as method arguments, store them inside other objects, switch linked commands at runtime,\u2003etc.</p> <p>Here\u2019s an example: you\u2019re developing a GUI component such as a context menu, and you want your users to be able to configure menu items that trigger operations when an end user clicks an item.</p> </li> <li> <p>Use the Command pattern when you want to queue operations, schedule their execution, or execute them remotely.   As with any other object, a command can be serialized, which means converting it to a string that can be easily written to a file or a database. Later, the string can be restored as the initial command object. Thus, you can delay and schedule command execution. But there\u2019s even more! In the same way, you can queue, log or send commands over the network.</p> </li> <li> <p>Use the Command pattern when you want to implement reversible operations.   Although there are many ways to implement undo/redo, the Command pattern is perhaps the most popular of all.</p> <p>To be able to revert operations, you need to implement the history of performed operations. The command history is a stack that contains all executed command objects along with related backups of the application\u2019s state.</p> <p>This method has two drawbacks. First, it isn\u2019t that easy to save an application\u2019s state because some of it can be private. This problem can be mitigated with the\u2003Memento\u2003pattern.</p> <p>Second, the state backups may consume quite a lot of RAM. Therefore, sometimes you can resort to an alternative implementation: instead of restoring the past state, the command performs the inverse operation. The reverse operation also has a price: it may turn out to be hard or even impossible to implement.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Command/#how-to-implement","title":"How to Implement","text":"<ol> <li>Declare the command interface with a single execution method.</li> <li>Start extracting requests into concrete command classes that implement the command interface. Each class must have a set of fields for storing the request arguments along with a reference to the actual receiver object. All these values must be initialized via the command\u2019s constructor.</li> <li>Identify classes that will act as\u2003senders. Add the fields for storing commands into these classes. Senders should communicate with their commands only via the command interface. Senders usually don\u2019t create command objects on their own, but rather get them from the client code.</li> <li>Change the senders so they execute the command instead of sending a request to the receiver directly.</li> <li>The client should initialize objects in the following order:<ul> <li>Create receivers.</li> <li>Create commands, and associate them with receivers if needed.</li> <li>Create senders, and associate them with specific commands.</li> </ul> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Command/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform these operations. The code may become more complicated since you\u2019re introducing a whole new layer between senders and receivers. Open Closed Principle. You can introduce new commands into the app without breaking existing client code. You can implement undo/redo. You can implement deferred execution of operations. You can assemble a set of simple commands into a complex one.","tags":["cleancode_designpatterns"]},{"location":"hidden/Command/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:<ul> <li>Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.</li> <li>Command establishes unidirectional connections between senders and receivers.</li> <li>Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a Mediator object.</li> <li>Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.</li> </ul> </li> <li> <p>Handlers in Chain of Responsibility can be implemented as Commands. In this case, you can execute a lot of different operations over the same context object, represented by a request.</p> <p>However, there\u2019s another approach, where the request itself is a Command object. In this case, you can execute the same operation in a series of different contexts linked into a chain.</p> </li> <li> <p>You can use Command and Memento together when implementing \u201cundo\u201d. In this case, commands are responsible for performing various operations over a target object, while mementos save the state of that object just before a command gets executed.</p> </li> <li> <p>Command and Strategy may look similar because you can use both to parameterize an object with some action. However, they have very different intents.</p> <ul> <li>You can use Command to convert any operation into an object. The operation\u2019s parameters become fields of that object. The conversion lets you defer execution of the operation, queue it, store the history of commands, send commands to remote services, etc.</li> <li>On the other hand, Strategy usually describes different ways of doing the same thing, letting you swap these algorithms within a single context class.</li> </ul> </li> <li>Prototype can help when you need to save copies of Commands into history.</li> <li>You can treat Visitor as a powerful version of the Command pattern. Its objects can execute operations over various objects of different classes.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Complex%20Refactorings/","title":"Complex Refactorings","text":"","tags":["cleancode"]},{"location":"hidden/Complex%20Refactorings/#complex-refactorings","title":"Complex Refactorings","text":"<p>Warum? Es ist nicht m\u00f6glich, Code direkt in der ultimativen Form zu schreiben.</p> <p>Bereits imroten Grad sind einfache Refaktorisierungen eingef\u00fchrt worden. Doch\u2003Umbenennen\u2003und\u2003Methode extrahieren\u2003reichen nicht aus, um den Code zu verbessern \u2013 oft sind gr\u00f6\u00dfere Eingriffe erforderlich. Die Einteilung in einfache und komplexe Refaktorisierungen ist sinnvoll, weil komplexe Refaktorisierungen nur mit vorhandenen automatisierten Tests effizient und risikolos zu bewerkstelligen sind. Ohne Tests w\u00e4re nach dem Refaktorisierungen nicht bekannt, ob der Code immer noch korrekt ist.</p> <p>Siehe auch unter\u2003refactoring-legacy-code.net\u2003sowie unter\u2003Tools.</p> <p>Weiter geht es beim\u2003gr\u00fcnen Grad</p>","tags":["cleancode"]},{"location":"hidden/Component%20Orientation/","title":"Component Orientation","text":"","tags":["cleancode"]},{"location":"hidden/Component%20Orientation/#component-orientation","title":"Component Orientation","text":"<p>Warum? Software braucht Black-Box-Bausteine, die sich parallel entwickeln und testen lassen. Das f\u00f6rdert Wandelbarkeit, Produktivit\u00e4t und Korrektheit.</p> <p>Die Prinzipien des\u2003CCD-Wertesystems\u2003haben sich bisher vor allem auf kleinere Codeausschnitte bezogen. Was sollte in einer Methode stehen, was sollte \u00fcber mehrere verteilt werden? Welche Methoden sollte eine Klasse ver\u00f6ffentlichen? Woher sollte ein Client-Objekt zu einem Service-Objekt kommen? Bisher ging es um Prinzipien f\u00fcr die Softwareentwicklung im Kleinen.</p> <p>Hat das CCD-Wertesystem denn aber nichts zu gr\u00f6\u00dferen Strukturen, zur Softwareentwicklung im Gro\u00dfen zu sagen? Wie steht es mit der Softwarearchitektur? Genau hier setzt das Prinzip der Komponentenorientierung an. Bisher haben wir zwar auch schon das Wort \u201eKomponente\u201c gebraucht, doch eher lax und in einem umgangssprachlichen Sinn. Von nun an jedoch soll\u2003Komponente\u2003etwas sehr spezifisches beschreiben, das wir f\u00fcr grundlegend f\u00fcr evolvierbare Software halten.</p> <p>Solange wir Software letztlich nur aus Klassen mit Methoden aufgebaut denken, versuchen wir sozusagen Computer auf Transistorebene zu beschreiben. Das funktioniert letztlich aber nicht, weil wir im Detailreichtum ersticken. Selbst die Klassen in Schichten zusammenzufassen hilft da nicht viel. Wir brauchen vielmehr sowohl ein Beschreibungsmittel f\u00fcr gr\u00f6\u00dfere Softwarestrukturen. Aber nicht nur das: das Beschreibungsmittel sollte auch ein Implementationsmittel sein \u2013 so wie Klassen -, damit das Modell, der Plan, die Beschreibung sich im Code widerspiegelt.</p> <p>Betriebssystemprozesse sind zwar solche architektonischen Mittel, letztlich sind auch sie jedoch zu gro\u00df. Solange die EXE eines Prozesses einer Applikation aus mehreren Hundert oder Tausend Klassen besteht, gewinnen wir nichts.</p> <p>Hilfe bringt allerdings das Prinzip der Komponentenorientierung. Es besagt, dass ein Anwendungsprozess zun\u00e4chst einmal aus Komponenten besteht und nicht aus Klassen. Erst die Bausteine der Komponenten sind dann Klassen. Und was ist eine Komponente? Es gibt einige Definitionen f\u00fcr Komponenten, von denen im Kern zwei Kriterien unverbr\u00fcchlich erscheinen:</p> <ul> <li>Komponenten sind bin\u00e4re Funktionseinheiten. (Eine Klasse hingegen ist eine Funktionseinheit auf Quellcodeebene.)</li> <li>Die Leistung von Komponenten wird durch einen separaten (!) Kontrakt beschrieben. (Die Leistungsbeschreibung einer Klasse liegt hingegen in ihr. Es ist die Summe ihrer Methodensignaturen.)</li> </ul> <p>Ein CCD sucht beim Entwurf einer Software nach der Definition der Prozesse also zun\u00e4chst nach den Komponenten, aus denen die Prozesse bestehen sollten. Er fragt sich, welche \u201eDienstleistungsbl\u00f6cke\u201c machen die Anwendung aus? Und diese Bl\u00f6cke sieht der CCD als Black Boxes in Bezug auf ihren Aufbau aus Klassen an. Diese Bl\u00f6cke sind Assemblies mit wohldefinierter Dienstleistung, aber unbekannter Struktur.</p> <p>Eine Client-Komponente C wei\u00df daher nichts \u00fcber die Klassenstruktur ihrer Service-Komponente S. C kennt nur den Kontrakt von S, der unabh\u00e4ngig von der Implementation von S ist. Kontrakte sind insofern f\u00fcr Komponenten das, was Interfaces f\u00fcr Klassen sind. Nicht zuf\u00e4llig bestehen Kontrakte zu einem guten Teil oder gar vollst\u00e4ndig aus Interfaces.</p> <p>Komponenten sind also Elemente der Planung wie auch der Implementation. Um das zu unterstreichen, werden Komponenten physisch unabh\u00e4ngig voneinander implementiert; ein probates Mittel daf\u00fcr sind\u2003Komponentenwerkb\u00e4nke, d.h. separate Visual Studio Solutions je Komponentenimplementation. Das f\u00f6rdert nicht nur die Konzentration auf eine Aufgabe, weil man w\u00e4hrend der Arbeit an einer Komponente in der IDE nur deren Code sieht. Dar\u00fcber hinaus f\u00f6rdert es auch konsequente Unit Tests unter Einsatz von Attrappen, da Quellcode anderer Komponenten nicht sichtbar ist. Au\u00dferdem steigert solche Codeorganisation die Produktivit\u00e4t, weil Komponenten dank ihrer separaten Kontrakte parallel implementiert werden k\u00f6nnen. Und schlie\u00dflich stellt sich eine physische Isolation gegen den schleichenden Zuwachs an Entropie im Code. Denn wo Bindungen zwischen Komponenten nur via Kontrakt aufgebaut werden k\u00f6nnen, ist die Kopplung lose und kontrolliert.</p> <p>Zur Komponentenorientierung geh\u00f6ren deshalb nicht nur bin\u00e4re, gr\u00f6\u00dfere Codeeinheiten mit separaten Kontrakten, sondern auch die Entwicklung der Kontrakte vor der Implementation (Contract-first Design). Denn sobald die Kontrakte definiert sind, die eine Komponente importiert und exportiert, kann die Arbeit an der Komponente unabh\u00e4ngig von allen anderen beginnen.</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"hidden/Composite/","title":"Composite","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Composite/#composite","title":"Composite","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Composite/#intent","title":"Intent","text":"<p>Composite\u2003is a structural design pattern that lets you compose objects into tree structures and then work with these structures as if they were individual\u2003objects.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Composite/#problem","title":"Problem","text":"<p>Using the Composite pattern makes sense only when the core model of your app can be represented as a tree.</p> <p>For example, imagine that you have two types of objects:\u2003<code>Products</code>\u2003and\u2003<code>Boxes</code>. A\u2003<code>Box</code>\u2003can contain several\u2003<code>Products</code>\u2003as well as a number of smaller\u2003<code>Boxes</code>. These little\u2003<code>Boxes</code>\u2003can also hold some\u2003<code>Products</code>\u2003or even smaller\u2003<code>Boxes</code>, and so on.</p> <p>Say you decide to create an ordering system that uses these classes. Orders could contain simple products without any wrapping, as well as boxes stuffed with products\u2026and other boxes. How would you determine the total price of such an order?</p> <p></p> <p>An order might comprise various products, packaged in boxes, which are packaged in bigger boxes and so on. The whole structure looks like an upside down\u2003tree.</p> <p>You could try the direct approach: unwrap all the boxes, go over all the products and then calculate the total. That would be doable in the real world; but in a program, it\u2019s not as simple as running a loop. You have to know the classes of\u2003<code>Products</code>\u2003and\u2003<code>Boxes</code>\u2003you\u2019re going through, the nesting level of the boxes and other nasty details beforehand. All of this makes the direct approach either too awkward or even impossible.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Composite/#solution","title":"Solution","text":"<p>The Composite pattern suggests that you work with\u2003<code>Products</code>\u2003and\u2003<code>Boxes</code>\u2003through a common interface which declares a method for calculating the total price.</p> <p>How would this method work? For a product, it\u2019d simply return the product\u2019s price. For a box, it\u2019d go over each item the box contains, ask its price and then return a total for this box. If one of these items were a smaller box, that box would also start going over its contents and so on, until the prices of all inner components were calculated. A box could even add some extra cost to the final price, such as packaging cost.</p> <p></p> <p>The Composite pattern lets you run a behavior recursively over all components of an object\u2003tree.</p> <p>The greatest benefit of this approach is that you don\u2019t need to care about the concrete classes of objects that compose the tree. You don\u2019t need to know whether an object is a simple product or a sophisticated box. You can treat them all the same via the common interface. When you call a method, the objects themselves pass the request down the tree.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Composite/#real-world-analogy","title":"Real-World Analogy","text":"<p>An example of a military\u2003structure.</p> <p>Armies of most countries are structured as hierarchies. An army consists of several divisions; a division is a set of brigades, and a brigade consists of platoons, which can be broken down into squads. Finally, a squad is a small group of real soldiers. Orders are given at the top of the hierarchy and passed down onto each level until every soldier knows what needs to be done.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Composite/#structure","title":"Structure","text":"<ol> <li>The\u2003Component\u2003interface describes operations that are common to both simple and complex elements of the tree.</li> <li> <p>The\u2003Leaf\u2003is a basic element of a tree that doesn\u2019t have sub-elements.</p> <p>Usually, leaf components end up doing most of the real work, since they don\u2019t have anyone to delegate the work to.</p> </li> <li> <p>The\u2003Container\u2003(aka\u2003composite) is an element that has sub-elements: leaves or other containers. A container doesn\u2019t know the concrete classes of its children. It works with all sub-elements only via the component interface.</p> <p>Upon receiving a request, a container delegates the work to its sub-elements, processes intermediate results and then returns the final result to the client.</p> </li> <li> <p>The\u2003Client\u2003works with all elements through the component interface. As a result, the client can work in the same way with both simple or complex elements of the tree.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Composite/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Composite\u2003pattern lets you implement stacking of geometric shapes in a graphical editor.</p> <p></p> <p>The geometric shapes editor\u2003example.</p> <p>The\u2003<code>CompoundGraphic</code>\u2003class is a container that can comprise any number of sub-shapes, including other compound shapes. A compound shape has the same methods as a simple shape. However, instead of doing something on its own, a compound shape passes the request recursively to all its children and \u201csums up\u201d the result.</p> <p>The client code works with all shapes through the single interface common to all shape classes. Thus, the client doesn\u2019t know whether it\u2019s working with a simple shape or a compound one. The client can work with very complex object structures without being coupled to concrete classes that form that structure.</p> <pre><code>// The component interface declares common operations for both\n// simple and complex objects of a composition.\ninterface Graphic is\n    method move(x, y)\n    method draw()\n\n// The leaf class represents end objects of a composition. A\n// leaf object can't have any sub-objects. Usually, it's leaf\n// objects that do the actual work, while composite objects only\n// delegate to their sub-components.\nclass Dot implements Graphic is\n    field x, y\n\n    constructor Dot(x, y) { ... }\n\n    method move(x, y) is\n        this.x += x, this.y += y\n\n    method draw() is\n        // Draw a dot at X and Y.\n\n// All component classes can extend other components.\nclass Circle extends Dot is\n    field radius\n\n    constructor Circle(x, y, radius) { ... }\n\n    method draw() is\n        // Draw a circle at X and Y with radius R.\n\n// The composite class represents complex components that may\n// have children. Composite objects usually delegate the actual\n// work to their children and then \"sum up\" the result.\nclass CompoundGraphic implements Graphic is\n    field children: array of Graphic\n\n    // A composite object can add or remove other components\n    // (both simple or complex) to or from its child list.\n    method add(child: Graphic) is\n        // Add a child to the array of children.\n\n    method remove(child: Graphic) is\n        // Remove a child from the array of children.\n\n    method move(x, y) is\n        foreach (child in children) do\n            child.move(x, y)\n\n    // A composite executes its primary logic in a particular\n    // way. It traverses recursively through all its children,\n    // collecting and summing up their results. Since the\n    // composite's children pass these calls to their own\n    // children and so forth, the whole object tree is traversed\n    // as a result.\n    method draw() is\n        // 1. For each child component:\n        //     - Draw the component.\n        //     - Update the bounding rectangle.\n        // 2. Draw a dashed rectangle using the bounding\n        // coordinates.\n\n// The client code works with all the components via their base\n// interface. This way the client code can support simple leaf\n// components as well as complex composites.\nclass ImageEditor is\n    field all: CompoundGraphic\n\n    method load() is\n        all = new CompoundGraphic()\n        all.add(new Dot(1, 2))\n        all.add(new Circle(5, 3, 10))\n        // ...\n\n    // Combine selected components into one complex composite\n    // component.\n    method groupSelected(components: array of Graphic) is\n        group = new CompoundGraphic()\n        foreach (component in components) do\n            group.add(component)\n            all.remove(component)\n        all.add(group)\n        // All components will be drawn.\n        all.draw()\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/Composite/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Composite pattern when you have to implement a tree-like object structure.     The Composite pattern provides you with two basic element types that share a common interface: simple leaves and complex containers. A container can be composed of both leaves and other containers. This lets you construct a nested recursive object structure that resembles a tree.</p> </li> <li> <p>Use the pattern when you want the client code to treat both simple and complex elements uniformly.     All elements defined by the Composite pattern share a common interface. Using this interface, the client doesn\u2019t have to worry about the concrete class of the objects it works with. </p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Composite/#how-to-implement","title":"How to Implement","text":"<ol> <li>Make sure that the core model of your app can be represented as a tree structure. Try to break it down into simple elements and containers. Remember that containers must be able to contain both simple elements and other containers.</li> <li>Declare the component interface with a list of methods that make sense for both simple and complex components.</li> <li>Create a leaf class to represent simple elements. A program may have multiple different leaf classes.</li> <li> <p>Create a container class to represent complex elements. In this class, provide an array field for storing references to sub-elements. The array must be able to store both leaves and containers, so make sure it\u2019s declared with the component interface type.</p> <p>While implementing the methods of the component interface, remember that a container is supposed to be delegating most of the work to sub-elements.</p> </li> <li> <p>Finally, define the methods for adding and removal of child elements in the container.</p> </li> </ol> <p>Keep in mind that these operations can be declared in the component interface. This would violate the\u2003Interface Segragation Principle\u2003because the methods will be empty in the leaf class. However, the client will be able to treat all the elements equally, even when composing the tree.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Composite/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can work with complex tree structures more conveniently: use polymorphism and recursion to your advantage. \u2003It might be difficult to provide a common interface for classes whose functionality differs too much. In certain scenarios, you\u2019d need to overgeneralize the component interface, making it harder to comprehend. Open Closed Principle. You can introduce new element types into the app without breaking the existing code, which now works with the object tree.","tags":["cleancode_designpatterns"]},{"location":"hidden/Composite/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>You can use Builder when creating complex Composite trees because you can program its construction steps to work recursively.</li> <li>Chain of Responsibility is often used in conjunction with Composite. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.</li> <li>You can use Iterators to traverse Composite trees.</li> <li>You can use Visitor to execute an operation over an entire Composite tree.</li> <li>You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.</li> <li> <p>Composite and Decorator have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.</p> <p>A Decorator is like a Composite but only has one child component. There\u2019s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just \u201csums up\u201d its children\u2019s results.</p> <p>However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.</p> </li> <li> <p>Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Continuous%20Delivery/","title":"Continuous Delivery","text":"","tags":["cleancode"]},{"location":"hidden/Continuous%20Delivery/#continuous-delivery","title":"Continuous Delivery","text":"<p>Warum? Als Clean Code Developer m\u00f6chte ich sicher sein, dass ein Setup das Produkt korrekt installiert. Wenn ich das erst beim Kunden herausfinde, ist es zu sp\u00e4t.</p> <p>Im\u2003gr\u00fcnen Grad\u2003haben wir den Continuous Integration Prozess f\u00fcr Build und Test aufgesetzt. Damit sorgt der Continuous Integration Prozess daf\u00fcr, dass Fehler w\u00e4hrend der Build- und Testphase schnell entdeckt werden. Wenn z.B. eine \u00c4nderung am Code dazu f\u00fchrt, dass eine andere Komponente nicht mehr \u00fcbersetzt werden kann, weist der Continuous Integration Prozess kurze Zeit nach dem Commit der \u00c4nderung auf den Fehler hin. Wenn am Ende jedoch ein Setup Programm produziert wird, welches sich aufgrund von Fehlern nicht installieren l\u00e4sst, haben wir unser Ziel trotzdem nicht erreicht: funktionierende Software die bei unseren Kunden installiert werden kann.</p> <p>Folglich m\u00fcssen wir auch die Phasen Setup und Deployment automatisieren, um sie per Knopfdruck ausf\u00fchren zu k\u00f6nnen. Nur so k\u00f6nnen wir sicher sein, dass wir installierbare Software produzieren. Und durch die Automatisierung ist sichergestellt, dass niemand einen wichtigen Schritt, der \u201ezu Fu\u00df\u201c ausgef\u00fchrt werden muss, vergisst. So kann jeder im Team zu jedem Zeitpunkt den aktuellen Stand des Produktes installationsfertig produzieren und installieren.</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"hidden/Continuous%20Integration/","title":"Continuous Integration","text":"","tags":["cleancode"]},{"location":"hidden/Continuous%20Integration/#continuous-integration","title":"Continuous Integration","text":"<p>Warum? Automatisierung und Zentralisierung der Softwareproduktion machen produktiver und reduzieren das Risiko von Fehlern bei der Auslieferung.</p> <p>Oft wird die Integration der Softwarekomponenten zeitlich nach hinten geschoben und erfolgt aufwendig und fehleranf\u00e4llig \u201eper Hand\u201c. Eigentlich sollte die Software aber zu jedem Zeitpunkt vollst\u00e4ndig lauff\u00e4hig sein. Mit Continuous Integration bezeichnet man einen Prozess, der daf\u00fcr sorgt dass der gesamte Code nach der \u00dcbermittlung von \u00c4nderungen \u00fcbersetzt und getestet wird.</p> <p>Der Continuous Integration Prozess ist vor allem f\u00fcr Teams wichtig, denn er sorgt daf\u00fcr, dass nach der \u00dcbermittlung von \u00c4nderungen der gesamte Code \u00fcbersetzt und getestet wird, nicht nur der Teil an dem ein Entwickler gerade gearbeitet hat. Die automatisierten Tests sollten von jedem Entwickler ausgef\u00fchrt werden bevor er \u00c4nderungen in die zentrale Versionskontrolle \u00fcbermittelt. Daran \u00e4ndert sich durch Continuous Integration nichts. Um sicherzustellen, dass die Tests tats\u00e4chlich ausgef\u00fchrt werden und Fehler fr\u00fchzeitig erkannt werden, laufen sie in jedem Fall auf dem Continuous Integration Server. Dies entbindet den Entwickler nicht davon die Tests vor dem Commit auszuf\u00fchren, schlie\u00dflich behindert fehlerhafter Code der in die Versionskontrolle eingecheckt wurde das gesamte Team, m\u00f6glicherweise sogar weitere Teams. So sorgt der Continuous Integration Prozess daf\u00fcr dass team\u00fcbergreifend sichergestellt wird dass Fehler so fr\u00fch wie m\u00f6glich erkannt werden.</p> <p>F\u00fcr den Continuous Integration Prozess stehen zahlreiche\u2003Softwaretools\u2003zur Verf\u00fcgung. Neben dem kontinuierlichen Build und Test, der sofort erfolgt, wenn \u00c4nderungen in die Versionskontrolle \u00fcbertragen werden, k\u00f6nnen durch Continuous Integration auch l\u00e4nger laufende Prozesse, wie z.B. Datenbanktests, automatisiert werden. Diese werden dann z.B. nur nachts ausgef\u00fchrt. Im gr\u00fcnen Grad wird lediglich der Build- und Testprozess ber\u00fccksichtigt. Das kontinuierliche Setup und Deployment der Software folgt erst sp\u00e4ter im\u2003blauen Grad.</p> <p>Martin Fowler hat einen sehr guten Artikel zu diesem Thema verfasst, nachzulesen unter\u2003http://www.martinfowler.com/articles/continuousIntegration.html</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"hidden/DRY/","title":"Don\u2019t Repeat Yourself (DRY)","text":"","tags":["cleancode"]},{"location":"hidden/DRY/#dont-repeat-yourself-dry","title":"Don\u2019t Repeat Yourself (DRY)","text":"<p>Warum? Jede Doppelung von Code oder Handgriffen leistet Inkonsistenzen und Fehlern Vorschub.</p> <p>Das DRY-Prinzip lautet:\u2003Don\u2019t Repeat Yourself\u2003\u2013 Wiederhole dich nicht. Es gilt seit den Anf\u00e4ngen der Softwareentwicklung \u2013 sonst g\u00e4be es keine Unterprogramme und keine Datennormalisierung. Dennoch ist es wahrscheinlich das am meisten missachtete Prinzip. Denn nichts ist einfacher, als Code durch Copy&amp;Paste zu wiederholen. Gerade dann, wenn es mal schnell gehen soll, passiert das allzuoft.</p> <p>Clean Code Developer \u00fcben sich im roten Grad daher darin, dieses Prinzip stets zu beachten. Sie sind sich bewusst, wann sie Code oder andere Artefakte wiederholen. Sie erkennen solche Wiederholungen, die sie selbst oder andere erzeugt haben. Sie bereinigen Wiederholungen durch Refaktorisierungen \u2013 wenn keine anderen Prinzipien oder Beschr\u00e4nkungen dagegen sprechen.</p>","tags":["cleancode"]},{"location":"hidden/Daily%20Reflection/","title":"Daily Reflection","text":"","tags":["cleancode"]},{"location":"hidden/Daily%20Reflection/#daily-reflection","title":"Daily Reflection","text":"<p>Warum? Keine Verbesserung, kein Fortschritt, kein Lernen ohne Reflexion. Aber nur, wenn Reflexion auch eingeplant wird, findet sie unter dem Druck des Tagesgesch\u00e4ftes auch statt.</p> <p>Im Zentrum von CCD steht die pers\u00f6nliche Entwicklung. Es geht also um Ver\u00e4nderung: Mit jedem Tag soll sich das CCD-Wertesysten ein klein wenig mehr im Projektalltag des Clean Code Developers manifestieren. Das ist die Pfadfinderregel des CCDs auf sich selbst angewandt.</p> <p>So ein Ver\u00e4nderungsweg geht sich allerdings gerade allein nicht leicht. Wie also auf Kurs bleiben? Wie Fortschritt messen?</p> <p>Ohne ein \u201eKontrollsystem\u201c etablieren zu wollen, glauben wir, dass dazu zweierlei geh\u00f6rt:</p> <ol> <li>Kleinschrittige Planung</li> <li>Reflexion nach jedem Schritt</li> </ol> <p>Unabh\u00e4ngig von Vorgaben durch eine Projektleitung sollten Clean Code Developer ihre Arbeit so einteilen, dass sie aus Aufgaben besteht, die an einem Arbeitstag zu bew\u00e4ltigen sind. Nur so kann am Abend jedes Tages eine Bilanz gezogen werden. Das halten wir f\u00fcr wichtig, um jeden Tag die Arbeit nicht mit in den Feierabend zu tragen. Da hat sie nichts zu suchen; der dient der Entspannung.</p> <p>Durch solche kleinen Planungsschritte wird der Arbeitsalltag allerdings nicht nur befriedigender, weil sich jeden Tag \u00fcber Erfolg oder Misserfolg entscheiden l\u00e4sst. Die schiere M\u00f6glichkeit der Entscheidung am Abend \u2013\u2003Habe ich alle meine Aufgaben erledigt? Wie habe ich meine Aufgaben erledigt?\u2003\u2013 erlaubt auch die Reflexion \u00fcber die Einhaltung des CCD-Wertesystems.</p> <p>Um sich konsequent zu einem CCD zu entwickeln, soll der Entwickler sich auf jedem Grad nach jedem Arbeitstag dar\u00fcber Rechenschaft ablegen, ob er alle f\u00fcr ihn nach Grad relevanten Aspekte des Wertesystems ber\u00fccksichtigt hat. F\u00fcr den roten Grad bedeutet das z.B. Fragen wie: Verwalte ich wirklich alle Codefragmente im Versionskontrollsystem? Habe ich das DRY-Prinzip konsequent angewandt? Habe ich ganz allgemein Code in einem besseren Zustand hinterlassen als vorgefunden?</p> <p>Wenn er auf eine dieser Fragen nur z\u00f6gerlich mit Ja oder gar mit einem Nein antworten muss, dann ist das nat\u00fcrlich kein Beinbruch. Bei allem Bem\u00fchen klappt es eben nicht immer, dass man den guten Willen auch in die Tat umsetzen kann.</p> <p>Dennoch oder gerade deshalb ist dann allerdings Folgendes zu tun:</p> <ul> <li>Entweder bessert der CCD jetzt solange nach, bis er in Bezug auf seines Tages Arbeit keine Prinzipienverletzung mehr wahrnimmt.</li> <li>Oder er nimmt die erkannten Prinzipienverletzungen f\u00fcr den n\u00e4chsten Tag auf seinen Aufgabenzettel.</li> </ul> <p>Eine Hilfe bei der Reflexion kann das CCD Armband\u2003sein. Uns ist bewusst, dass es nicht jedermanns Sache ist, ein buntes Silikonarmband zu tragen. Wer damit kein Problem hat, kann das Armband im Rahmen der pers\u00f6nlichen Reflexion nutzen. Kann oder will der CCD die Prinzipienverletzung nicht bereinigen oder auf seinen Arbeitszettel nehmen, sollte er das Armband, das er tr\u00e4gt, vom einen auf den anderen Arm wechseln. So macht er deutlich, dass er eine Differenz zwischen dem Soll seines Grades und dem Geschafften anerkennt. Das ist nicht als Niederlage misszuverstehen oder gar als \u201eBu\u00dfe\u201c. Es geht vielmehr um eine haptische Unterst\u00fctzung des Lernvorgangs.</p> <p>Wenn ein CCD 21 Tage lang nach getaner Arbeit das Armband nicht mehr wechseln musste, kann er zur Arbeit am n\u00e4chsten Grad \u00fcbergehen. F\u00fcr den roten Grad ist das der\u2003orange Grad.</p>","tags":["cleancode"]},{"location":"hidden/Decorator/","title":"Decorator","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Decorator/#decorator","title":"Decorator","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Decorator/#intent","title":"Intent","text":"<p>Decorator\u2003is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the\u2003behaviors.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Decorator/#problem","title":"Problem","text":"<p>Imagine that you\u2019re working on a notification library which lets other programs notify their users about important events.</p> <p>The initial version of the library was based on the\u2003<code>Notifier</code>\u2003class that had only a few fields, a constructor and a single\u2003<code>send</code>\u2003method. The method could accept a message argument from a client and send the message to a list of emails that were passed to the notifier via its constructor. A third-party app which acted as a client was supposed to create and configure the notifier object once, and then use it each time something important happened.</p> <p></p> <p>A program could use the notifier class to send notifications about important events to a predefined set of\u2003emails.</p> <p>At some point, you realize that users of the library expect more than just email notifications. Many of them would like to receive an SMS about critical issues. Others would like to be notified on Facebook and, of course, the corporate users would love to get Slack notifications.</p> <p></p> <p>Each notification type is implemented as a notifier\u2019s\u2003subclass.</p> <p>How hard can that be? You extended the\u2003<code>Notifier</code>\u2003class and put the additional notification methods into new subclasses. Now the client was supposed to instantiate the desired notification class and use it for all further notifications.</p> <p>But then someone reasonably asked you, \u201cWhy can\u2019t you use several notification types at once? If your house is on fire, you\u2019d probably want to be informed through every channel.\u201d</p> <p>You tried to address that problem by creating special subclasses which combined several notification methods within one class. However, it quickly became apparent that this approach would bloat the code immensely, not only the library code but the client code as well.</p> <p></p> <p>Combinatorial explosion of\u2003subclasses.</p> <p>You have to find some other way to structure notifications classes so that their number won\u2019t accidentally break some Guinness record.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Decorator/#solution","title":"Solution","text":"<p>Extending a class is the first thing that comes to mind when you need to alter an object\u2019s behavior. However, inheritance has several serious caveats that you need to be aware of.</p> <ul> <li>Inheritance is static. You can\u2019t alter the behavior of an existing object at runtime. You can only replace the whole object with another one that\u2019s created from a different subclass.</li> <li>Subclasses can have just one parent class. In most languages, inheritance doesn\u2019t let a class inherit behaviors of multiple classes at the same time.</li> </ul> <p>One of the ways to overcome these caveats is by using\u2003Aggregation\u2003or\u2003Composition\u2003\u2003instead of\u2003Inheritance. Both of the alternatives work almost the same way: one object\u2003has a\u2003reference to another and delegates it some work, whereas with inheritance, the object itself\u2003is\u2003able to do that work, inheriting the behavior from its superclass.</p> <p>With this new approach you can easily substitute the linked \u201chelper\u201d object with another, changing the behavior of the container at runtime. An object can use the behavior of various classes, having references to multiple objects and delegating them all kinds of work. Aggregation/composition is the key principle behind many design patterns, including Decorator. On that note, let\u2019s return to the pattern discussion.</p> <p></p> <p>Inheritance vs.\u2003Aggregation</p> <p>\u201cWrapper\u201d is the alternative nickname for the Decorator pattern that clearly expresses the main idea of the pattern. A\u2003wrapper\u2003is an object that can be linked with some\u2003target\u2003object. The wrapper contains the same set of methods as the target and delegates to it all requests it receives. However, the wrapper may alter the result by doing something either before or after it passes the request to the target.</p> <p>When does a simple wrapper become the real decorator? As I mentioned, the wrapper implements the same interface as the wrapped object. That\u2019s why from the client\u2019s perspective these objects are identical. Make the wrapper\u2019s reference field accept any object that follows that interface. This will let you cover an object in multiple wrappers, adding the combined behavior of all the wrappers to it.</p> <p>In our notifications example, let\u2019s leave the simple email notification behavior inside the base\u2003<code>Notifier</code>\u2003class, but turn all other notification methods into decorators.</p> <p></p> <p>Various notification methods become\u2003decorators.</p> <p>The client code would need to wrap a basic notifier object into a set of decorators that match the client\u2019s preferences. The resulting objects will be structured as a stack.</p> <p></p> <p>Apps might configure complex stacks of notification\u2003decorators.</p> <p>The last decorator in the stack would be the object that the client actually works with. Since all decorators implement the same interface as the base notifier, the rest of the client code won\u2019t care whether it works with the \u201cpure\u201d notifier object or the decorated one.</p> <p>We could apply the same approach to other behaviors such as formatting messages or composing the recipient list. The client can decorate the object with any custom decorators, as long as they follow the same interface as the others.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Decorator/#real-world-analogy","title":"Real-World Analogy","text":"<p>You get a combined effect from wearing multiple pieces of\u2003clothing.</p> <p>Wearing clothes is an example of using decorators. When you\u2019re cold, you wrap yourself in a sweater. If you\u2019re still cold with a sweater, you can wear a jacket on top. If it\u2019s raining, you can put on a raincoat. All of these garments \u201cextend\u201d your basic behavior but aren\u2019t part of you, and you can easily take off any piece of clothing whenever you don\u2019t need it.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Decorator/#structure","title":"Structure","text":"<ol> <li> <p>The\u2003Component\u2003declares the common interface for both wrappers and wrapped objects.</p> </li> <li> <p>Concrete Component\u2003is a class of objects being wrapped. It defines the basic behavior, which can be altered by decorators.</p> </li> <li> <p>The\u2003Base Decorator\u2003class has a field for referencing a wrapped object. The field\u2019s type should be declared as the component interface so it can contain both concrete components and decorators. The base decorator delegates all operations to the wrapped object.</p> </li> <li> <p>Concrete Decorators\u2003define extra behaviors that can be added to components dynamically. Concrete decorators override methods of the base decorator and execute their behavior either before or after calling the parent method.</p> </li> <li> <p>The\u2003Client\u2003can wrap components in multiple layers of decorators, as long as it works with all objects via the component interface.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Decorator/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Decorator\u2003pattern lets you compress and encrypt sensitive data independently from the code that actually uses this data.</p> <p></p> <p>The encryption and compression decorators\u2003example.</p> <p>The application wraps the data source object with a pair of decorators. Both wrappers change the way the data is written to and read from the disk:</p> <ul> <li> <p>Just before the data is\u2003written to disk, the decorators encrypt and compress it. The original class writes the encrypted and protected data to the file without knowing about the change.</p> </li> <li> <p>Right after the data is\u2003read from disk, it goes through the same decorators, which decompress and decode it.</p> </li> </ul> <p>The decorators and the data source class implement the same interface, which makes them all interchangeable in the client code.</p> <pre><code>// The component interface defines operations that can be\n// altered by decorators.\ninterface DataSource is\n    method writeData(data)\n    method readData():data\n\n// Concrete components provide default implementations for the\n// operations. There might be several variations of these\n// classes in a program.\nclass FileDataSource implements DataSource is\n    constructor FileDataSource(filename) { ... }\n\n    method writeData(data) is\n        // Write data to file.\n\n    method readData():data is\n        // Read data from file.\n\n// The base decorator class follows the same interface as the\n// other components. The primary purpose of this class is to\n// define the wrapping interface for all concrete decorators.\n// The default implementation of the wrapping code might include\n// a field for storing a wrapped component and the means to\n// initialize it.\nclass DataSourceDecorator implements DataSource is\n    protected field wrappee: DataSource\n\n    constructor DataSourceDecorator(source: DataSource) is\n        wrappee = source\n\n    // The base decorator simply delegates all work to the\n    // wrapped component. Extra behaviors can be added in\n    // concrete decorators.\n    method writeData(data) is\n        wrappee.writeData(data)\n\n    // Concrete decorators may call the parent implementation of\n    // the operation instead of calling the wrapped object\n    // directly. This approach simplifies extension of decorator\n    // classes.\n    method readData():data is\n        return wrappee.readData()\n\n// Concrete decorators must call methods on the wrapped object,\n// but may add something of their own to the result. Decorators\n// can execute the added behavior either before or after the\n// call to a wrapped object.\nclass EncryptionDecorator extends DataSourceDecorator is\n    method writeData(data) is\n        // 1. Encrypt passed data.\n        // 2. Pass encrypted data to the wrappee's writeData\n        // method.\n\n    method readData():data is\n        // 1. Get data from the wrappee's readData method.\n        // 2. Try to decrypt it if it's encrypted.\n        // 3. Return the result.\n\n// You can wrap objects in several layers of decorators.\nclass CompressionDecorator extends DataSourceDecorator is\n    method writeData(data) is\n        // 1. Compress passed data.\n        // 2. Pass compressed data to the wrappee's writeData\n        // method.\n\n    method readData():data is\n        // 1. Get data from the wrappee's readData method.\n        // 2. Try to decompress it if it's compressed.\n        // 3. Return the result.\n\n// Option 1. A simple example of a decorator assembly.\nclass Application is\n    method dumbUsageExample() is\n        source = new FileDataSource(\"somefile.dat\")\n        source.writeData(salaryRecords)\n        // The target file has been written with plain data.\n\n        source = new CompressionDecorator(source)\n        source.writeData(salaryRecords)\n        // The target file has been written with compressed\n        // data.\n\n        source = new EncryptionDecorator(source)\n        // The source variable now contains this:\n        // Encryption &gt; Compression &gt; FileDataSource\n        source.writeData(salaryRecords)\n        // The file has been written with compressed and\n        // encrypted data.\n\n// Option 2. Client code that uses an external data source.\n// SalaryManager objects neither know nor care about data\n// storage specifics. They work with a pre-configured data\n// source received from the app configurator.\nclass SalaryManager is\n    field source: DataSource\n\n    constructor SalaryManager(source: DataSource) { ... }\n\n    method load() is\n        return source.readData()\n\n    method save() is\n        source.writeData(salaryRecords)\n    // ...Other useful methods...\n\n// The app can assemble different stacks of decorators at\n// runtime, depending on the configuration or environment.\nclass ApplicationConfigurator is\n    method configurationExample() is\n        source = new FileDataSource(\"salary.dat\")\n        if (enabledEncryption)\n            source = new EncryptionDecorator(source)\n        if (enabledCompression)\n            source = new CompressionDecorator(source)\n\n        logger = new SalaryManager(source)\n        salary = logger.load()\n    // ...\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/Decorator/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Decorator pattern when you need to be able to assign extra behaviors to objects at runtime without breaking the code that uses these objects.     \u2003The Decorator lets you structure your business logic into layers, create a decorator for each layer and compose objects with various combinations of this logic at runtime. The client code can treat all these objects in the same way, since they all follow a common interface.</p> </li> <li> <p>Use the pattern when it\u2019s awkward or not possible to extend an object\u2019s behavior using inheritance.     Many programming languages have the\u2003<code>final</code>\u2003keyword that can be used to prevent further extension of a class. For a final class, the only way to reuse the existing behavior would be to wrap the class with your own wrapper, using the Decorator pattern.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Decorator/#how-to-implement","title":"How to Implement","text":"<ol> <li>Make sure your business domain can be represented as a primary component with multiple optional layers over it.</li> <li>Figure out what methods are common to both the primary component and the optional layers. Create a component interface and declare those methods there.</li> <li>Create a concrete component class and define the base behavior in it.</li> <li>Create a base decorator class. It should have a field for storing a reference to a wrapped object. The field should be declared with the component interface type to allow linking to concrete components as well as decorators. The base decorator must delegate all work to the wrapped object.</li> <li>Make sure all classes implement the component interface.</li> <li>Create concrete decorators by extending them from the base decorator. A concrete decorator must execute its behavior before or after the call to the parent method (which always delegates to the wrapped object).</li> <li>The client code must be responsible for creating decorators and composing them in the way the client needs.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Decorator/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can extend an object\u2019s behavior without making a new subclass. It\u2019s hard to remove a specific wrapper from the wrappers stack. You can add or remove responsibilities from an object at runtime. It\u2019s hard to implement a decorator in such a way that its behavior doesn\u2019t depend on the order in the decorators stack. You can combine several behaviors by wrapping an object into multiple decorators. The initial configuration code of layers might look pretty ugly. Single Responsibility Principle. You can divide a monolithic class that implements many possible variants of behavior into several smaller classes.","tags":["cleancode_designpatterns"]},{"location":"hidden/Decorator/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<p>Adapter changes the interface of an existing object, while Decorator enhances an object without changing its interface. In addition, Decorator supports recursive composition, which isn\u2019t possible when you use Adapter.</p> <p>Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.</p> <p>Chain of Responsibility and Decorator have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences.</p> <p>The CoR handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various Decorators can extend the object\u2019s behavior while keeping it consistent with the base interface. In addition, decorators aren\u2019t allowed to break the flow of the request.</p> <p>Composite and Decorator have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.</p> <p>A Decorator is like a Composite but only has one child component. There\u2019s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just \u201csums up\u201d its children\u2019s results.</p> <p>However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.</p> <p>Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.</p> <p>Decorator lets you change the skin of an object, while Strategy lets you change the guts.</p> <p>Decorator and Proxy have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a Proxy usually manages the life cycle of its service object on its own, whereas the composition of Decorators is always controlled by the client.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Dependency%20Inversion%20Principle/","title":"Dependency Inversion Principle (DIP)","text":"","tags":["cleancode"]},{"location":"hidden/Dependency%20Inversion%20Principle/#dependency-inversion-principle-dip","title":"Dependency Inversion Principle (DIP)","text":"<p>Warum?</p> <p>Punktgenaues Testen setzt Isolation von Klassen voraus. Isolation entsteht, wenn Klassen keine Abh\u00e4ngigkeiten von Implementationen mehr enthalten \u2013 weder zur Laufzeit, noch zur \u00dcbersetzungszeit. Konkrete Abh\u00e4ngigkeiten sollten deshalb so sp\u00e4t wie m\u00f6glich entschieden werden. Am besten zur Laufzeit.</p> <p>Auch das Dependency Inversion Principle (DIP) ist ein\u2003SOLID\u2003Prinzip. Es besagt folgendes:</p> <ul> <li>High-Level Klassen sollen nicht von Low-Level Klassen abh\u00e4ngig sein, sondern beide von Interfaces.</li> <li>Interfaces sollen nicht von Details abh\u00e4ngig sein, sondern Details von Interfaces.</li> </ul> <p>Verwendet eine High-Level Klasse eine Low-Level Klasse unmittelbar, so ergibt sich eine starke Kopplung zwischen beiden. Sp\u00e4testens beim Versuch, die High-Level Klasse isoliert zu testen, wird man auf Schwierigkeiten sto\u00dfen. Aus diesem Grund sollte die High-Level Klasse von einem Interface abh\u00e4ngig sein, das wiederum von der Low-Level Klasse implementiert wird. So kann die Low-Level Klasse im Unit Test durch ein\u2003Mockup\u2003ersetzt werden.</p> <p>Um zur Laufzeit die invertierte, abstrakte Abh\u00e4ngigkeit mit einem konkreten Objekt aufzul\u00f6sen, bieten sich im Prinzip drei M\u00f6glichkeiten:</p> <ul> <li>mittels Konstruktorparameter \u201eper Hand\u201c</li> <li>Einsatz eines Inversion of Control Containers (IoC Container) wie etwa Castle Windsor</li> <li>Dependency Lookup</li> </ul> <p>Im\u2003gelben Grad\u2003injizieren wir die Abh\u00e4ngigkeiten zun\u00e4chst nur \u00fcber die Parameter der Konstruktoren. Dies ist anfangs die einfachste L\u00f6sung und funktioniert mit einer handvoll Klassen ganz gut. Sp\u00e4ter im\u2003gr\u00fcnen Grad\u2003nutzen wir einen IoC Container und Dependency Lookup.</p>","tags":["cleancode"]},{"location":"hidden/Design%20Patterns/","title":"Design Patterns","text":"","tags":["cleancode_designpatterns","cleancode_refactoring"]},{"location":"hidden/Design%20Patterns/#design-patterns","title":"Design Patterns","text":"<p>Design patterns\u2003are typical solutions to commonly occurring problems in software design. They are like pre-made blueprints that you can customize to solve a recurring design problem in your code</p>","tags":["cleancode_designpatterns","cleancode_refactoring"]},{"location":"hidden/Design%20Patterns/#creational","title":"Creational","text":"<p>These patterns provide various object creation mechanisms, which increase flexibility and reuse of existing code.</p> <ul> <li>Factory</li> <li>Abstract Factory</li> <li>Builder</li> <li>Prototype</li> <li>Singleton</li> </ul>","tags":["cleancode_designpatterns","cleancode_refactoring"]},{"location":"hidden/Design%20Patterns/#structural","title":"Structural","text":"<p>These patterns explain how to assemble objects and classes into larger structures while keeping these structures flexible and efficient. - Adapter - Bridge - Composite - Decorator - Facade - Flyweight - Proxy</p>","tags":["cleancode_designpatterns","cleancode_refactoring"]},{"location":"hidden/Design%20Patterns/#behavioral","title":"Behavioral","text":"<p>These patterns are concerned with algorithms and the assignment of responsibilities between objects. - Chain of Responsibility - Command - Iterator - Mediator - Memento - Observer - State - Strategy - Template Method - Visitor</p>","tags":["cleancode_designpatterns","cleancode_refactoring"]},{"location":"hidden/Design%20Patterns/#source","title":"Source","text":"<p>The initial Version of the listed Design Pattern pages will be a copy of Refactoring Guru</p>","tags":["cleancode_designpatterns","cleancode_refactoring"]},{"location":"hidden/Design%20and%20Implementation%20do%20not%20Overlapp/","title":"Design and Implementation Don\u2019t Overlapp","text":"","tags":["cleancode"]},{"location":"hidden/Design%20and%20Implementation%20do%20not%20Overlapp/#design-and-implementation-dont-overlapp","title":"Design and Implementation Don\u2019t Overlapp","text":"<p>Warum? Planungsunterlagen, die mit der Umsetzung nichts mehr gemein haben, schaden mehr, als dass sie n\u00fctzen. Deshalb nicht die Planung aufgeben, sondern die Chance auf Inkonsistenz minimieren.</p> <p>Eines der grundlegenden Probleme der Softwareentwicklung sind Implementationen, denen eine vorausgegangene Planung nicht mehr anzusehen ist. Da h\u00e4ngen dann Entwurfsdiagramme an der Wand, die kaum noch etwas mit der Coderealit\u00e4t zu tun haben. Die Ursache daf\u00fcr ist eine Verletzung des fundamentalen DRY-Prinzips: Entwurf und Implementation sind Wiederholungen desselben, der Struktur einer Software. Da Implementation auf Entwurf folgt und den L\u00f6wenanteil der Arbeit ausmacht, geraten beide schnell aus dem Tritt, wenn Struktur\u00e4nderungen w\u00e4hrend der Implementation nicht immer wieder in den Entwurf eingearbeitet werden. Entwurfsdiagramme sind nach Beginn der Implementation sonst bald nichts mehr wert.</p> <p>Wie kann die Situation verbessert werden? Sollte vielleicht auf Entwurf verzichtet werden, wenn letztlich in der Implementation die \u201eStrukturwahrheit\u201c liegt? Nein, sicher nicht. Entwurf muss sein. Ohne Planung gibt es keine Zielvorstellung. Aber Entwurf und Implementation m\u00fcssen dem DRY-Prinzip gerecht werden. Deshalb sollten Entwurf und Implementation sich so wenig \u00fcberlappen wie m\u00f6glich. Ihre Schnittstelle sollte d\u00fcnn sein. Wenn das der Fall ist, stellen sie keine Wiederholungen mehr dar, sondern beschreiben unterschiedliches. Das bedeutet: Entwurf/Architektur k\u00fcmmert sich nicht um die Implementation und Implementation k\u00fcmmert sich nicht um Architektur.</p> <p>Und wo verl\u00e4uft diese Trennlinie? Bei den so genannten Komponenten (s.u. Praktiken). Architekten k\u00fcmmern sich nicht um den internen Aufbau von Komponenten. F\u00fcr sie sind es Black Boxes, deren Klassenstruktur nicht architekturrelevant ist. Umgekehrt ist f\u00fcr einen Komponentenimplementierer die Architektur irrelevant. Was er zu implementieren hat, ergibt sich aus den Komponentenkontrakten, die seine Komponente importiert und exportiert. Einen gr\u00f6\u00dferen Zusammenhang muss er nicht kennen.</p> <p>Die Aufgabe der Architektur ist es mithin, Software in Komponenten zu zerlegen, deren Abh\u00e4ngigkeiten zu definieren und Leistungen in Kontrakten zu beschreiben. Diese Strukturen werden dann auch einzig durch Architekten gepflegt. Und die Aufgabe der Implementation ist es, die von der Architektur definierten Komponenten zu realisieren. Wie sie das tun, ist nicht architekturrelevant. Ihre innere Struktur ist f\u00fcr die Architektur unsichtbar.</p>","tags":["cleancode"]},{"location":"hidden/Design%20before%20Implementation/","title":"Design before Implementation","text":"","tags":["cleancode"]},{"location":"hidden/Design%20before%20Implementation/#design-before-implementation","title":"Design before Implementation","text":"<p>Warum? Vor der Umsetzung muss eine L\u00f6sung entworfen werden. Andernfalls findet kein konsequentes Nachdenken \u00fcber die L\u00f6sung statt.</p> <p>Die Aufgabe eines Entwicklers besteht darin, Anforderungen in Code zu \u00fcbersetzen. Dazu ist es erforderlich, eine L\u00f6sung f\u00fcr die Anforderungen zu entwickeln. Es muss nachgedacht werden. Wie kann das aber auf gute Weise geschehen, wenn Entwickler direkt ins Codieren springen?</p> <p>In trivialen F\u00e4llen mag es m\u00f6glich sein, direkt Code zu schreiben. Dennoch wird auch beim unmittelbaren Sprung ins Codieren \u00fcber die L\u00f6sung nachgedacht. Allerdings geschieht dies eher unbewusst, vor allem aber\u2003w\u00e4hrend\u2003der Umsetzung. Der Entwickler denkt ein wenig nach, codiert, denk nach, codiert, usw. Es fehlt hier ein konsequentes Durchdenken der L\u00f6sung, getrennt von der Umsetzung.</p> <p>Sp\u00e4testens, wenn eine Gruppe von Entwicklern gemeinsam als Team arbeiten m\u00f6chte, muss der Entwurf zeitlich getrennt von der Umsetzung stattfinden. Andernfalls ist keine fl\u00fcssige arbeitsteilige Vorgehensweise m\u00f6glich.</p> <p>Der Entwurf erm\u00f6glicht es dem Team bzw. einem einzelnen Entwickler, bereits vor der Codierung \u00fcber wichtige Prinzipien nachzudenken. Es entstehen bspw. erst gar keine Methoden oder Klassen mit mehreren Verantwortlichkeiten, da schon auf der Ebene des Entwurfs \u00fcber das\u2003Single Responsibility Principle\u2003nachgedacht werden kann. Damit erspart sich das Team den Refaktorisierungsaufwand der entsteht, wenn \u201edrauf los\u201c codiert wird.</p> <p>Siehe auch\u2003https://flow-design.info.</p>","tags":["cleancode"]},{"location":"hidden/Docker/","title":"Docker","text":""},{"location":"hidden/Docker/#connecting-from-container-to-host","title":"Connecting from Container to host","text":"<p>One problem I faced was to connect to the host from a container. (It was because of a live logging application)</p> <p>I achieved the desired result by doing adding the extra_hosts section in my compose file: <pre><code>services:\n\texample:\n\t...\n\t\textra_hosts:\n\t\t  - logserver.local: host-gateway\n</code></pre></p> <p>With this I can call <code>logserver.local</code> inside of my container and it gets routed to the localhost.</p> <p>If you want to configure it so that host-gateway points to a specific IP address you can configure it in the <code>/etc/docker/daemon.json</code> <pre><code>{ \"host-gateway-ip\": \"&lt;desiredIP&gt;\" }\n</code></pre></p> <p>This can be especially useful if you install docker without docker-desktop on WSL. Then you can route your host-gateway to the virtual network-interface connecting to windows.</p>"},{"location":"hidden/Docker/#synchronizing-timezone-of-host-with-container","title":"Synchronizing Timezone of Host with Container","text":"<p>Docker containers are by default in the timezone ETC/UTC, if you need to have it synchronized to the local machine then you will find multiple options on the internet:</p>"},{"location":"hidden/Docker/#1-set-the-tz-variable","title":"1. Set the TZ variable","text":"<p>In a <code>docker-compose.yml</code>: <pre><code>services:\n# ...\n# Container Definition in docker.compose.yaml\n  environments:\n    - TZ=Europe/Berlin\n</code></pre></p> <p>As single command: <pre><code>docker run -rm -e TZ=Europe/Berlin debian:latest date\n</code></pre></p> Pro Contra Works for most cases Does not work if timezone needs to be updated without recreating the container Easy to set up"},{"location":"hidden/Docker/#2-bind-the-system-time-files-to-the-container","title":"2. Bind the system time files to the container","text":"<p>In a <code>docker-compose.yml</code> <pre><code>services:\n# ...\n# Container Definition in docker.compose.yaml\n  volumes:\n    - /etc/timezone:/etc/timezone:ro\n    - /etc/localtime:/etc/localtime:ro\n</code></pre></p> Pro Contra Timezone is set correctly localtime does not work correctly Time is synchronized to the host continously ### 3. Combination This solution combines the two concepts and sets the TZ Variable on every start of the container. For that we need to add a script to the Dockerfile. <pre><code>ENTRYPOINT [\"/bin/bash\", \"startupScript.sh\"]\n</code></pre> <p>In the script we set the TZ and then startup the application: <pre><code>#!/bin/bash  \nif timezone=$(cat /etc/timezone 2&gt;/dev/null); then  \n    export TZ=\"$timezone\"  \n    echo \"Using Timezone $timezone\"  \nfi  \n./Application # this is the command to run your application\n</code></pre></p> <p>If we do it like this, then every time we restart the container the timezone is synchronized with the host.</p>"},{"location":"hidden/Entwurfsprinzipien/","title":"Entwurfsprinzipien","text":"<p>Achtung</p> <p>Dieser Abschnitt ist zur Zeit noch in Arbeit.</p> <p>Quelle</p> <p>Die Inhalte basieren zum Gro\u00dfteil auf den Folien aus der Vorlesung \u201cInteraktive Systeme\u201d von Andreas Heil (aheil.de) Dessen Quelle ist das Buch \u201cPreim, B. und Dachselt, R. (2010) Interaktive Systeme: Band 1: Grundlagen, Graphical User Interfaces, Informationsvisualisierung. 2. Aufl. Berlin: Springer. Abschnitt 6.2\u201d</p> <p>Prinzipien f\u00fcr allgemeine und kognitive Aspekte sind:</p> <ol> <li>Kenntnis potenzieller Benutzer und ihrer Aufgaben</li> <li>Unterst\u00fctzung beim Aufbau mentaler Modelle</li> <li>Terminologie der Benutzer verwenden</li> <li>Reduktion der kognitiven Belastung</li> </ol> <p>Prinzipien, die die Benutzungsschnittstelle betreffen:</p> <ol> <li>Strukturierung der Benutzungsschnittstelle,  </li> <li>Kombination visueller und textueller Elemente,  </li> <li>Sichtbarkeit von Systemzust\u00e4nden und m\u00f6glichen Aktionen,  </li> <li>Angemessene R\u00fcckkopplung,</li> <li>Konsistenz,  </li> <li>Abbruch und R\u00fcckg\u00e4ngigmachen von Aktionen,  </li> <li>Ber\u00fccksichtigung von Fehlern,  </li> <li>Erwartungskonformes Verhalten und  </li> <li>Adaptierbarkeit der Schnittstelle </li> </ol>","tags":["is"]},{"location":"hidden/Error%20Measurement/","title":"Error Measurement","text":"","tags":["cleancode"]},{"location":"hidden/Error%20Measurement/#error-measurement","title":"Error Measurement","text":"<p>Warum? Nur wer wei\u00df, wie viele Fehler auftreten, kann sein Vorgehen so ver\u00e4ndern, dass die Fehlerrate sinkt.</p> <p>W\u00e4hrend der Softwareentwicklung passieren Fehler. Die passieren in allen Phasen: falsch verstandene oder unklar formulierte Anforderungen f\u00fchren zu Fehlern genauso wie fehlerhafte Implementierungen. Am Ende ist alles ein Fehler, was dazu f\u00fchrt, dass der Kunde eine Software erh\u00e4lt, die nicht seinen Anforderungen entspricht. Iteratives Vorgehen und Reflexion sind zwei Bausteine, die dazu dienen, den Prozess zu verbessern. Um jedoch zu erkennen, ob tats\u00e4chlich eine Verbesserung eintritt, muss eine Messgr\u00f6\u00dfe vorliegen, an der man eine Entwicklung zum Besseren \u00fcberhaupt ablesen kann.</p> <p>Das Messen der Fehler kann durch Z\u00e4hlen oder durch Zeitnahme erfolgen. Dabei steht nicht die Pr\u00e4zision im Vordergrund, solange die Messmethode vergleichbare Daten liefert. Die Entwicklungstendenz \u00fcber mehrere Iterationen hinweg soll ersichtlich werden. Ferner geht es nicht darum, die Verantwortlichkeit f\u00fcr einen Fehler zu kl\u00e4ren. Am Ende ist es egal, wer den Fehler verursacht hat, so lange das Team daraus lernt und seinen Prozess verbessert.</p> <p>Welche Fehler sind zu messen? Es sind nicht die Fehler, die w\u00e4hrend der Entwicklung auftreten. Die sind nicht zu vermeiden und f\u00fchren hoffentlich dahin, dass am Ende einer Iteration ein fehlerfreies Produkt ausgeliefert wird. Vielmehr geht es um die Fehler, die nach einer Iteration zur\u00fcckgemeldet werden vom Kunden bzw. seinem Stellvertreter (z.B. Product Owner oder Support). Das sind Fehler, die die Umsetzung neuer Anforderungen behindern. Zu messende Fehler sind also die, die auftreten, wenn man glaubt, dass es sie nicht geben d\u00fcrfte ;-) Wann im Prozess ein Team diesen Punkt erreicht und flucht, weil da wieder so ein Fehler der sonstigen Arbeit dazwischenfunkt, ist teamindividuell zu bestimmen.</p> <p>Weiter geht es beim\u2003blauen Grad.</p>","tags":["cleancode"]},{"location":"hidden/Erwartungskonformes%20Verhalten/","title":"Erwartungskonformes Verhalten","text":"<ul> <li>Prinzip des \u201eminimalen Erstaunens\u201c</li> <li>exploratives Lernen</li> <li>Verh\u00e4lt sich entsprechend den Mentalen Modellen</li> <li>Eine Anwendung sollte sich vorhersehbar verhalten</li> </ul>","tags":["is"]},{"location":"hidden/Facade/","title":"Facade","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Facade/#facade","title":"Facade","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Facade/#intent","title":"Intent","text":"<p>Facade\u2003is a structural design pattern that provides a simplified interface to a library, a framework, or any other complex set of\u2003classes.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Facade/#problem","title":"Problem","text":"<p>Imagine that you must make your code work with a broad set of objects that belong to a sophisticated library or framework. Ordinarily, you\u2019d need to initialize all of those objects, keep track of dependencies, execute methods in the correct order, and so on.</p> <p>As a result, the business logic of your classes would become tightly coupled to the implementation details of 3rd-party classes, making it hard to comprehend and maintain.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Facade/#solution","title":"Solution","text":"<p>A facade is a class that provides a simple interface to a complex subsystem which contains lots of moving parts. A facade might provide limited functionality in comparison to working with the subsystem directly. However, it includes only those features that clients really care about.</p> <p>Having a facade is handy when you need to integrate your app with a sophisticated library that has dozens of features, but you just need a tiny bit of its functionality.</p> <p>For instance, an app that uploads short funny videos with cats to social media could potentially use a professional video conversion library. However, all that it really needs is a class with the single method\u2003<code>encode(filename, format)</code>. After creating such a class and connecting it with the video conversion library, you\u2019ll have your first facade.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Facade/#real-world-analogy","title":"Real-World Analogy","text":"<p>Placing orders by\u2003phone.</p> <p>When you call a shop to place a phone order, an operator is your facade to all services and departments of the shop. The operator provides you with a simple voice interface to the ordering system, payment gateways, and various delivery services.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Facade/#structure","title":"Structure","text":"<ol> <li>The\u2003Facade\u2003provides convenient access to a particular part of the subsystem\u2019s functionality. It knows where to direct the client\u2019s request and how to operate all the moving parts.</li> <li>An\u2003Additional Facade\u2003class can be created to prevent polluting a single facade with unrelated features that might make it yet another complex structure. Additional facades can be used by both clients and other facades.</li> <li> <p>The\u2003Complex Subsystem\u2003consists of dozens of various objects. To make them all do something meaningful, you have to dive deep into the subsystem\u2019s implementation details, such as initializing objects in the correct order and supplying them with data in the proper format.</p> <p>Subsystem classes aren\u2019t aware of the facade\u2019s existence. They operate within the system and work with each other directly.</p> </li> <li> <p>The\u2003Client\u2003uses the facade instead of calling the subsystem objects directly.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Facade/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Facade\u2003pattern simplifies interaction with a complex video conversion framework.</p> <p></p> <p>An example of isolating multiple dependencies within a single facade\u2003class.</p> <p>Instead of making your code work with dozens of the framework classes directly, you create a facade class which encapsulates that functionality and hides it from the rest of the code. This structure also helps you to minimize the effort of upgrading to future versions of the framework or replacing it with another one. The only thing you\u2019d need to change in your app would be the implementation of the facade\u2019s methods. <pre><code>// These are some of the classes of a complex 3rd-party video\n// conversion framework. We don't control that code, therefore\n// can't simplify it.\n\nclass VideoFile\n// ...\n\nclass OggCompressionCodec\n// ...\n\nclass MPEG4CompressionCodec\n// ...\n\nclass CodecFactory\n// ...\n\nclass BitrateReader\n// ...\n\nclass AudioMixer\n// ...\n\n// We create a facade class to hide the framework's complexity\n// behind a simple interface. It's a trade-off between\n// functionality and simplicity.\nclass VideoConverter is\n    method convert(filename, format):File is\n        file = new VideoFile(filename)\n        sourceCodec = new CodecFactory.extract(file)\n        if (format == \"mp4\")\n            destinationCodec = new MPEG4CompressionCodec()\n        else\n            destinationCodec = new OggCompressionCodec()\n        buffer = BitrateReader.read(filename, sourceCodec)\n        result = BitrateReader.convert(buffer, destinationCodec)\n        result = (new AudioMixer()).fix(result)\n        return new File(result)\n\n// Application classes don't depend on a billion classes\n// provided by the complex framework. Also, if you decide to\n// switch frameworks, you only need to rewrite the facade class.\nclass Application is\n    method main() is\n        convertor = new VideoConverter()\n        mp4 = convertor.convert(\"funny-cats-video.ogg\", \"mp4\")\n        mp4.save()\n</code></pre></p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Facade/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Facade pattern when you need to have a limited but straightforward interface to a complex subsystem.     Often, subsystems get more complex over time. Even applying design patterns typically leads to creating more classes. A subsystem may become more flexible and easier to reuse in various contexts, but the amount of configuration and boilerplate code it demands from a client grows ever larger. The Facade attempts to fix this problem by providing a shortcut to the most-used features of the subsystem which fit most client requirements.</p> </li> <li> <p>Use the Facade when you want to structure a subsystem into layers.     Create facades to define entry points to each level of a subsystem. You can reduce coupling between multiple subsystems by requiring them to communicate only through facades.</p> <p>For example, let\u2019s return to our video conversion framework. It can be broken down into two layers: video- and audio-related. For each layer, you can create a facade and then make the classes of each layer communicate with each another via those facades. This approach looks very similar to the Mediator pattern.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Facade/#how-to-implement","title":"How to Implement","text":"<ol> <li>Check whether it\u2019s possible to provide a simpler interface than what an existing subsystem already provides. You\u2019re on the right track if this interface makes the client code independent from many of the subsystem\u2019s classes.</li> <li>Declare and implement this interface in a new facade class. The facade should redirect the calls from the client code to appropriate objects of the subsystem. The facade should be responsible for initializing the subsystem and managing its further life cycle unless the client code already does this.</li> <li>To get the full benefit from the pattern, make all the client code communicate with the subsystem only via the facade. Now the client code is protected from any changes in the subsystem code. For example, when a subsystem gets upgraded to a new version, you will only need to modify the code in the facade.</li> <li>If the facade becomes\u2003Large Class, consider extracting part of its behavior to a new, refined facade class.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Facade/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can isolate your code from the complexity of a subsystem. A facade can become a god object coupled to all classes of an app.","tags":["cleancode_designpatterns"]},{"location":"hidden/Facade/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.</li> <li>Abstract Factorycan serve as an alternative to Facade when you only want to hide the way the subsystem objects are created from the client code.</li> <li>Flyweight shows how to make lots of little objects, whereas Facade shows how to make a single object that represents an entire subsystem.</li> <li>Facade and Mediator have similar jobs: they try to organize collaboration between lots of tightly coupled classes.<ul> <li>Facade defines a simplified interface to a subsystem of objects, but it doesn\u2019t introduce any new functionality. The subsystem itself is unaware of the facade. Objects within the subsystem can communicate directly.</li> <li>Mediator centralizes communication between components of the system. The components only know about the mediator object and don\u2019t communicate directly.</li> </ul> </li> <li>A Facade class can often be transformed into a Singleton since a single facade object is sufficient in most cases.</li> <li>Facade is similar to Proxy in that both buffer a complex entity and initialize it on its own. Unlike Facade, Proxy has the same interface as its service object, which makes them interchangeable.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Factory/","title":"Factory","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Factory/#factory","title":"Factory","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Factory/#intent","title":"Intent","text":"<p>Factory Method is a creational design pattern that provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be\u2003created.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Factory/#problem","title":"Problem","text":"<p>Imagine that you\u2019re creating a logistics management application. The first version of your app can only handle transportation by trucks, so the bulk of your code lives inside the <code>Truck</code> class.</p> <p>After a while, your app becomes pretty popular. Each day you receive dozens of requests from sea transportation companies to incorporate sea logistics into the app.</p> <p></p> <p>Adding a new class to the program isn\u2019t that simple if the rest of the code is already coupled to existing\u2003classes.</p> <p>Great news, right? But how about the code? At present, most of your code is coupled to the <code>Truck</code> class. Adding <code>Ships</code> into the app would require making changes to the entire codebase. Moreover, if later you decide to add another type of transportation to the app, you will probably need to make all of these changes again.</p> <p>As a result, you will end up with pretty nasty code, riddled with conditionals that switch the app\u2019s behavior depending on the class of transportation objects.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Factory/#solution","title":"Solution","text":"<p>The Factory Method pattern suggests that you replace direct object construction calls (using the <code>new</code> operator) with calls to a special factory method. Don\u2019t worry: the objects are still created via the <code>new</code> operator, but it\u2019s being called from within the factory method. Objects returned by a factory method are often referred to as products.</p> <p></p> <p>Subclasses can alter the class of objects being returned by the factory\u2003method.</p> <p>At first glance, this change may look pointless: we just moved the constructor call from one part of the program to another. However, consider this: now you can override the factory method in a subclass and change the class of products being created by the method.</p> <p>There\u2019s a slight limitation though: subclasses may return different types of products only if these products have a common base class or interface. Also, the factory method in the base class should have its return type declared as this interface.</p> <p></p> <p>All products must follow the same\u2003interface.</p> <p>For example, both <code>Truck</code> and <code>Ship</code> classes should implement the <code>Transport</code> interface, which declares a method called <code>deliver</code>. Each class implements this method differently: trucks deliver cargo by land, ships deliver cargo by sea. The factory method in the <code>RoadLogistics</code> class returns truck objects, whereas the factory method in the <code>SeaLogistics</code> class returns ships.</p> <p></p> <p>As long as all product classes implement a common interface, you can pass their objects to the client code without breaking\u2003it.</p> <p>The code that uses the factory method (often called the client code) doesn\u2019t see a difference between the actual products returned by various subclasses. The client treats all the products as abstract <code>Transport</code>. The client knows that all transport objects are supposed to have the <code>deliver</code> method, but exactly how it works isn\u2019t important to the client.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Factory/#structure","title":"Structure","text":"<ol> <li> <p>The Product declares the interface, which is common to all objects that can be produced by the creator and its subclasses.</p> </li> <li> <p>Concrete Products are different implementations of the product interface.</p> </li> <li> <p>The Creator class declares the factory method that returns new product objects. It\u2019s important that the return type of this method matches the product interface.</p> <p>You can declare the factory method as <code>abstract</code> to force all subclasses to implement their own versions of the method. As an alternative, the base factory method can return some default product type.</p> <p>Note, despite its name, product creation is not the primary responsibility of the creator. Usually, the creator class already has some core business logic related to products. The factory method helps to decouple this logic from the concrete product classes. Here is an analogy: a large software development company can have a training department for programmers. However, the primary function of the company as a whole is still writing code, not producing programmers.</p> </li> <li> <p>Concrete Creators override the base factory method so it returns a different type of product.</p> <p>Note that the factory method doesn\u2019t have to create new instances all the time. It can also return existing objects from a cache, an object pool, or another source.</p> </li> </ol> <p></p> <p>The cross-platform dialog\u2003example.</p> <p>The base <code>Dialog</code> class uses different UI elements to render its window. Under various operating systems, these elements may look a little bit different, but they should still behave consistently. A button in Windows is still a button in Linux.</p> <p>When the factory method comes into play, you don\u2019t need to rewrite the logic of the <code>Dialog</code> class for each operating system. If we declare a factory method that produces buttons inside the base <code>Dialog</code> class, we can later create a subclass that returns Windows-styled buttons from the factory method. The subclass then inherits most of the code from the base class, but, thanks to the factory method, can render Windows-looking buttons on the screen.</p> <p>For this pattern to work, the base <code>Dialog</code> class must work with abstract buttons: a base class or an interface that all concrete buttons follow. This way the code within <code>Dialog</code> remains functional, whichever type of buttons it works with.</p> <p>Of course, you can apply this approach to other UI elements as well. However, with each new factory method you add to the <code>Dialog</code>, you get closer to the Abstract Factory pattern. Fear not, we\u2019ll talk about this pattern later.</p> <pre><code>// The creator class declares the factory method that must\n// return an object of a product class. The creator's subclasses\n// usually provide the implementation of this method.\nclass Dialog is\n    // The creator may also provide some default implementation\n    // of the factory method.\n    abstract method createButton():Button\n\n    // Note that, despite its name, the creator's primary\n    // responsibility isn't creating products. It usually\n    // contains some core business logic that relies on product\n    // objects returned by the factory method. Subclasses can\n    // indirectly change that business logic by overriding the\n    // factory method and returning a different type of product\n    // from it.\n    method render() is\n        // Call the factory method to create a product object.\n        Button okButton = createButton()\n        // Now use the product.\n        okButton.onClick(closeDialog)\n        okButton.render()\n\n// Concrete creators override the factory method to change the\n// resulting product's type.\nclass WindowsDialog extends Dialog is\n    method createButton():Button is\n        return new WindowsButton()\n\nclass WebDialog extends Dialog is\n    method createButton():Button is\n        return new HTMLButton()\n\n// The product interface declares the operations that all\n// concrete products must implement.\ninterface Button is\n    method render()\n    method onClick(f)\n\n// Concrete products provide various implementations of the\n// product interface.\nclass WindowsButton implements Button is\n    method render(a, b) is\n        // Render a button in Windows style.\n    method onClick(f) is\n        // Bind a native OS click event.\n\nclass HTMLButton implements Button is\n    method render(a, b) is\n        // Return an HTML representation of a button.\n    method onClick(f) is\n        // Bind a web browser click event.\n\nclass Application is\n    field dialog: Dialog\n\n    // The application picks a creator's type depending on the\n    // current configuration or environment settings.\n    method initialize() is\n        config = readApplicationConfigFile()\n\n        if (config.OS == \"Windows\") then\n            dialog = new WindowsDialog()\n        else if (config.OS == \"Web\") then\n            dialog = new WebDialog()\n        else\n            throw new Exception(\"Error! Unknown operating system.\")\n\n    // The client code works with an instance of a concrete\n    // creator, albeit through its base interface. As long as\n    // the client keeps working with the creator via the base\n    // interface, you can pass it any creator's subclass.\n    method main() is\n        this.initialize()\n        dialog.render()\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/Factory/#pseudocode","title":"Pseudocode","text":"<p>This example illustrates how the Factory Method can be used for creating cross-platform UI elements without coupling the client code to concrete UI classes.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Factory/#applicability","title":"Applicability","text":"<ul> <li>Use the Factory Method when you don\u2019t know beforehand the exact types and dependencies of the objects your code should work with.   The Factory Method separates product construction code from the code that actually uses the product. Therefore it\u2019s easier to extend the product construction code independently from the rest of the code.</li> </ul> <p>For example, to add a new product type to the app, you\u2019ll only need to create a new creator subclass and override the factory method in it.</p> <ul> <li>Use the Factory Method when you want to provide users of your library or framework with a way to extend its internal components.   Inheritance is probably the easiest way to extend the default behavior of a library or framework. But how would the framework recognize that your subclass should be used instead of a standard component?</li> </ul> <p>The solution is to reduce the code that constructs components across the framework into a single factory method and let anyone override this method in addition to extending the component itself.</p> <p>Let\u2019s see how that would work. Imagine that you write an app using an open source UI framework. Your app should have round buttons, but the framework only provides square ones. You extend the standard <code>Button</code> class with a glorious <code>RoundButton</code> subclass. But now you need to tell the main <code>UIFramework</code> class to use the new button subclass instead of a default one.</p> <p>To achieve this, you create a subclass <code>UIWithRoundButtons</code> from a base framework class and override its <code>createButton</code> method. While this method returns <code>Button</code> objects in the base class, you make your subclass return <code>RoundButton</code> objects. Now use the <code>UIWithRoundButtons</code> class instead of <code>UIFramework</code>. And that\u2019s about it!</p> <ul> <li>Use the Factory Method when you want to save system resources by reusing existing objects instead of rebuilding them each time.</li> </ul> <p>You often experience this need when dealing with large, resource-intensive objects such as database connections, file systems, and network resources.</p> <p>Let\u2019s think about what has to be done to reuse an existing object:</p> <ol> <li>First, you need to create some storage to keep track of all of the created objects.</li> <li>When someone requests an object, the program should look for a free object inside that pool.</li> <li>\u2026 and then return it to the client code.</li> <li>If there are no free objects, the program should create a new one (and add it to the pool).</li> </ol> <p>That\u2019s a lot of code! And it must all be put into a single place so that you don\u2019t pollute the program with duplicate code.</p> <p>Probably the most obvious and convenient place where this code could be placed is the constructor of the class whose objects we\u2019re trying to reuse. However, a constructor must always return new objects by definition. It can\u2019t return existing instances.</p> <p>Therefore, you need to have a regular method capable of creating new objects as well as reusing existing ones. That sounds very much like a factory method.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Factory/#how-to-implement","title":"How to Implement","text":"<ol> <li> <p>Make all products follow the same interface. This interface should declare methods that make sense in every product.</p> </li> <li> <p>Add an empty factory method inside the creator class. The return type of the method should match the common product interface.</p> </li> <li> <p>In the creator\u2019s code find all references to product constructors. One by one, replace them with calls to the factory method, while extracting the product creation code into the factory method.</p> <p>You might need to add a temporary parameter to the factory method to control the type of returned product.</p> <p>At this point, the code of the factory method may look pretty ugly. It may have a large <code>switch</code> statement that picks which product class to instantiate. But don\u2019t worry, we\u2019ll fix it soon enough.</p> </li> <li> <p>Now, create a set of creator subclasses for each type of product listed in the factory method. Override the factory method in the subclasses and extract the appropriate bits of construction code from the base method.</p> </li> <li> <p>If there are too many product types and it doesn\u2019t make sense to create subclasses for all of them, you can reuse the control parameter from the base class in subclasses.</p> <p>For instance, imagine that you have the following hierarchy of classes: the base <code>Mail</code> class with a couple of subclasses: <code>AirMail</code> and <code>GroundMail</code>; the <code>Transport</code> classes are <code>Plane</code>, <code>Truck</code> and <code>Train</code>. While the <code>AirMail</code> class only uses <code>Plane</code> objects, <code>GroundMail</code> may work with both <code>Truck</code> and <code>Train</code> objects. You can create a new subclass (say <code>TrainMail</code>) to handle both cases, but there\u2019s another option. The client code can pass an argument to the factory method of the <code>GroundMail</code> class to control which product it wants to receive.</p> </li> <li> <p>If, after all of the extractions, the base factory method has become empty, you can make it abstract. If there\u2019s something left, you can make it a default behavior of the method.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Factory/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You avoid tight coupling between the creator and the concrete products. The code may become more complicated since you need to introduce a lot of new subclasses to implement the pattern. The best case scenario is when you\u2019re introducing the pattern into an existing hierarchy of creator classes. Single Responsibility Principle. You can move the product creation code into one place in the program, making the code easier to support. Open Closed Principle. You can introduce new types of products into the program without breaking existing client code. ## Relations with Other Patterns - Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated). - Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes. - You can use Factory Method along with Iterator to let collection subclasses return different types of iterators that are compatible with the collections. - Prototype isn\u2019t based on inheritance, so it doesn\u2019t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. Factory Method is based on inheritance but doesn\u2019t require an initialization step. - Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.","tags":["cleancode_designpatterns"]},{"location":"hidden/Favour%20Composition%20over%20Inheritance/","title":"Favour Composition over Inheritance (FCoI)","text":"","tags":["cleancode"]},{"location":"hidden/Favour%20Composition%20over%20Inheritance/#favour-composition-over-inheritance-fcoi","title":"Favour Composition over Inheritance (FCoI)","text":"<p>Warum? Komposition f\u00f6rdert die lose Kopplung und die Testbarkeit eines Systems und ist oft flexibler.</p> <p>F\u00fcr die Wiederverwendung von Funktionalit\u00e4t kennt die Objektorientierte Programmierung (OOP) zwei sehr bekannte Kandidaten: Die Vererbung (whitebox \u2013 reuse) und die Komposition (blackbox \u2013 reuse). Verwendet man Funktionalit\u00e4t wieder durch das Ableiten von einer Klasse, so ist die Subklasse abh\u00e4ngig von der Elternklasse. Dies macht ein System in vielen F\u00e4llen unn\u00f6tig komplex, schlechter testbar und erschwert das Austauschen von Funktionalit\u00e4t zur Laufzeit. Clean Code Developer hat f\u00fcr das korrekte Ableiten das Liskov Substitution Principle bereit, das es dabei zu befolgen gilt.</p> <p>Bei der Komposition verwendet eine Klasse eine andere. Verwendet man dazu eine klar definierte Schnittstelle, f\u00f6rdert das die Entkopplung. Auch k\u00f6nnen verschiedene Implementationen einfach ausgetauscht werden. Bevor man sich also der  stellt, fordert Favour Composition over Inheritance, sich die Frage zu stellen, ob man der Komposition nicht Vorrang geben kann.</p> <p>\u201eBecause inheritance exposes a subclass to details of its parent\u2019s implementation, it\u2019s often said that \u201ainheritance breaks encapsulation\u201e. (Gang of Four 1995:19)</p>","tags":["cleancode"]},{"location":"hidden/Flyweight/","title":"Flyweight","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Flyweight/#flyweight","title":"Flyweight","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Flyweight/#intent","title":"Intent","text":"<p>Flyweight\u2003is a structural design pattern that lets you fit more objects into the available amount of RAM by sharing common parts of state between multiple objects instead of keeping all of the data in each\u2003object.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Flyweight/#problem","title":"Problem","text":"<p>To have some fun after long working hours, you decided to create a simple video game: players would be moving around a map and shooting each other. You chose to implement a realistic particle system and make it a distinctive feature of the game. Vast quantities of bullets, missiles, and shrapnel from explosions should fly all over the map and deliver a thrilling experience to the player.</p> <p>Upon its completion, you pushed the last commit, built the game and sent it to your friend for a test drive. Although the game was running flawlessly on your machine, your friend wasn\u2019t able to play for long. On his computer, the game kept crashing after a few minutes of gameplay. After spending several hours digging through debug logs, you discovered that the game crashed because of an insufficient amount of RAM. It turned out that your friend\u2019s rig was much less powerful than your own computer, and that\u2019s why the problem emerged so quickly on his machine.</p> <p>The actual problem was related to your particle system. Each particle, such as a bullet, a missile or a piece of shrapnel was represented by a separate object containing plenty of data. At some point, when the carnage on a player\u2019s screen reached its climax, newly created particles no longer fit into the remaining RAM, so the program crashed.</p> <p></p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Flyweight/#solution","title":"Solution","text":"<p>On closer inspection of the\u2003<code>Particle</code>\u2003class, you may notice that the color and\u2003sprite\u2003fields consume a lot more memory than other fields. What\u2019s worse is that these two fields store almost identical data across all particles. For example, all bullets have the same color and sprite.</p> <p></p> <p>Other parts of a particle\u2019s state, such as coordinates, movement vector and speed, are unique to each particle. After all, the values of these fields change over time. This data represents the always changing context in which the particle exists, while the color and sprite remain constant for each particle.</p> <p>This constant data of an object is usually called the\u2003intrinsic state. It lives within the object; other objects can only read it, not change it. The rest of the object\u2019s state, often altered \u201cfrom the outside\u201d by other objects, is called the\u2003extrinsic state.</p> <p>The Flyweight pattern suggests that you stop storing the extrinsic state inside the object. Instead, you should pass this state to specific methods which rely on it. Only the intrinsic state stays within the object, letting you reuse it in different contexts. As a result, you\u2019d need fewer of these objects since they only differ in the intrinsic state, which has much fewer variations than the extrinsic.</p> <p></p> <p>Let\u2019s return to our game. Assuming that we had extracted the extrinsic state from our particle class, only three different objects would suffice to represent all particles in the game: a bullet, a missile, and a piece of shrapnel. As you\u2019ve probably guessed by now, an object that only stores the intrinsic state is called\u2003a flyweight.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Flyweight/#extrinsic-state-storage","title":"Extrinsic state storage","text":"<p>Where does the extrinsic state move to? Some class should still store it, right? In most cases, it gets moved to the container object, which aggregates objects before we apply the pattern.</p> <p>In our case, that\u2019s the main\u2003<code>Game</code>\u2003object that stores all particles in the\u2003<code>particles</code>\u2003field. To move the extrinsic state into this class, you need to create several array fields for storing coordinates, vectors, and speed of each individual particle. But that\u2019s not all. You need another array for storing references to a specific flyweight that represents a particle. These arrays must be in sync so that you can access all data of a particle using the same index.</p> <p></p> <p>A more elegant solution is to create a separate context class that would store the extrinsic state along with reference to the flyweight object. This approach would require having just a single array in the container class.</p> <p>Wait a second! Won\u2019t we need to have as many of these contextual objects as we had at the very beginning? Technically, yes. But the thing is, these objects are much smaller than before. The most memory-consuming fields have been moved to just a few flyweight objects. Now, a thousand small contextual objects can reuse a single heavy flyweight object instead of storing a thousand copies of its data.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Flyweight/#flyweight-and-immutability","title":"Flyweight and immutability","text":"<p>Since the same flyweight object can be used in different contexts, you have to make sure that its state can\u2019t be modified. A flyweight should initialize its state just once, via constructor parameters. It shouldn\u2019t expose any setters or public fields to other objects.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Flyweight/#flyweight-factory","title":"Flyweight factory","text":"<p>For more convenient access to various flyweights, you can create a factory method that manages a pool of existing flyweight objects. The method accepts the intrinsic state of the desired flyweight from a client, looks for an existing flyweight object matching this state, and returns it if it was found. If not, it creates a new flyweight and adds it to the pool.</p> <p>There are several options where this method could be placed. The most obvious place is a flyweight container. Alternatively, you could create a new factory class. Or you could make the factory method static and put it inside an actual flyweight class.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Flyweight/#structure","title":"Structure","text":"<ol> <li>The Flyweight pattern is merely an optimization. Before applying it, make sure your program does have the RAM consumption problem related to having a massive number of similar objects in memory at the same time. Make sure that this problem can\u2019t be solved in any other meaningful way.</li> <li>The\u2003Flyweight\u2003class contains the portion of the original object\u2019s state that can be shared between multiple objects. The same flyweight object can be used in many different contexts. The state stored inside a flyweight is called\u2003intrinsic.\u2003The state passed to the flyweight\u2019s methods is called\u2003extrinsic.</li> <li>The\u2003Context\u2003class contains the extrinsic state, unique across all original objects. When a context is paired with one of the flyweight objects, it represents the full state of the original object.</li> <li>Usually, the behavior of the original object remains in the flyweight class. In this case, whoever calls a flyweight\u2019s method must also pass appropriate bits of the extrinsic state into the method\u2019s parameters. On the other hand, the behavior can be moved to the context class, which would use the linked flyweight merely as a data object.</li> <li>The\u2003Client\u2003calculates or stores the extrinsic state of flyweights. From the client\u2019s perspective, a flyweight is a template object which can be configured at runtime by passing some contextual data into parameters of its methods.    </li> <li>The\u2003Flyweight Factory\u2003manages a pool of existing flyweights. With the factory, clients don\u2019t create flyweights directly. Instead, they call the factory, passing it bits of the intrinsic state of the desired flyweight. The factory looks over previously created flyweights and either returns an existing one that matches search criteria or creates a new one if nothing is found.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Flyweight/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Flyweight\u2003pattern helps to reduce memory usage when rendering millions of tree objects on a canvas.</p> <p></p> <p>The pattern extracts the repeating intrinsic state from a main\u2003<code>Tree</code>\u2003class and moves it into the flyweight class\u2003<code>TreeType</code>.</p> <p>Now instead of storing the same data in multiple objects, it\u2019s kept in just a few flyweight objects and linked to appropriate\u2003<code>Tree</code>\u2003objects which act as contexts. The client code creates new tree objects using the flyweight factory, which encapsulates the complexity of searching for the right object and reusing it if needed.</p> <pre><code>// The flyweight class contains a portion of the state of a\n// tree. These fields store values that are unique for each\n// particular tree. For instance, you won't find here the tree\n// coordinates. But the texture and colors shared between many\n// trees are here. Since this data is usually BIG, you'd waste a\n// lot of memory by keeping it in each tree object. Instead, we\n// can extract texture, color and other repeating data into a\n// separate object which lots of individual tree objects can\n// reference.\nclass TreeType is\n    field name\n    field color\n    field texture\n    constructor TreeType(name, color, texture) { ... }\n    method draw(canvas, x, y) is\n        // 1. Create a bitmap of a given type, color &amp; texture.\n        // 2. Draw the bitmap on the canvas at X and Y coords.\n\n// Flyweight factory decides whether to re-use existing\n// flyweight or to create a new object.\nclass TreeFactory is\n    static field treeTypes: collection of tree types\n    static method getTreeType(name, color, texture) is\n        type = treeTypes.find(name, color, texture)\n        if (type == null)\n            type = new TreeType(name, color, texture)\n            treeTypes.add(type)\n        return type\n\n// The contextual object contains the extrinsic part of the tree\n// state. An application can create billions of these since they\n// are pretty small: just two integer coordinates and one\n// reference field.\nclass Tree is\n    field x,y\n    field type: TreeType\n    constructor Tree(x, y, type) { ... }\n    method draw(canvas) is\n        type.draw(canvas, this.x, this.y)\n\n// The Tree and the Forest classes are the flyweight's clients.\n// You can merge them if you don't plan to develop the Tree\n// class any further.\nclass Forest is\n    field trees: collection of Trees\n\n    method plantTree(x, y, name, color, texture) is\n        type = TreeFactory.getTreeType(name, color, texture)\n        tree = new Tree(x, y, type)\n        trees.add(tree)\n\n    method draw(canvas) is\n        foreach (tree in trees) do\n            tree.draw(canvas)\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/Flyweight/#applicability","title":"Applicability","text":"<ul> <li>Use the Flyweight pattern only when your program must support a huge number of objects which barely fit into available RAM.     The benefit of applying the pattern depends heavily on how and where it\u2019s used. It\u2019s most useful when:<ul> <li>an application needs to spawn a huge number of similar objects</li> <li>this drains all available RAM on a target device</li> <li>the objects contain duplicate states which can be extracted and shared between multiple objects</li> </ul> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Flyweight/#how-to-implement","title":"How to Implement","text":"<ol> <li> <p>Divide fields of a class that will become a flyweight into two parts:</p> <ul> <li>the intrinsic state: the fields that contain unchanging data duplicated across many objects</li> <li>the extrinsic state: the fields that contain contextual data unique to each object 2.  Leave the fields that represent the intrinsic state in the class, but make sure they\u2019re immutable. They should take their initial values only inside the constructor. 3.  Go over methods that use fields of the extrinsic state. For each field used in the method, introduce a new parameter and use it instead of the field. 4.  Optionally, create a factory class to manage the pool of flyweights. It should check for an existing flyweight before creating a new one. Once the factory is in place, clients must only request flyweights through it. They should describe the desired flyweight by passing its intrinsic state to the factory. 5.  The client must store or calculate values of the extrinsic state (context) to be able to call methods of flyweight objects. For the sake of convenience, the extrinsic state along with the flyweight-referencing field may be moved to a separate context class.</li> </ul> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Flyweight/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can save lots of RAM, assuming your program has tons of similar objects. You might be trading RAM over CPU cycles when some of the context data needs to be recalculated each time somebody calls a flyweight method. The code becomes much more complicated. New team members will always be wondering why the state of an entity was separated in such a way.","tags":["cleancode_designpatterns"]},{"location":"hidden/Flyweight/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.</li> <li>Flyweight shows how to make lots of little objects, whereas Facade shows how to make a single object that represents an entire subsystem.</li> <li>Flyweight would resemble Singleton if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:<ol> <li>There should be only one Singleton instance, whereas a Flyweight class can have multiple instances with different intrinsic states.</li> <li>The Singleton object can be mutable. Flyweight objects are immutable.</li> </ol> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Gelber%20Grad/","title":"Gelber Grad","text":"","tags":["cleancode"]},{"location":"hidden/Gelber%20Grad/#gelber-grad","title":"Gelber Grad","text":"","tags":["cleancode"]},{"location":"hidden/Gelber%20Grad/#prinzipien","title":"Prinzipien","text":"<ul> <li>Interface Segragation Principle</li> <li>Dependency Inversion Principle</li> <li>Liskov Substitution Principle</li> <li>Principle of Least Astonishment</li> <li>Information Hiding Principle</li> </ul>","tags":["cleancode"]},{"location":"hidden/Gelber%20Grad/#praktiken","title":"Praktiken","text":"<ul> <li>Automated Unit Tests</li> <li>Mockups</li> <li>Code Coverage Analysis</li> <li>Partizipation in Professional Events</li> <li>Complex Refactorings</li> </ul>","tags":["cleancode"]},{"location":"hidden/GitVersion/","title":"GitVersion","text":"<p>Official Website</p> <p>https://gitversion.net/</p>","tags":["git","ci","versioning"]},{"location":"hidden/GitVersion/#setup","title":"Setup","text":"<p>Install gitversion (from https://gitversion.net/docs/usage/cli/installation) <pre><code>dotnet tool install --global GitVersion.Tool --version 5.*\n</code></pre></p> <p>Initialize via wizard: <pre><code>dotnet-gitversion init\n</code></pre></p> <p>Configure branch specific information using template from https://gitversion.net/docs/reference/configuration#:~:text=a%20build%20server.-,Branch%20configuration,-Then%20we%20have</p>","tags":["git","ci","versioning"]},{"location":"hidden/GitVersion/#example-setup","title":"Example Setup","text":"<pre><code>mode: ContinuousDelivery  \nignore:  \n  sha: []  \nmerge-message-formats: {}  \nbranches:  \n  main:  \n    regex: ^master$|^main$  \n    mode: ContinuousDelivery  \n    tag: ''  \n    increment: Patch  \n    prevent-increment-of-merged-branch-version: true  \n    track-merge-target: false  \n    source-branches: [ 'develop', 'release' ]  \n    tracks-release-branches: false  \n    is-release-branch: false  \n    is-mainline: true  \n    pre-release-weight: 55000  \n  develop:  \n    regex: ^dev(elop)?(ment)?$  \n    mode: ContinuousDeployment  \n    tag: dev  \n    increment: Minor  \n    prevent-increment-of-merged-branch-version: false  \n    track-merge-target: true  \n    source-branches: []  \n    tracks-release-branches: true  \n    is-release-branch: false  \n    is-mainline: false  \n    pre-release-weight: 0  \n  release:  \n    regex: ^releases?[/-]  \n    mode: ContinuousDelivery  \n    tag: beta  \n    increment: None  \n    prevent-increment-of-merged-branch-version: true  \n    track-merge-target: false  \n    source-branches: [ 'develop', 'main', 'support', 'release' ]  \n    tracks-release-branches: false  \n    is-release-branch: true  \n    is-mainline: false  \n    pre-release-weight: 30000  \n  feature:  \n    regex: ^features?[/-]  \n    mode: ContinuousDelivery  \n    tag: useBranchName  \n    increment: Inherit  \n    prevent-increment-of-merged-branch-version: false  \n    track-merge-target: false  \n    source-branches: [ 'develop', 'main', 'release', 'feature', 'support', 'hotfix' ]  \n    tracks-release-branches: false  \n    is-release-branch: false  \n    is-mainline: false  \n    pre-release-weight: 30000  \n  pull-request:  \n    regex: ^(pull|pull\\-requests|pr)[/-]  \n    mode: ContinuousDelivery  \n    tag: PullRequest  \n    increment: Inherit  \n    prevent-increment-of-merged-branch-version: false  \n    tag-number-pattern: '[/-](?&lt;number&gt;\\d+)[-/]'  \n    track-merge-target: false  \n    source-branches: [ 'develop', 'main', 'release', 'feature', 'support', 'hotfix' ]  \n    tracks-release-branches: false  \n    is-release-branch: false  \n    is-mainline: false  \n    pre-release-weight: 30000  \n  hotfix:  \n    regex: ^hotfix(es)?[/-]  \n    mode: ContinuousDelivery  \n    tag: beta  \n    increment: Patch  \n    prevent-increment-of-merged-branch-version: false  \n    track-merge-target: false  \n    source-branches: [ 'develop', 'main', 'support' ]  \n    tracks-release-branches: false  \n    is-release-branch: false  \n    is-mainline: false  \n    pre-release-weight: 30000  \n  support:  \n    regex: ^support[/-]  \n    mode: ContinuousDelivery  \n    tag: ''  \n    increment: Patch  \n    prevent-increment-of-merged-branch-version: true  \n    track-merge-target: false  \n    source-branches: [ 'main' ]  \n    tracks-release-branches: false  \n    is-release-branch: false  \n    is-mainline: true  \n    pre-release-weight: 55000\n</code></pre>","tags":["git","ci","versioning"]},{"location":"hidden/GitVersion/#usage","title":"Usage","text":"","tags":["git","ci","versioning"]},{"location":"hidden/GitVersion/#show-all-possible-variables","title":"Show all possible Variables","text":"<p><pre><code>dotnet-gitversion\n</code></pre> Example output: <pre><code>{\n  \"Major\": 0,\n  \"Minor\": 8,\n  \"Patch\": 0,\n  \"PreReleaseTag\": \"\",\n  \"PreReleaseTagWithDash\": \"\",\n  \"PreReleaseLabel\": \"\",\n  \"PreReleaseLabelWithDash\": \"\",\n  \"PreReleaseNumber\": null,\n  \"WeightedPreReleaseNumber\": 60000,\n  \"BuildMetaData\": null,\n  \"BuildMetaDataPadded\": \"\",\n  \"FullBuildMetaData\": \"Branch.develop.Sha.a5cf5c881143995e3549a786eb89ab388a1f0fab\",\n  \"MajorMinorPatch\": \"0.8.0\",\n  \"SemVer\": \"0.8.0\",\n  \"LegacySemVer\": \"0.8.0\",\n  \"LegacySemVerPadded\": \"0.8.0\",\n  \"AssemblySemVer\": \"0.8.0.0\",\n  \"AssemblySemFileVer\": \"0.8.0.0\",\n  \"FullSemVer\": \"0.8.0\",\n  \"InformationalVersion\": \"0.8.0+Branch.develop.Sha.a5cf5c881143995e3549a786eb89ab388a1f0fab\",\n  \"BranchName\": \"develop\",\n  \"EscapedBranchName\": \"develop\",\n  \"Sha\": \"a5cf5c881143995e3549a786eb89ab388a1f0fab\",\n  \"ShortSha\": \"a5cf5c8\",\n  \"NuGetVersionV2\": \"0.8.0\",\n  \"NuGetVersion\": \"0.8.0\",\n  \"NuGetPreReleaseTagV2\": \"\",\n  \"NuGetPreReleaseTag\": \"\",\n  \"VersionSourceSha\": \"a5cf5c881143995e3549a786eb89ab388a1f0fab\",\n  \"CommitsSinceVersionSource\": 0,\n  \"CommitsSinceVersionSourcePadded\": \"0000\",\n  \"UncommittedChanges\": 1,\n  \"CommitDate\": \"2024-05-21\"\n}\n</code></pre></p>","tags":["git","ci","versioning"]},{"location":"hidden/GitVersion/#show-single-variable","title":"Show single variable","text":"<pre><code>dotnet-gitversion /showvariable FullSemVer\n</code></pre> <p>Example output <pre><code>0.9.0-zweitesFeature.1+0\n</code></pre></p>","tags":["git","ci","versioning"]},{"location":"hidden/Gr%C3%BCner%20Grad/","title":"Gr\u00fcner Grad","text":"","tags":["cleancode"]},{"location":"hidden/Gr%C3%BCner%20Grad/#gruner-grad","title":"Gr\u00fcner Grad","text":"","tags":["cleancode"]},{"location":"hidden/Gr%C3%BCner%20Grad/#prinzipien","title":"Prinzipien","text":"<ul> <li>Open Closed Principle</li> <li>Tell do not ask</li> <li>Law of Demeter</li> </ul>","tags":["cleancode"]},{"location":"hidden/Gr%C3%BCner%20Grad/#praktiken","title":"Praktiken","text":"<ul> <li>Continuous Integration</li> <li>Statical Code Analysis</li> <li>Inversion of Control Container</li> <li>Share Experience</li> <li>Error Measurement</li> </ul>","tags":["cleancode"]},{"location":"hidden/Implementation%20Reflects%20Design/","title":"Implementation Reflects Design","text":"","tags":["cleancode"]},{"location":"hidden/Implementation%20Reflects%20Design/#implementation-reflects-design","title":"Implementation Reflects Design","text":"<p>Warum? Umsetzung, die von der Planung beliebig abweichen kann, f\u00fchrt direkt in die Unwartbarkeit. Umsetzung braucht daher einen durch die Planung vorgegebenen physischen Rahmen.</p> <p>Architektur und Implementation sollen nicht \u00fcberlappen, damit sie das DRY-Prinzip nicht verletzten. So werden Inkonsistenzen vermieden, die dadurch entstehen k\u00f6nnen, dass auf der einen Seite etwas ge\u00e4ndert wird, ohne diese \u00c4nderung auf der anderen Seite nachzuf\u00fchren.</p> <p>Nichtsdestotrotz macht die Architektur aber ja Aussagen \u00fcber die Implementation. Nicht ihre Details, aber ihre grunds\u00e4tzliche Form. Architektur definiert die Strukturelemente und deren Beziehungen innerhalb eines Codesystems. Implementation existiert also auch bei Abwesenheit von \u00dcberlappungen nicht unabh\u00e4ngig von Architektur, sondern sozusagen in ihr.</p> <p>Genau das sollte sich dann aber auch in der Implementation ausdr\u00fccken. So wird die leichter verst\u00e4ndlich, so kann besser sichergestellt werden, dass die Implementation tats\u00e4chlich der Architektur folgt. Die von der Architektur auf verschiedenen Abstraktionsebenen definierten Strukturelemente sollten deshalb nicht in einem gro\u00dfen \u201eCodetopf\u201c (z.b. eine gro\u00dfe Visual Studio Solution) \u201ezusammenger\u00fchrt werden\u201c. Viel besser auch im Sinne hoher Produktivit\u00e4t und einfacher Testbarkeit ist es, die logischen Strukturen der Architektur so physisch wie m\u00f6glich zu manifestieren.</p> <ol> <li>Die von der Architektur geplanten Strukturen auf verschiedenen Abstraktionsebenen sollten sich so weitgehend wie m\u00f6glich in der Codeorganisation widerspiegeln. Das bedeutet zum einen, dass die Architektur als Strukturelemente vor allem physische Codeeinheiten benutzt. Und zum anderen sollen diese Strukturelemente dann aber auch im Quellcode bzw. in der Codeorganisation im Repository klar sichtbar sein.</li> <li>Bei der Arbeit an der Implementation der Strukturelemente und insbesondere innerhalb von Komponenten sollen Architektur\u00e4nderungen \u201eim Vorbeigehen\u201c unm\u00f6glich sein. Wer in bzw. an einem Strukturelement arbeitet, also an einem Teil, darf nicht ad hoc die umliegende Struktur, d.h. das Ganze, \u00e4ndern k\u00f6nnen. Nur wenn das gew\u00e4hrleistet ist, w\u00e4chst die Entropie einer Software nicht unkontrolliert. Das ist wichtig, da das Hauptziel von Architektur ist, die Entropie und damit die Komplexit\u00e4t von Software zu minimieren.</li> </ol> <p>Planung muss sein. Implementation darf Planung nicht torpedieren. (Wenn auch Erkenntnisse w\u00e4hrend der Implementation nat\u00fcrlich auf die Planung zur\u00fcckwirken d\u00fcrfen.) Deshalb sind Planung und Implementation zu entkoppeln. Und wo das nicht m\u00f6glich ist, da sollte die Planung mit Mitteln der Implementation arbeiten und die Implementation physisch die Planung widerspiegeln.</p>","tags":["cleancode"]},{"location":"hidden/Incremental%20Development/","title":"Incremental Development","text":"","tags":["cleancode"]},{"location":"hidden/Incremental%20Development/#incremental-development","title":"Incremental Development","text":"<p>Warum? Nur die Arbeit in Inkrementen erm\u00f6glicht es dem Product Owner, Feedback zu geben.</p> <p>Ein Inkrement stellt einen vertikalen Schnitt durch die verschiedenen Aspekte eines Softwaresystems dar. Somit ist ein Inkrement ein St\u00fcck ausf\u00fchrbare Software. Das Inkrement kann einem Product Owner auf einer Testmaschine zur Verf\u00fcgung gestellt werden, um Feedback einzuholen.</p> <p>Regelm\u00e4\u00dfiges Feedback in kurzen Abst\u00e4nden, jeweils am Ende einer Iteration, ist die Definition von Agilit\u00e4t.</p> <p>Wird dagegen horizontal statt vertikal vorgegangen, entstehen Module, die nicht eigenst\u00e4ndig ausf\u00fchrbar sind. Zu solchen Modulen kann ein Product Owner kein Feedback geben. Somit ist kein echtes agiles Vorgehen m\u00f6glich.</p>","tags":["cleancode"]},{"location":"hidden/Information%20Hiding%20Principle/","title":"Information Hiding Principle","text":"","tags":["cleancode"]},{"location":"hidden/Information%20Hiding%20Principle/#information-hiding-principle","title":"Information Hiding Principle","text":"<p>Warum? Durch das Verbergen von Details in einer Schnittstelle werden die Abh\u00e4ngigkeiten reduziert.</p> <p>Beim Design einer Schnittstelle sollte man sich fragen, welche Details au\u00dfen unbedingt sichtbar sein m\u00fcssen. Mit Schnittstelle sind hier nicht nur Interfaces im objektorientierten Sinne gemeint, sondern auch implizite Schnittstellen. Jede Klasse hat zwangsl\u00e4ufig eine implizite Schnittstelle \u2013 sie enth\u00e4lt alle nach au\u00dfen sichtbaren Details. Je mehr Details von au\u00dfen sichtbar sind, desto h\u00f6her ist die Kopplung zwischen der Klasse und ihren Verwendern. Benutzen die Verwender einer Klasse erstmal ein Detail, wird es schwerer, dieses Detail zu ver\u00e4ndern. Dies steht der Wandelbarkeit der Software entgegen.</p>","tags":["cleancode"]},{"location":"hidden/Integration%20Operation%20Segregation%20Principle%20%28IOSP%29/","title":"Integration Operation Segregation Principle (IOSP)","text":"","tags":["cleancode"]},{"location":"hidden/Integration%20Operation%20Segregation%20Principle%20%28IOSP%29/#integration-operation-segregation-principle-iosp","title":"Integration Operation Segregation Principle (IOSP)","text":"<p>Warum? Ein deutliches Symptom schlecht wandelbaren Codes sind tiefe Hierarchien funktionaler Abh\u00e4ngigkeit. Sie reduzieren die Verst\u00e4ndlichkeit und erschweren automatisierte Tests wie Refactoring.</p> <p>Indem in Methoden verhaltenserzeugende Anweisungen (Logik) gemischt mit Aufrufen anderer Methoden derselben Codebasis steht, ist nicht mehr klar erkennbar, wie Gesamtverhalten\u2003entsteht; die Anweisungen sind ja verschmiert\u2003\u00fcber eine u.U. sehr tiefe Hierarchie. Zudem tendieren Methoden mit solcher Mischung dazu, unbegrenzt zu wachsen.</p> <p>Dem stellt sich das IOSP mit einer klaren Trennung entgegen:</p> <ul> <li>Entweder enth\u00e4lt eine Methode nur Logik, d.h. Transformationen, Kontrollstrukturen oder I/O- bzw. allgemeiner: API-Aufrufe. Dann wird sie\u2003Operation\u2003genannt.</li> <li>Oder eine Methode enth\u00e4lt keinerlei Logik, sondern nur Aufrufe von anderen Methoden derselben Codebasis. Dann wird sie\u2003Integration\u2003genannt.</li> </ul> <p>Diese strikte Unterscheidung f\u00fchrt zu mehrerlei positiven Effekten:</p> <ol> <li>Methoden tendieren dazu, sehr kurz zu bleiben. Denn mehr als 10, 20 oder 30 Zeilen reine Logik oder ausschlie\u00dflich Methodenaufrufe \u201ef\u00fchlen sich nicht gut an\u201c. Da eine Mischung nicht erlaubt ist, werden weitere kleine Methoden extrahiert.</li> <li>Kurze Methoden, die nur Logik enthalten, sind leicht zu testen, da sie keine Abh\u00e4ngigkeiten haben.</li> <li>Kurze Methoden, die nur Logik enthalten, sind vergleichsweise leicht zu verstehen. Der Methodenname kann wirklich bedeutungsstiftend wirken.</li> <li>Kurze Methoden, die ausschlie\u00dflich integrieren, sind sehr gut zu verstehen und beschreiben \u201eauf einen Blick\u201c, was geschieht.</li> <li>Die Korrektheit von Integrationen l\u00e4sst sich sehr leicht durch Augenscheinnahme pr\u00fcfen. Es ist lediglich festzustellen, ob Verarbeitungsschritte grunds\u00e4tzlich in der korrekten Reihenfolge angeordnet sind. Den Rest \u00fcbernimmt der Compiler \u2013 bzw. die Testabdeckung der Operationen.</li> <li>Integrationen lassen sich leicht durch \u201eZwischenschieben\u201c weiterer Methoden erweitern, um neue Anforderungen zu erf\u00fcllen. Die Verst\u00e4ndlichkeit bleibt dabei erhalten.</li> </ol> <p>Das IOSP l\u00e4sst sich \u201eaus dem Stand\u201c von jedem Entwickler guten Willens anwenden. Seine Einhaltung ist durch jedermann leicht zu \u00fcberpr\u00fcfen. Integrationen und Operationen unterscheiden sich in der Form deutlich. Weitere Details, insbesondere zur Abgrenzung zum\u2003Dependency Inversion Principle,\u2003findest du bspw. hier.</p>","tags":["cleancode"]},{"location":"hidden/Integration%20Tests/","title":"Integration Tests","text":"","tags":["cleancode"]},{"location":"hidden/Integration%20Tests/#integration-tests","title":"Integration Tests","text":"","tags":["cleancode"]},{"location":"hidden/Interaktive%20Systeme/","title":"Interaktive Systeme","text":"<ul> <li>Entwurfsprinzipien</li> </ul>"},{"location":"hidden/Interface%20Segragation%20Principle/","title":"Interface Segregation Principle (ISP)","text":"","tags":["cleancode"]},{"location":"hidden/Interface%20Segragation%20Principle/#interface-segregation-principle-isp","title":"Interface Segregation Principle (ISP)","text":"<p>Warum?</p> <p>Leistungsbeschreibungen, die unabh\u00e4ngig von einer konkreten Erf\u00fcllung sind, machen unabh\u00e4ngig.</p> <p>Das Interface Segregation Principle (ISP) ist ein weiteres\u2003SOLID\u2003Prinzip.\u2003Segregation\u2003bedeutet\u2003Abtrennung. Das Prinzip besagt, dass ein Client nicht von Details eines Service abh\u00e4ngig sein soll, die er gar nicht ben\u00f6tigt. Je weniger in dessen Interface enthalten ist, desto geringer ist die Kopplung zwischen den beiden Komponenten.</p> <p>Stellen wir uns vor, wir m\u00fcssten einen Stecker planen, mit dem ein Monitor an einen Computer angeschlossen werden soll. Wir entscheiden uns, einfach alle Signale die in einem Computer so anfallen, per Stecker zur Verf\u00fcgung zu stellen. Der hat dann zwar einige Hundert Pins, aber daf\u00fcr ist er maximal flexibel. Dummerweise ist damit die Kopplung ebenfalls maximal.</p> <p>Beim Beispiel des Steckers ist es offensichtlich, dass eine Monitorverbindung nur jene Signale enthalten soll, die zur Darstellung eines Bildes auf dem Monitor erforderlich sind. Genauso verh\u00e4lt es sich mit Software Interfaces. Auch sie sollten so klein wie m\u00f6glich sein, um unn\u00f6tige Kopplung zu vermeiden. Und genau wie beim Monitorstecker sollte das Interface eine hohe Koh\u00e4sion haben: Es sollte nur Dinge enthalten, die wirklich eng zusammen geh\u00f6ren.</p> <p>Um das Interface Segregation Principle anzuwenden, stehen die beiden Refaktorisierungen\u2003Extract Interface\u2003und\u2003Extract Superclass\u2003zur Verf\u00fcgung.</p>","tags":["cleancode"]},{"location":"hidden/Inversion%20of%20Control%20Container/","title":"Inversion of Control Container","text":"","tags":["cleancode"]},{"location":"hidden/Inversion%20of%20Control%20Container/#inversion-of-control-container","title":"Inversion of Control Container","text":"<p>Warum? Nur, was nicht fest verdrahtet ist, kann leichter umkonfiguriert werden.</p> <p>Bereits im gelben Grad\u2003hat der CCD das Dependency Inversion Principle kennengelernt. Dabei wurden die Abh\u00e4ngigkeiten noch \u201evon Hand\u201c aufgel\u00f6st. Der n\u00e4chste logische Schritt besteht nun darin, das Aufl\u00f6sen der Abh\u00e4ngigkeiten zu automatisieren. Dazu stehen zwei Verfahren zur Verf\u00fcgung:</p> <ul> <li>Locator</li> <li>Container</li> </ul> <p>Beide verwenden einen sogenannten\u2003Inversion of Control Container\u2003(IoC Container). Vor der Verwendung des Containers m\u00fcssen die verwendeten Klassen im Container hinterlegt werden. Anschlie\u00dfend kann der Container Instanzen der hinterlegten Klassen liefern. Beim\u2003Locator\u2003geschieht dies explizit. Dies hat den Vorteil, dass die Abh\u00e4ngigkeiten nicht alle im Konstruktor der Klasse aufgef\u00fchrt werden m\u00fcssen. Bei Querschnittsaufgaben wie beispielsweise\u2003Logging\u2003ist dies ein \u00fcbliches Vorgehen. In der Regel werden die Abh\u00e4ngigkeiten jedoch als Parameter des Konstruktors aufgef\u00fchrt. Dies hat den Vorteil dass alle Abh\u00e4ngigkeiten sichtbar sind. Der Container ist damit in der Lage die Abh\u00e4ngigkeiten implizit aufzul\u00f6sen in dem er rekursiv alle ben\u00f6tigten Objekte \u00fcber den Container instanziert.</p> <p>IoC Container werden wichtig, sobald die Anzahl der Klassen w\u00e4chst. Wenn man\u2003Separation of Concerns\u2003beherzigt, entstehen viele kleine Klassen mit \u00fcberschaubaren Aufgaben. Das Zusammensetzen von Instanzen dieser Klassen wird entsprechend aufwendiger. Genau hier setzt der IoC Container an, er hilft beim Instanziieren und Verbinden der vielen kleinen Objekte.</p> <p>Ein weiterer Vorteil von IoC Containern ist die Tatsache, dass der\u2003Lebenszyklus\u2003eines Objektes per Konfiguration bestimmt werden kann. Soll es zur Laufzeit nur eine einzige Instanz eines Objektes geben (Singleton) kann der Container angewiesen werden, immer ein und dieselbe Instanz zu liefern. Auch andere Lebenszyklen wie z.B.\u2003eine Instanz pro Session\u2003werden unterst\u00fctzt.</p> <p>Um bei Verwendung eines Locators nicht in Abh\u00e4ngigkeit zu einem bestimmten IoC Container zu geraten, kann der\u2003Microsoft Common Service Locator\u2003(siehe Tools) verwendet werden. Dieser bietet eine vereinheitlichte Schnittstelle zu den g\u00e4ngigen IoC Containern.</p> <p>Zum Verst\u00e4ndnis der Mechanik die hinter einem IoC Container steckt, ist es n\u00fctzlich die Funktionalit\u00e4t einmal selber zu implementieren. Dabei soll kein vollst\u00e4ndiger Container implementiert werden sondern lediglich die Grundfunktionen.</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"hidden/Issue%20Tracking/","title":"Issue Tracking","text":"","tags":["cleancode"]},{"location":"hidden/Issue%20Tracking/#issue-tracking","title":"Issue Tracking","text":"<p>Warum? Nur, was man aufschreibt, vergisst man nicht und kann man effektiv delegieren und verfolgen.</p> <p>Eine strukturierte Verwaltung aller \u201eIssues\u201c ist schon deshalb erforderlich, damit nichts verloren geht. Und nur wenn ein \u00dcberblick \u00fcber alle offenen Punkte m\u00f6glich ist, k\u00f6nnen die Punkte priorisiert und in eine Reihenfolge gebracht werden. Dazu bedarf es nicht zwangsl\u00e4ufig ausgekl\u00fcgelter Tools, ein Board mit Pappkarten kann den Zweck auch erf\u00fcllen. Vor allem sollte hier nicht das Tool im Vordergrund stehen, sondern die T\u00e4tigkeit.</p>","tags":["cleancode"]},{"location":"hidden/Iterative%20Development/","title":"Iterative Development","text":"","tags":["cleancode"]},{"location":"hidden/Iterative%20Development/#iterative-development","title":"Iterative Development","text":"<p>Warum? Frei nach von Clausewitz: Kein Entwurf, keine Implementation \u00fcberlebt den Kontakt mit dem Kunden. Softwareentwicklung tut daher gut daran, ihren Kurs korrigieren zu k\u00f6nnen.</p> <p>Nat\u00fcrlich schreitet Softwareentwicklung immer von einer Planung \u00fcber die Implementation zu einem Test durch den Kunden voran. Irrig ist allerdings die Annahme, ein Projekt k\u00e4me mit einer Planungsphase und einer Implementationsphase und einer Kundentestphase aus. Das funktioniert \u2013 wenn \u00fcberhaupt \u2013 nur in trivialen Szenarien, wo in der Planungsphase alle Anforderungen bekannt sind. In realen Projekten jedoch liefert jede Phase Erkenntnisse f\u00fcr vorhergehende Phasen. Allemal durch den Kundentest ergeben sich Konsequenzen f\u00fcr die Planung und Implementation.</p> <p>Solche Erkenntnisse k\u00f6nnen allerdings nur Einfluss auf ein Projekt nehmen, wenn das Vorgehen nicht linear ist. Wenn es von einer sp\u00e4teren Phase keinen Weg zur\u00fcck zu einer fr\u00fcheren Phase gibt, ist Feedback nutzlos.</p> <p>Um Feedback in ein Softwareprodukt einflie\u00dfen lassen zu k\u00f6nnen, muss der Entwicklungsprozess Schleifen enthalten. Allemal die Schleife von der Kundentestphase zur\u00fcck zur Planung ist n\u00f6tig. Das hei\u00dft, Softwareentwicklung kann nur iterativ, also in mehreren Durchl\u00e4ufen, \u00fcber den Anforderungskatalog des Kunden stattfinden. Wer versucht, \u201emit einem Mal\u201c (big bang) auszuliefern, handelt dieser Erkenntnis zuwider. Der Softwareentwicklungsprozes ist vielmehr so zu planen, dass er sich durch die Anforderungen \u201ein kleinen Happen durchbei\u00dft\u201c. Jeder dieser Happen sollte nicht gr\u00f6\u00dfer sein, als dass der Durchlauf von Planung bis Kundentest mehr als 2-4 Wochen dauert. Nur dann kommt das Feedback vom Kunden h\u00e4ufig genug, um nicht allzu lange in der Umsetzung in die Irre zu laufen.</p> <p>Softwareentwicklung ist damit ein Lernprozess. In seinem Verlauf lernt das Projektteam etwas \u00fcber die Anforderungen des Kunden. Es h\u00f6rt ihm zu, plant, implementiert, und h\u00e4ndigt eine Softwareversion aus, die das Verst\u00e4ndnis des Geh\u00f6rten widerspiegelt. Dann h\u00f6rt das Team wieder zu, plant weiter/erneut nach den aktuellen Erkenntnissen usw. usf. immer im Kreis. Iteration f\u00fcr Iteration. Manchmal wird etwas aus einer fr\u00fcheren Iteration verfeinert, manchmal Neues hinzugef\u00fcgt.</p> <p>Doch nicht nur die Entwicklung einer Software ist ein Lernprozess. Lernen sollte auch auf organisatorischer Ebene stattfinden. Das Team sollte nicht nur \u00fcber den Kunden etwas lernen, sondern auch \u00fcber sich selbst. Deshalb sollte es auch immer wieder \u201eHaltepunkte\u201c geben, an denen das Team \u00fcber sein Vorgehen reflektiert. Die Erkenntnisse aus solcher Retrospektive flie\u00dfen dann ein in die n\u00e4chste Iteration der organisatorischen Entwicklung. Hier schlie\u00dft der blaue Grad an den roten Grad an, zu dem die t\u00e4gliche pers\u00f6nliche Reflexion geh\u00f6rt.</p> <p>Nat\u00fcrlich muss jede Iteration auch ein Ende haben. Und damit man wei\u00df ob man fertig ist, muss vorher klar definiert sein, was in der Iteration erreicht werden soll. Die Erreichbarkeit von Zielen kann immer nur gesch\u00e4tzt werden, auch dabei hilft die Reflexion, um die Sch\u00e4tzungen schrittweise soweit zu verbessern, dass sie f\u00fcr die Planung ausreichend genau sind. Doch wann ist das vorher definierte Ziel erreicht?\u2003\u201aWhat is done?\u2018\u2003Oberstes Ziel ist die Lieferung funktionsf\u00e4higer Software an unsere Kunden. Folglich kann das Ziel nur erreicht sein wenn wir auslieferungsfertige Software produziert haben. Das bedeutet insbesondere, dass die Software getestet ist und dass sie per Setup installiert werden kann. Durch Continuous Integration stellen wir dies kontinuierlich sicher. Keinesfalls d\u00fcrfen wir kurz vor Ende einer Iteration entscheiden, dass ein Ziel erreicht ist, obwohl noch nicht alle Tests abgeschlossen sind.</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"hidden/Iterator/","title":"Iterator","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Iterator/#iterator","title":"Iterator","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Iterator/#intent","title":"Intent","text":"<p>Iterator\u2003is a behavioral design pattern that lets you traverse elements of a collection without exposing its underlying representation (list, stack, tree,\u2003etc.). Collections are one of the most used data types in programming. Nonetheless, a collection is just a container for a group of objects.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Iterator/#problem","title":"Problem","text":"<p>Various types of\u2003collections.</p> <p>Most collections store their elements in simple lists. However, some of them are based on stacks, trees, graphs and other complex data structures.</p> <p>But no matter how a collection is structured, it must provide some way of accessing its elements so that other code can use these elements. There should be a way to go through each element of the collection without accessing the same elements over and over.</p> <p>This may sound like an easy job if you have a collection based on a list. You just loop over all of the elements. But how do you sequentially traverse elements of a complex data structure, such as a tree? For example, one day you might be just fine with depth-first traversal of a tree. Yet the next day you might require breadth-first traversal. And the next week, you might need something else, like random access to the tree elements.</p> <p></p> <p>The same collection can be traversed in several different\u2003ways.</p> <p>Adding more and more traversal algorithms to the collection gradually blurs its primary responsibility, which is efficient data storage. Additionally, some algorithms might be tailored for a specific application, so including them into a generic collection class would be weird.</p> <p>On the other hand, the client code that\u2019s supposed to work with various collections may not even care how they store their elements. However, since collections all provide different ways of accessing their elements, you have no option other than to couple your code to the specific collection classes.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Iterator/#solution","title":"Solution","text":"<p>The main idea of the Iterator pattern is to extract the traversal behavior of a collection into a separate object called an\u2003iterator.</p> <p></p> <p>Iterators implement various traversal algorithms. Several iterator objects can traverse the same collection at the same\u2003time.</p> <p>In addition to implementing the algorithm itself, an iterator object encapsulates all of the traversal details, such as the current position and how many elements are left till the end. Because of this, several iterators can go through the same collection at the same time, independently of each other.</p> <p>Usually, iterators provide one primary method for fetching elements of the collection. The client can keep running this method until it doesn\u2019t return anything, which means that the iterator has traversed all of the elements.</p> <p>All iterators must implement the same interface. This makes the client code compatible with any collection type or any traversal algorithm as long as there\u2019s a proper iterator. If you need a special way to traverse a collection, you just create a new iterator class, without having to change the collection or the client.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Iterator/#real-world-analogy","title":"Real-World Analogy","text":"<p>Various ways to walk around\u2003Rome.</p> <p>You plan to visit Rome for a few days and visit all of its main sights and attractions. But once there, you could waste a lot of time walking in circles, unable to find even the Colosseum.</p> <p>On the other hand, you could buy a virtual guide app for your smartphone and use it for navigation. It\u2019s smart and inexpensive, and you could be staying at some interesting places for as long as you want.</p> <p>A third alternative is that you could spend some of the trip\u2019s budget and hire a local guide who knows the city like the back of his hand. The guide would be able to tailor the tour to your likings, show you every attraction and tell a lot of exciting stories. That\u2019ll be even more fun; but, alas, more expensive, too.</p> <p>All of these options\u2014the random directions born in your head, the smartphone navigator or the human guide\u2014act as iterators over the vast collection of sights and attractions located in Rome.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Iterator/#structure","title":"Structure","text":"<ol> <li> <p>The\u2003Iterator\u2003interface declares the operations required for traversing a collection: fetching the next element, retrieving the current position, restarting iteration,\u2003etc.</p> </li> <li> <p>Concrete Iterators\u2003implement specific algorithms for traversing a collection. The iterator object should track the traversal progress on its own. This allows several iterators to traverse the same collection independently of each other.</p> </li> <li> <p>The\u2003Collection\u2003interface declares one or multiple methods for getting iterators compatible with the collection. Note that the return type of the methods must be declared as the iterator interface so that the concrete collections can return various kinds of iterators.</p> </li> <li> <p>Concrete Collections\u2003return new instances of a particular concrete iterator class each time the client requests one. You might be wondering, where\u2019s the rest of the collection\u2019s code? Don\u2019t worry, it should be in the same class. It\u2019s just that these details aren\u2019t crucial to the actual pattern, so we\u2019re omitting them.</p> </li> <li> <p>The\u2003Client\u2003works with both collections and iterators via their interfaces. This way the client isn\u2019t coupled to concrete classes, allowing you to use various collections and iterators with the same client code.</p> <p>Typically, clients don\u2019t create iterators on their own, but instead get them from collections. Yet, in certain cases, the client can create one directly; for example, when the client defines its own special iterator.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Iterator/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Iterator\u2003pattern is used to walk through a special kind of collection which encapsulates access to Facebook\u2019s social graph. The collection provides several iterators that can traverse profiles in various ways.</p> <p></p> <p>Example of iterating over social\u2003profiles.</p> <p>The \u2018friends\u2019 iterator can be used to go over the friends of a given profile. The \u2018colleagues\u2019 iterator does the same, except it omits friends who don\u2019t work at the same company as a target person. Both iterators implement a common interface which allows clients to fetch profiles without diving into implementation details such as authentication and sending REST requests.</p> <p>The client code isn\u2019t coupled to concrete classes because it works with collections and iterators only through interfaces. If you decide to connect your app to a new social network, you simply need to provide new collection and iterator classes without changing the existing code.</p> <pre><code>// The collection interface must declare a factory method for\n// producing iterators. You can declare several methods if there\n// are different kinds of iteration available in your program.\ninterface SocialNetwork is\n    method createFriendsIterator(profileId):ProfileIterator\n    method createCoworkersIterator(profileId):ProfileIterator\n\n// Each concrete collection is coupled to a set of concrete\n// iterator classes it returns. But the client isn't, since the\n// signature of these methods returns iterator interfaces.\nclass Facebook implements SocialNetwork is\n    // ... The bulk of the collection's code should go here ...\n\n    // Iterator creation code.\n    method createFriendsIterator(profileId) is\n        return new FacebookIterator(this, profileId, \"friends\")\n    method createCoworkersIterator(profileId) is\n        return new FacebookIterator(this, profileId, \"coworkers\")\n\n// The common interface for all iterators.\ninterface ProfileIterator is\n    method getNext():Profile\n    method hasMore():bool\n\n// The concrete iterator class.\nclass FacebookIterator implements ProfileIterator is\n    // The iterator needs a reference to the collection that it\n    // traverses.\n    private field facebook: Facebook\n    private field profileId, type: string\n\n    // An iterator object traverses the collection independently\n    // from other iterators. Therefore it has to store the\n    // iteration state.\n    private field currentPosition\n    private field cache: array of Profile\n\n    constructor FacebookIterator(facebook, profileId, type) is\n        this.facebook = facebook\n        this.profileId = profileId\n        this.type = type\n\n    private method lazyInit() is\n        if (cache == null)\n            cache = facebook.socialGraphRequest(profileId, type)\n\n    // Each concrete iterator class has its own implementation\n    // of the common iterator interface.\n    method getNext() is\n        if (hasMore())\n            currentPosition++\n            return cache[currentPosition]\n\n    method hasMore() is\n        lazyInit()\n        return currentPosition &lt; cache.length\n\n// Here is another useful trick: you can pass an iterator to a\n// client class instead of giving it access to a whole\n// collection. This way, you don't expose the collection to the\n// client.\n//\n// And there's another benefit: you can change the way the\n// client works with the collection at runtime by passing it a\n// different iterator. This is possible because the client code\n// isn't coupled to concrete iterator classes.\nclass SocialSpammer is\n    method send(iterator: ProfileIterator, message: string) is\n        while (iterator.hasMore())\n            profile = iterator.getNext()\n            System.sendEmail(profile.getEmail(), message)\n\n// The application class configures collections and iterators\n// and then passes them to the client code.\nclass Application is\n    field network: SocialNetwork\n    field spammer: SocialSpammer\n\n    method config() is\n        if working with Facebook\n            this.network = new Facebook()\n        if working with LinkedIn\n            this.network = new LinkedIn()\n        this.spammer = new SocialSpammer()\n\n    method sendSpamToFriends(profile) is\n        iterator = network.createFriendsIterator(profile.getId())\n        spammer.send(iterator, \"Very important message\")\n\n    method sendSpamToCoworkers(profile) is\n        iterator = network.createCoworkersIterator(profile.getId())\n        spammer.send(iterator, \"Very important message\")\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/Iterator/#applicability","title":"Applicability","text":"<ul> <li>Use the Iterator pattern when your collection has a complex data structure under the hood, but you want to hide its complexity from clients (either for convenience or security reasons).     \u2003The iterator encapsulates the details of working with a complex data structure, providing the client with several simple methods of accessing the collection elements. While this approach is very convenient for the client, it also protects the collection from careless or malicious actions which the client would be able to perform if working with the collection directly.</li> <li>Use the pattern to reduce duplication of the traversal code across your app.     \u2003The code of non-trivial iteration algorithms tends to be very bulky. When placed within the business logic of an app, it may blur the responsibility of the original code and make it less maintainable. Moving the traversal code to designated iterators can help you make the code of the application more lean and clean.</li> <li>Use the Iterator when you want your code to be able to traverse different data structures or when types of these structures are unknown beforehand.     \u2003The pattern provides a couple of generic interfaces for both collections and iterators. Given that your code now uses these interfaces, it\u2019ll still work if you pass it various kinds of collections and iterators that implement these interfaces.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Iterator/#how-to-implement","title":"How to Implement","text":"<ol> <li> <p>Declare the iterator interface. At the very least, it must have a method for fetching the next element from a collection. But for the sake of convenience you can add a couple of other methods, such as fetching the previous element, tracking the current position, and checking the end of the iteration.</p> </li> <li> <p>Declare the collection interface and describe a method for fetching iterators. The return type should be equal to that of the iterator interface. You may declare similar methods if you plan to have several distinct groups of iterators.</p> </li> <li> <p>Implement concrete iterator classes for the collections that you want to be traversable with iterators. An iterator object must be linked with a single collection instance. Usually, this link is established via the iterator\u2019s constructor.</p> </li> <li> <p>Implement the collection interface in your collection classes. The main idea is to provide the client with a shortcut for creating iterators, tailored for a particular collection class. The collection object must pass itself to the iterator\u2019s constructor to establish a link between them.</p> </li> <li> <p>Go over the client code to replace all of the collection traversal code with the use of iterators. The client fetches a new iterator object each time it needs to iterate over the collection elements.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Iterator/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons Single Responsibility Principle. You can clean up the client code and the collections by extracting bulky traversal algorithms into separate classes. Applying the pattern can be an overkill if your app only works with simple collections. Open Closed Principle. You can implement new types of collections and iterators and pass them to existing code without breaking anything. Using an iterator may be less efficient than going through elements of some specialized collections directly. You can iterate over the same collection in parallel because each iterator object contains its own iteration state. For the same reason, you can delay an iteration and continue it when needed.","tags":["cleancode_designpatterns"]},{"location":"hidden/Iterator/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>You can use Iterators to traverse Composite trees.</li> <li>You can use Factory Method along with Iterator to let collection subclasses return different types of iterators that are compatible with the collections.</li> <li>You can use Memento along with Iterator to capture the current iteration state and roll it back if necessary.</li> <li>You can use Visitor along with Iterator to traverse a complex data structure and execute some operation over its elements, even if they all have different classes.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/KISS/","title":"Keep it simple, stupid (KISS)","text":"","tags":["cleancode"]},{"location":"hidden/KISS/#keep-it-simple-stupid-kiss","title":"Keep it simple, stupid (KISS)","text":"<p>Warum? Wer mehr tut als das Einfachste, l\u00e4sst den Kunden warten und macht die L\u00f6sung unn\u00f6tig kompliziert.</p> <p>Oder um es mit Albert Einsteins Worten zu sagen: </p> <p>\u201eAlles sollte so einfach wie m\u00f6glich gemacht werden, aber nicht einfacher.\u201c</p> <p>F\u00fcr die Wandelbarkeit des Codes ist zwingende Voraussetzung, dass der Code verst\u00e4ndlich ist. Eine einfache, klare und leicht verst\u00e4ndliche L\u00f6sung sollte daher immer bevorzugt werden. Wenn man seinen eigenen Code nach kurzer Zeit schon nicht mehr versteht, sollten die Alarmglocken klingen. Noch wichtiger aber ist, dass auch andere Entwickler den Code schnell verstehen k\u00f6nnen. Dabei helfen regelm\u00e4\u00dfige Code Reviews und Pair Programming. Sie dienen der Kontrolle, ob tats\u00e4chlich die einfachste L\u00f6sung verwendet wurde.</p> <p>Gerade in technischen Details steckt die Versuchung, eine komplizierte L\u00f6sung anzustreben. Das Bekannte, naheliegende ist manchmal zu \u201elangweilig\u201c \u2013 und schon hat sich eine komplizierte L\u00f6sung eingeschlichen. Wenn die einfache L\u00f6sung auch funktioniert, sollte ihr Vorrang gew\u00e4hrt werden. Das gleiche gilt f\u00fcr Datenstrukturen. Wenn ein IEnumerable reicht, sollte keine ICollection oder sogar IList verwendet werden.</p>","tags":["cleancode"]},{"location":"hidden/Kenntnis%20potenzieller%20Benutzer%20und%20ihrer%20Aufgaben/","title":"Kenntnis potenzieller Benutzer und ihrer Aufgaben","text":"<ul> <li>Grundlegendes Prinzip, Voraussetzung f\u00fcr die Anwendung aller anderen Prinzipien</li> <li>Prinzip muss von Anfang an beachtet werden</li> <li>Entwickler muss sich umfassend \u00fcber Benutzer informieren<ul> <li>Repr\u00e4sentative Menge an Benutzern</li> <li>Benutzer sollten repr\u00e4sentativ sein</li> <li>Befragung hinsichtlich Vorstellungen und Bed\u00fcrfnisse</li> </ul> </li> </ul>","tags":["is"]},{"location":"hidden/Kenntnis%20potenzieller%20Benutzer%20und%20ihrer%20Aufgaben/#methoden","title":"Methoden","text":"<ul> <li>Beobachtungen</li> <li>Interviews und Gruppeninterviews</li> <li>Schriftliche Befragungen</li> <li>Besuch von Benutzern \u201cvor Ort\u201d</li> <li>Analyse von T\u00e4tigkeiten (Workflow Analysis)</li> </ul>","tags":["is"]},{"location":"hidden/Kenntnis%20potenzieller%20Benutzer%20und%20ihrer%20Aufgaben/#probleme","title":"Probleme","text":"<ul> <li>Kontakt Benutzer zu Entwickler oft von Auftraggeber nicht erw\u00fcnscht</li> <li>Vertraulichkeit von Informationen</li> <li>Entwickler verstehen das komplexe Arbeitsumfeld der Benutzer nicht</li> <li>Entwickler m\u00fcssen antizipieren, was erforderlich ist</li> </ul>","tags":["is"]},{"location":"hidden/Kichererbsen%20Wrap/","title":"Kichererbsen Wrap","text":"","tags":["cooking","mexican"]},{"location":"hidden/Kichererbsen%20Wrap/#zutaten","title":"Zutaten","text":"","tags":["cooking","mexican"]},{"location":"hidden/Kichererbsen%20Wrap/#gerostete-kichererbsen","title":"Ger\u00f6stete Kichererbsen","text":"<ul> <li>2 Dosen Kichererbsen</li> <li>1 TL Paprikapulver</li> <li>1 TL Salz</li> <li>1 EL \u00d6l</li> <li>2 EL Sambal Oelek</li> <li>3 EL Joghurt</li> <li>4 Tortilla Wraps</li> <li>1 Handvoll Eisbergsalat</li> </ul>","tags":["cooking","mexican"]},{"location":"hidden/Kichererbsen%20Wrap/#dressing","title":"Dressing","text":"<ul> <li>6 EL Joghurt</li> <li>1 TL Dill</li> <li>1/2 Zitrone, Saft</li> <li>1/2 TL Senf</li> <li>1/2 TL Salz</li> <li>1/2 TL Agavendicksaft</li> </ul>","tags":["cooking","mexican"]},{"location":"hidden/Kichererbsen%20Wrap/#zubereitung","title":"Zubereitung","text":"<ol> <li>Kichererbsen aus der Dose nehmen, waschen und auf einem Backblech getrennt voneinander platzieren.</li> <li>Ger\u00e4uchertes Paprikapulver, Salz sowie \u00d6l \u00fcber die Kichererbsen geben und alles gut miteinander vermischen.</li> <li>Das Ganze nun im 220 Grad vorgeheizten Ofen f\u00fcr 15 Minuten erhitzen</li> <li>In der Zwischenzeit das Dressing vorbereiten und hierf\u00fcr Joghurt, Dill, Zitronensaft, Senf, Salz sowie Agavendicksaft in einer Sch\u00fcssel miteinander vermischen und zur Seit stellen.</li> <li>Nun die Tortilla-Wraps kurz erw\u00e4rmen</li> <li>Sambal-Olek sowie Joghurt in eine Sch\u00fcssel geben und die gebackenen Kichererbsen aus dem Ofen darin w\u00e4lzen.</li> <li>Eisbergsalat klein schneiden und zusammen mit den Kichererbsen auf die Tortilla-Wraps geben, mit Dressing \u00fcbergie\u00dfen, einrollen und genie\u00dfen.</li> </ol>","tags":["cooking","mexican"]},{"location":"hidden/Kombination%20visueller%20und%20textueller%20Elemente/","title":"Kombination visueller und textueller Elemente","text":"<ul> <li>z.B Button mit text und Icon</li> </ul>","tags":["is"]},{"location":"hidden/Konsistenz/","title":"Konsistenz","text":"<ul> <li>Sprachliche Konsistenz (Terminologie von Men\u00fceintr\u00e4gen, etc.)</li> <li>Strukturelle Konsistenz (Anordnung, Reihenfolge)</li> <li>Grafische Konsistenz (Farben, Fonts, 3D-Effekte, Linienstile)</li> <li>Interaktionskonsistenz (Verhalten bei Bet\u00e4tigung von Maustasten, Funktionstasten, Mausbuttons)</li> <li>Konsistenz zwischen Programmen</li> </ul>","tags":["is"]},{"location":"hidden/Law%20of%20Demeter/","title":"Law of Demeter","text":"","tags":["cleancode"]},{"location":"hidden/Law%20of%20Demeter/#law-of-demeter","title":"Law of Demeter","text":"<p>Warum? Abh\u00e4ngigkeiten von Objekten \u00fcber mehrere Glieder einer Dienstleistungskette hinweg f\u00fchren zu unsch\u00f6n enger Kopplung.</p> <p>Beim\u2003Law of Demeter\u2003geht es darum, das Zusammenspiel von Objekten auf ein gesundes Ma\u00df zu beschr\u00e4nken. Man kann es vereinfacht umschreiben mit \u201eDon\u2019t talk to strangers\u201c. Nach dem Law of Demeter soll eine Methode nur folgende andere Methoden verwenden:</p> <ul> <li>Methoden der eigenen Klasse</li> <li>Methoden der Parameter</li> <li>Methoden assoziierter Klassen</li> <li>Methoden selbst erzeugter Objekte</li> </ul> <p>Allerdings: Es ist zu ber\u00fccksichtigen, dass ab und zu auch reine Datenhaltungsklassen Sinn ergeben. Auf diese muss man das Law of Demeter nat\u00fcrlich nicht anwenden. Es kann z.B. durchaus sinnvoll sein, die Konfigurationsdaten in mehrere Klassen hierarchisch zu verteilen, so dass sich am Ende folgender Zugriff auf einen Wert ergeben k\u00f6nnte:</p> <pre><code>int margin = config.Pages.Margins.Left;\n</code></pre> <p>W\u00fcrde man hier das Law of Demeter anwenden, w\u00e4re nur der Zugriff auf config.Pages gestattet.</p>","tags":["cleancode"]},{"location":"hidden/Legacy%20Code/","title":"Legacy Code","text":"","tags":["cleancode_refactoring"]},{"location":"hidden/Legacy%20Code/#legacy-code","title":"Legacy Code","text":"","tags":["cleancode_refactoring"]},{"location":"hidden/Linux/","title":"Linux","text":""},{"location":"hidden/Linux/#the-hierarchical-structure-of-the-linux-file-system","title":"The Hierarchical Structure of the Linux File System","text":"<p>The Linux file system is organized in a hierarchical tree-like structure, with the root directory (/) at the top. All other directories and files are contained within the root directory, which can be broken down into several subdirectories. Some of the key directories and their purposes include:</p> <p></p> <p>File Hierarchy Structure (FHS) in Linux</p> <p>It follows a standard naming convention for directories and files. Directories are often named after their function or content, while files are named after their purpose. Here are some common directories and their functions:</p> <ol> <li>/bin (Essential User Binaries): The /bin directory contains essential system binaries that are required for the basic operation of the system, such as ls, cp, mv, and cat.</li> <li>/boot (Boot Loader Files): The /boot directory contains the files required for the boot loader to load the operating system. These files include the kernel, initial RAM disk, and boot loader configuration files.</li> <li>/dev (Device Files): The /dev directory contains device files that represent hardware devices and drivers. These files can be used to interact with hardware devices directly, such as USB drives, CD-ROMs, and printers.</li> <li>/etc (Configuration Files): The /etc directory contains configuration files for the system and applications installed on the system. These files include network configuration, user accounts, and system-wide configuration settings.</li> <li>/home (User Home Directories): The /home directory contains the home directories for individual users on the system. Each user has a subdirectory in the /home directory that contains their personal files and settings.</li> <li>/lib (Essential Shared Libraries): The /lib directory contains essential shared libraries that are required by system binaries and other applications on the system.</li> <li>/media (Removable Media): The /media directory is used for mounting removable media, such as USB drives, CD-ROMs, and DVDs.</li> <li>/mnt (Mount Point for File Systems): The /mnt directory is used for mounting other file systems, such as network file systems or other hard drives.</li> <li>/opt (Optional Software): The /opt directory is used for optional software installed on the system. This directory can be used for installing software that is not included in the system\u2019s package manager.</li> <li>/proc (Process Information): The /proc directory contains virtual files that provide information about the system and running processes. These files can be used to monitor system performance and diagnose issues.</li> <li>/root (Home Directory for root User): The /root directory is the home directory for the root user, the system administrator. This directory contains the personal files and settings for the root user.</li> <li>/run (Runtime Data): The /run directory contains runtime data for the system and applications, such as system logs, process IDs, and other temporary files.</li> <li>/sbin (System Binaries): The /sbin directory contains system binaries that are required for system administration tasks, such as fdisk and iptables.</li> <li>/srv (Service Data): The /srv directory contains data for services provided by the system, such as websites and FTP servers.</li> <li>/tmp (Temporary Files): The /tmp directory is used for storing temporary files that are created and used by applications.</li> <li>/usr (User Binaries and Libraries): The /usr directory contains user binaries and libraries for the system, such as system administration tools and development libraries.</li> <li>/var (Variable Data): The /var directory contains variable data for the system, such as system logs, mailboxes, and spool files.</li> </ol>"},{"location":"hidden/Linux/#oh-my-zsh","title":"Oh My Zsh","text":"<pre><code>dnf install zsh\n\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n</code></pre>"},{"location":"hidden/Linux/#luks","title":"LUKS","text":""},{"location":"hidden/Linux/#setup-automatic-unlock","title":"Setup automatic unlock:","text":"<pre><code>clevis luks bind -d /dev/mmcblkp3 tpm2 '{\"pcr_ids\":\"1,7\",\"key\":\"rsa\"}'\nsystemctl enable clevis-luks-askpass.path\ndracut --regenerate-all --force\n</code></pre>"},{"location":"hidden/Linux/#regenerate","title":"Regenerate","text":"<p>If automatic unlock does not work anymore it needs to be regenerated. First list the used slots: <pre><code>clevis luks list -d /dev/nvme0n1p3\n</code></pre></p> <p>Then regenerate using slot <pre><code>clevis luks regen -d /dev/nvme0n1p3 -s 1\n</code></pre></p>"},{"location":"hidden/Linux/#change-pcrs","title":"Change PCRs","text":"<p>To change PCRs you first need to delete the key and then re-add using the wanted PCRs. List the used slots:</p> <p><pre><code>clevis luks list -d /dev/nvme0n1p3\n</code></pre> Remove the slot: <pre><code>clevis luks unbind -d /dev/nvme0n1p3 -s 1 -f\n</code></pre></p> <p>Note:\u2003<code>-f</code>\u2003will not ask for confirmation but is needed if there is no other slot set up.</p> <p>After that re-add the key like above.</p>"},{"location":"hidden/Linux/#obs-virtual-cam","title":"OBS Virtual Cam","text":"<p>Install v4l2loopback <pre><code>sudo dnf install https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm\nsudo dnf install v4l2loopback \n</code></pre></p> <pre><code>git clone https://github.com/umlaeute/v4l2loopback\n</code></pre>"},{"location":"hidden/Liskov%20Substitution%20Principle/","title":"Liskov Substitution Principle","text":"","tags":["cleancode"]},{"location":"hidden/Liskov%20Substitution%20Principle/#liskov-substitution-principle","title":"Liskov Substitution Principle","text":"<p>Warum?</p> <p>Wer mit Erben zu tun hat, m\u00f6chte keine \u00dcberraschungen erleben, wenn er mit Erblassern vertraut ist.</p> <p>Auch das Liskov Substitution Principle (LSP) ist ein\u2003SOLID\u2003Prinzip. Es besagt, dass Subtypen sich so verhalten m\u00fcssen wie ihr Basistyp. Dies klingt zun\u00e4chst banal. Am Beispiel von Exceptions wird deutlich, welche Probleme entstehen, wenn das Prinzip verletzt wird: L\u00f6st der Basistyp bei der Ausf\u00fchrung einer Methode keine Exception aus, m\u00fcssen alle Subtypen sich an diese Regel halten. L\u00f6st die Methode eines Subtyps dennoch eine Exception aus, w\u00fcrde dies bei Verwendern, die ein Objekt vom Basistyp erwarten, Probleme verursachen, weil sie nicht darauf vorbereitet sind. Wenn der Basistyp an der Stelle keine Exception ausl\u00f6st, ist der Verwender nicht darauf eingestellt, Exceptions behandeln zu m\u00fcssen.</p> <p>Allgemeiner kann man das Prinzip auch so ausdr\u00fccken, dass ein Subtyp die Funktionalit\u00e4t eines Basistyps lediglich erweitern, aber nicht einschr\u00e4nken darf. Wenn eine Methode im Basistyp auf einem bestimmten Wertebereich definiert ist, darf der Subtyp diesen Wertebereich \u00fcbernehmen oder auch erweitern, er darf ihn jedoch keinesfall einschr\u00e4nken.</p> <p>Aus dem Liskov Substitution Principle ergibt sich ferner die Empfehlung, \u00fcber Vererbung sehr genau nachzudenken. In den allermeisten F\u00e4llen ist die Komposition der Vererbung vorzuziehen (Favour Composition over Inheritance). Bei der Vererbung sollte man in jedem Fall \u00fcber das Verhalten nachdenken, nicht nur \u00fcber die Struktur. Statt Vererbung als_is-a_\u2003Relation zu betrachten und dabei nur die (Daten-)Struktur zu bedenken, sollte man besser von einer\u2003behaves-as\u2003Relation ausgehen und das Verhalten der Klasse ber\u00fccksichtigen.</p>","tags":["cleancode"]},{"location":"hidden/Mediator/","title":"Mediator","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Mediator/#mediator","title":"Mediator","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Mediator/#intent","title":"Intent","text":"<p>Mediator\u2003is a behavioral design pattern that lets you reduce chaotic dependencies between objects. The pattern restricts direct communications between the objects and forces them to collaborate only via a mediator\u2003object.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Mediator/#problem","title":"Problem","text":"<p>Say you have a dialog for creating and editing customer profiles. It consists of various form controls such as text fields, checkboxes, buttons,\u2003etc.</p> <p></p> <p>Relations between elements of the user interface can become chaotic as the application\u2003evolves.</p> <p>Some of the form elements may interact with others. For instance, selecting the \u201cI have a dog\u201d checkbox may reveal a hidden text field for entering the dog\u2019s name. Another example is the submit button that has to validate values of all fields before saving the data.</p> <p></p> <p>Elements can have lots of relations with other elements. Hence, changes to some elements may affect the\u2003others.</p> <p>By having this logic implemented directly inside the code of the form elements you make these elements\u2019 classes much harder to reuse in other forms of the app. For example, you won\u2019t be able to use that checkbox class inside another form, because it\u2019s coupled to the dog\u2019s text field. You can use either all the classes involved in rendering the profile form, or none at all.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Mediator/#solution","title":"Solution","text":"<p>The Mediator pattern suggests that you should cease all direct communication between the components which you want to make independent of each other. Instead, these components must collaborate indirectly, by calling a special mediator object that redirects the calls to appropriate components. As a result, the components depend only on a single mediator class instead of being coupled to dozens of their colleagues.</p> <p>In our example with the profile editing form, the dialog class itself may act as the mediator. Most likely, the dialog class is already aware of all of its sub-elements, so you won\u2019t even need to introduce new dependencies into this class.</p> <p></p> <p>UI elements should communicate indirectly, via the mediator\u2003object.</p> <p>The most significant change happens to the actual form elements. Let\u2019s consider the submit button. Previously, each time a user clicked the button, it had to validate the values of all individual form elements. Now its single job is to notify the dialog about the click. Upon receiving this notification, the dialog itself performs the validations or passes the task to the individual elements. Thus, instead of being tied to a dozen form elements, the button is only dependent on the dialog class.</p> <p>You can go further and make the dependency even looser by extracting the common interface for all types of dialogs. The interface would declare the notification method which all form elements can use to notify the dialog about events happening to those elements. Thus, our submit button should now be able to work with any dialog that implements that interface.</p> <p>This way, the Mediator pattern lets you encapsulate a complex web of relations between various objects inside a single mediator object. The fewer dependencies a class has, the easier it becomes to modify, extend or reuse that class.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Mediator/#real-world-analogy","title":"Real-World Analogy","text":"<p>Aircraft pilots don\u2019t talk to each other directly when deciding who gets to land their plane next. All communication goes through the control\u2003tower.</p> <p>Pilots of aircraft that approach or depart the airport control area don\u2019t communicate directly with each other. Instead, they speak to an air traffic controller, who sits in a tall tower somewhere near the airstrip. Without the air traffic controller, pilots would need to be aware of every plane in the vicinity of the airport, discussing landing priorities with a committee of dozens of other pilots. That would probably skyrocket the airplane crash statistics.</p> <p>The tower doesn\u2019t need to control the whole flight. It exists only to enforce constraints in the terminal area because the number of involved actors there might be overwhelming to a pilot.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Mediator/#structure","title":"Structure","text":"<ol> <li> <p>Components\u2003are various classes that contain some business logic. Each component has a reference to a mediator, declared with the type of the mediator interface. The component isn\u2019t aware of the actual class of the mediator, so you can reuse the component in other programs by linking it to a different mediator.</p> </li> <li> <p>The\u2003Mediator\u2003interface declares methods of communication with components, which usually include just a single notification method. Components may pass any context as arguments of this method, including their own objects, but only in such a way that no coupling occurs between a receiving component and the sender\u2019s class.</p> </li> <li> <p>Concrete Mediators\u2003encapsulate relations between various components. Concrete mediators often keep references to all components they manage and sometimes even manage their lifecycle.</p> </li> <li> <p>Components must not be aware of other components. If something important happens within or to a component, it must only notify the mediator. When the mediator receives the notification, it can easily identify the sender, which might be just enough to decide what component should be triggered in return.</p> <p>From a component\u2019s perspective, it all looks like a total black box. The sender doesn\u2019t know who\u2019ll end up handling its request, and the receiver doesn\u2019t know who sent the request in the first place.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Mediator/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Mediator\u2003pattern helps you eliminate mutual dependencies between various UI classes: buttons, checkboxes and text labels.</p> <p></p> <p>Structure of the UI dialog\u2003classes.</p> <p>An element, triggered by a user, doesn\u2019t communicate with other elements directly, even if it looks like it\u2019s supposed to. Instead, the element only needs to let its mediator know about the event, passing any contextual info along with that notification.</p> <p>In this example, the whole authentication dialog acts as the mediator. It knows how concrete elements are supposed to collaborate and facilitates their indirect communication. Upon receiving a notification about an event, the dialog decides what element should address the event and redirects the call accordingly.</p> <pre><code>// The mediator interface declares a method used by components\n// to notify the mediator about various events. The mediator may\n// react to these events and pass the execution to other\n// components.\ninterface Mediator is\n    method notify(sender: Component, event: string)\n\n// The concrete mediator class. The intertwined web of\n// connections between individual components has been untangled\n// and moved into the mediator.\nclass AuthenticationDialog implements Mediator is\n    private field title: string\n    private field loginOrRegisterChkBx: Checkbox\n    private field loginUsername, loginPassword: Textbox\n    private field registrationUsername, registrationPassword,\n                  registrationEmail: Textbox\n    private field okBtn, cancelBtn: Button\n\n    constructor AuthenticationDialog() is\n        // Create all component objects by passing the current\n        // mediator into their constructors to establish links.\n\n    // When something happens with a component, it notifies the\n    // mediator. Upon receiving a notification, the mediator may\n    // do something on its own or pass the request to another\n    // component.\n    method notify(sender, event) is\n        if (sender == loginOrRegisterChkBx and event == \"check\")\n            if (loginOrRegisterChkBx.checked)\n                title = \"Log in\"\n                // 1. Show login form components.\n                // 2. Hide registration form components.\n            else\n                title = \"Register\"\n                // 1. Show registration form components.\n                // 2. Hide login form components\n\n        if (sender == okBtn &amp;&amp; event == \"click\")\n            if (loginOrRegister.checked)\n                // Try to find a user using login credentials.\n                if (!found)\n                    // Show an error message above the login\n                    // field.\n            else\n                // 1. Create a user account using data from the\n                // registration fields.\n                // 2. Log that user in.\n                // ...\n\n// Components communicate with a mediator using the mediator\n// interface. Thanks to that, you can use the same components in\n// other contexts by linking them with different mediator\n// objects.\nclass Component is\n    field dialog: Mediator\n\n    constructor Component(dialog) is\n        this.dialog = dialog\n\n    method click() is\n        dialog.notify(this, \"click\")\n\n    method keypress() is\n        dialog.notify(this, \"keypress\")\n\n// Concrete components don't talk to each other. They have only\n// one communication channel, which is sending notifications to\n// the mediator.\nclass Button extends Component is\n    // ...\n\nclass Textbox extends Component is\n    // ...\n\nclass Checkbox extends Component is\n    method check() is\n        dialog.notify(this, \"check\")\n    // ...\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/Mediator/#applicability","title":"Applicability","text":"<ul> <li>Use the Mediator pattern when it\u2019s hard to change some of the classes because they are tightly coupled to a bunch of other classes.     \u2003The pattern lets you extract all the relationships between classes into a separate class, isolating any changes to a specific component from the rest of the components.</li> <li>Use the pattern when you can\u2019t reuse a component in a different program because it\u2019s too dependent on other components.     \u2003After you apply the Mediator, individual components become unaware of the other components. They could still communicate with each other, albeit indirectly, through a mediator object. To reuse a component in a different app, you need to provide it with a new mediator class.</li> <li>Use the Mediator when you find yourself creating tons of component subclasses just to reuse some basic behavior in various contexts.     Since all relations between components are contained within the mediator, it\u2019s easy to define entirely new ways for these components to collaborate by introducing new mediator classes, without having to change the components themselves.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Mediator/#how-to-implement","title":"How to Implement","text":"<ol> <li> <p>Identify a group of tightly coupled classes which would benefit from being more independent (e.g., for easier maintenance or simpler reuse of these classes).</p> </li> <li> <p>Declare the mediator interface and describe the desired communication protocol between mediators and various components. In most cases, a single method for receiving notifications from components is sufficient.</p> <p>This interface is crucial when you want to reuse component classes in different contexts. As long as the component works with its mediator via the generic interface, you can link the component with a different implementation of the mediator.</p> </li> <li> <p>Implement the concrete mediator class. Consider storing references to all components inside the mediator. This way, you could call any component from the mediator\u2019s methods.</p> </li> <li> <p>You can go even further and make the mediator responsible for the creation and destruction of component objects. After this, the mediator may resemble a\u2003Factory\u2003or a\u2003Facade.</p> </li> <li> <p>Components should store a reference to the mediator object. The connection is usually established in the component\u2019s constructor, where a mediator object is passed as an argument.</p> </li> <li> <p>Change the components\u2019 code so that they call the mediator\u2019s notification method instead of methods on other components. Extract the code that involves calling other components into the mediator class. Execute this code whenever the mediator receives notifications from that component.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Mediator/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons Single Responsibility Principle. You can extract the communications between various components into a single place, making it easier to comprehend and maintain. \u2003Over time a mediator can evolve into a\u2003God Object. Open Closed Principle. You can introduce new mediators without having to change the actual components. You can reduce coupling between various components of a program. You can reuse individual components more easily.","tags":["cleancode_designpatterns"]},{"location":"hidden/Mediator/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:<ul> <li>Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.</li> <li>Command establishes unidirectional connections between senders and receivers.</li> <li>Mediator eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.</li> <li>Observer lets receivers dynamically subscribe to and unsubscribe from receiving requests.</li> </ul> </li> <li>Facade and Mediator have similar jobs: they try to organize collaboration between lots of tightly coupled classes.<ul> <li>Facade defines a simplified interface to a subsystem of objects, but it doesn\u2019t introduce any new functionality. The subsystem itself is unaware of the Facade. Objects within the subsystem can communicate directly.</li> <li>Mediator centralizes communication between components of the system. The components only know about the mediator object and don\u2019t communicate directly.</li> </ul> </li> <li> <p>The difference between Mediator and Observer is often elusive. In most cases, you can implement either of these patterns; but sometimes you can apply both simultaneously. Let\u2019s see how we can do that.</p> <p>The primary goal of Mediator is to eliminate mutual dependencies among a set of system components. Instead, these components become dependent on a single mediator object. The goal of Observer is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.</p> <p>There\u2019s a popular implementation of the Mediator pattern that relies on Observer. The mediator object plays the role of publisher, and the components act as subscribers which subscribe to and unsubscribe from the mediator\u2019s events. When Mediator is implemented this way, it may look very similar to Observer.</p> <p>When you\u2019re confused, remember that you can implement the Mediator pattern in other ways. For example, you can permanently link all the components to the same mediator object. This implementation won\u2019t resemble Observer but will still be an instance of the Mediator pattern.</p> <p>Now imagine a program where all components have become publishers, allowing dynamic connections between each other. There won\u2019t be a centralized mediator object, only a distributed set of observers.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Memento/","title":"Memento","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Memento/#memento","title":"Memento","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Memento/#intent","title":"Intent","text":"<p>Memento\u2003is a behavioral design pattern that lets you save and restore the previous state of an object without revealing the details of its\u2003implementation.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Memento/#problem","title":"Problem","text":"<p>Imagine that you\u2019re creating a text editor app. In addition to simple text editing, your editor can format text, insert inline images,\u2003etc.</p> <p>At some point, you decided to let users undo any operations carried out on the text. This feature has become so common over the years that nowadays people expect every app to have it. For the implementation, you chose to take the direct approach. Before performing any operation, the app records the state of all objects and saves it in some storage. Later, when a user decides to revert an action, the app fetches the latest snapshot from the history and uses it to restore the state of all objects.</p> <p></p> <p>Before executing an operation, the app saves a snapshot of the objects\u2019 state, which can later be used to restore objects to their previous\u2003state.</p> <p>Let\u2019s think about those state snapshots. How exactly would you produce one? You\u2019d probably need to go over all the fields in an object and copy their values into storage. However, this would only work if the object had quite relaxed access restrictions to its contents. Unfortunately, most real objects won\u2019t let others peek inside them that easily, hiding all significant data in private fields.</p> <p>Ignore that problem for now and let\u2019s assume that our objects behave like hippies: preferring open relations and keeping their state public. While this approach would solve the immediate problem and let you produce snapshots of objects\u2019 states at will, it still has some serious issues. In the future, you might decide to refactor some of the editor classes, or add or remove some of the fields. Sounds easy, but this would also require changing the classes responsible for copying the state of the affected objects.</p> <p></p> <p>How to make a copy of the object\u2019s private\u2003state?</p> <p>But there\u2019s more. Let\u2019s consider the actual \u201csnapshots\u201d of the editor\u2019s state. What data does it contain? At a bare minimum, it must contain the actual text, cursor coordinates, current scroll position,\u2003etc. To make a snapshot, you\u2019d need to collect these values and put them into some kind of container.</p> <p>Most likely, you\u2019re going to store lots of these container objects inside some list that would represent the history. Therefore the containers would probably end up being objects of one class. The class would have almost no methods, but lots of fields that mirror the editor\u2019s state. To allow other objects to write and read data to and from a snapshot, you\u2019d probably need to make its fields public. That would expose all the editor\u2019s states, private or not. Other classes would become dependent on every little change to the snapshot class, which would otherwise happen within private fields and methods without affecting outer classes.</p> <p>It looks like we\u2019ve reached a dead end: you either expose all internal details of classes, making them too fragile, or restrict access to their state, making it impossible to produce snapshots. Is there any other way to implement the \u201cundo\u201d?</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Memento/#solution","title":"Solution","text":"<p>All problems that we\u2019ve just experienced are caused by broken encapsulation. Some objects try to do more than they are supposed to. To collect the data required to perform some action, they invade the private space of other objects instead of letting these objects perform the actual action.</p> <p>The Memento pattern delegates creating the state snapshots to the actual owner of that state, the\u2003originator\u2003object. Hence, instead of other objects trying to copy the editor\u2019s state from the \u201coutside,\u201d the editor class itself can make the snapshot since it has full access to its own state.</p> <p>The pattern suggests storing the copy of the object\u2019s state in a special object called\u2003memento. The contents of the memento aren\u2019t accessible to any other object except the one that produced it. Other objects must communicate with mementos using a limited interface which may allow fetching the snapshot\u2019s metadata (creation time, the name of the performed operation,\u2003etc.), but not the original object\u2019s state contained in the snapshot.</p> <p></p> <p>The originator has full access to the memento, whereas the caretaker can only access the\u2003metadata.</p> <p>Such a restrictive policy lets you store mementos inside other objects, usually called\u2003caretakers. Since the caretaker works with the memento only via the limited interface, it\u2019s not able to tamper with the state stored inside the memento. At the same time, the originator has access to all fields inside the memento, allowing it to restore its previous state at will.</p> <p>In our text editor example, we can create a separate history class to act as the caretaker. A stack of mementos stored inside the caretaker will grow each time the editor is about to execute an operation. You could even render this stack within the app\u2019s UI, displaying the history of previously performed operations to a user.</p> <p>When a user triggers the undo, the history grabs the most recent memento from the stack and passes it back to the editor, requesting a roll-back. Since the editor has full access to the memento, it changes its own state with the values taken from the memento.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Memento/#structure","title":"Structure","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Memento/#implementation-based-on-nested-classes","title":"Implementation based on nested classes","text":"<p>The classic implementation of the pattern relies on support for nested classes, available in many popular programming languages (such as C++, C#, and Java).</p> <p></p> <ol> <li> <p>The\u2003Originator\u2003class can produce snapshots of its own state, as well as restore its state from snapshots when needed.</p> </li> <li> <p>The\u2003Memento\u2003is a value object that acts as a snapshot of the originator\u2019s state. It\u2019s a common practice to make the memento immutable and pass it the data only once, via the constructor.</p> </li> <li> <p>The\u2003Caretaker\u2003knows not only \u201cwhen\u201d and \u201cwhy\u201d to capture the originator\u2019s state, but also when the state should be restored.</p> <p>A caretaker can keep track of the originator\u2019s history by storing a stack of mementos. When the originator has to travel back in history, the caretaker fetches the topmost memento from the stack and passes it to the originator\u2019s restoration method.</p> </li> <li> <p>In this implementation, the memento class is nested inside the originator. This lets the originator access the fields and methods of the memento, even though they\u2019re declared private. On the other hand, the caretaker has very limited access to the memento\u2019s fields and methods, which lets it store mementos in a stack but not tamper with their state.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Memento/#implementation-based-on-an-intermediate-interface","title":"Implementation based on an intermediate interface","text":"<p>There\u2019s an alternative implementation, suitable for programming languages that don\u2019t support nested classes (yeah, PHP, I\u2019m talking about you).</p> <p></p> <ol> <li> <p>In the absence of nested classes, you can restrict access to the memento\u2019s fields by establishing a convention that caretakers can work with a memento only through an explicitly declared intermediary interface, which would only declare methods related to the memento\u2019s metadata.</p> </li> <li> <p>On the other hand, originators can work with a memento object directly, accessing fields and methods declared in the memento class. The downside of this approach is that you need to declare all members of the memento public.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Memento/#implementation-with-even-stricter-encapsulation","title":"Implementation with even stricter encapsulation","text":"<p>There\u2019s another implementation which is useful when you don\u2019t want to leave even the slightest chance of other classes accessing the state of the originator through the memento.</p> <p></p> <ol> <li> <p>This implementation allows having multiple types of originators and mementos. Each originator works with a corresponding memento class. Neither originators nor mementos expose their state to anyone.</p> </li> <li> <p>Caretakers are now explicitly restricted from changing the state stored in mementos. Moreover, the caretaker class becomes independent from the originator because the restoration method is now defined in the memento class.</p> </li> <li> <p>Each memento becomes linked to the originator that produced it. The originator passes itself to the memento\u2019s constructor, along with the values of its state. Thanks to the close relationship between these classes, a memento can restore the state of its originator, given that the latter has defined the appropriate setters.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Memento/#pseudocode","title":"Pseudocode","text":"<p>This example uses the Memento pattern alongside the\u2003Command\u2003pattern for storing snapshots of the complex text editor\u2019s state and restoring an earlier state from these snapshots when needed.</p> <p></p> <p>Saving snapshots of the text editor\u2019s\u2003state.</p> <p>The command objects act as caretakers. They fetch the editor\u2019s memento before executing operations related to commands. When a user attempts to undo the most recent command, the editor can use the memento stored in that command to revert itself to the previous state.</p> <p>The memento class doesn\u2019t declare any public fields, getters or setters. Therefore no object can alter its contents. Mementos are linked to the editor object that created them. This lets a memento restore the linked editor\u2019s state by passing the data via setters on the editor object. Since mementos are linked to specific editor objects, you can make your app support several independent editor windows with a centralized undo stack.</p> <pre><code>// The originator holds some important data that may change over\n// time. It also defines a method for saving its state inside a\n// memento and another method for restoring the state from it.\nclass Editor is\n    private field text, curX, curY, selectionWidth\n\n    method setText(text) is\n        this.text = text\n\n    method setCursor(x, y) is\n        this.curX = x\n        this.curY = y\n\n    method setSelectionWidth(width) is\n        this.selectionWidth = width\n\n    // Saves the current state inside a memento.\n    method createSnapshot():Snapshot is\n        // Memento is an immutable object; that's why the\n        // originator passes its state to the memento's\n        // constructor parameters.\n        return new Snapshot(this, text, curX, curY, selectionWidth)\n\n// The memento class stores the past state of the editor.\nclass Snapshot is\n    private field editor: Editor\n    private field text, curX, curY, selectionWidth\n\n    constructor Snapshot(editor, text, curX, curY, selectionWidth) is\n        this.editor = editor\n        this.text = text\n        this.curX = x\n        this.curY = y\n        this.selectionWidth = selectionWidth\n\n    // At some point, a previous state of the editor can be\n    // restored using a memento object.\n    method restore() is\n        editor.setText(text)\n        editor.setCursor(curX, curY)\n        editor.setSelectionWidth(selectionWidth)\n\n// A command object can act as a caretaker. In that case, the\n// command gets a memento just before it changes the\n// originator's state. When undo is requested, it restores the\n// originator's state from a memento.\nclass Command is\n    private field backup: Snapshot\n\n    method makeBackup() is\n        backup = editor.createSnapshot()\n\n    method undo() is\n        if (backup != null)\n            backup.restore()\n    // ...\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/Memento/#applicability","title":"Applicability","text":"<ul> <li>Use the Memento pattern when you want to produce snapshots of the object\u2019s state to be able to restore a previous state of the object.     The Memento pattern lets you make full copies of an object\u2019s state, including private fields, and store them separately from the object. While most people remember this pattern thanks to the \u201cundo\u201d use case, it\u2019s also indispensable when dealing with transactions (i.e., if you need to roll back an operation on error).</li> <li>Use the pattern when direct access to the object\u2019s fields/getters/setters violates its encapsulation.     The Memento makes the object itself responsible for creating a snapshot of its state. No other object can read the snapshot, making the original object\u2019s state data safe and secure.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Memento/#how-to-implement","title":"How to Implement","text":"<ol> <li> <p>Determine what class will play the role of the originator. It\u2019s important to know whether the program uses one central object of this type or multiple smaller ones.</p> </li> <li> <p>Create the memento class. One by one, declare a set of fields that mirror the fields declared inside the originator class.</p> </li> <li> <p>Make the memento class immutable. A memento should accept the data just once, via the constructor. The class should have no setters.</p> </li> <li> <p>If your programming language supports nested classes, nest the memento inside the originator. If not, extract a blank interface from the memento class and make all other objects use it to refer to the memento. You may add some metadata operations to the interface, but nothing that exposes the originator\u2019s state.</p> </li> <li> <p>Add a method for producing mementos to the originator class. The originator should pass its state to the memento via one or multiple arguments of the memento\u2019s constructor.</p> <p>The return type of the method should be of the interface you extracted in the previous step (assuming that you extracted it at all). Under the hood, the memento-producing method should work directly with the memento class.</p> </li> <li> <p>Add a method for restoring the originator\u2019s state to its class. It should accept a memento object as an argument. If you extracted an interface in the previous step, make it the type of the parameter. In this case, you need to typecast the incoming object to the memento class, since the originator needs full access to that object.</p> </li> <li> <p>The caretaker, whether it represents a command object, a history, or something entirely different, should know when to request new mementos from the originator, how to store them and when to restore the originator with a particular memento.</p> </li> <li> <p>The link between caretakers and originators may be moved into the memento class. In this case, each memento must be connected to the originator that had created it. The restoration method would also move to the memento class. However, this would all make sense only if the memento class is nested into originator or the originator class provides sufficient setters for overriding its state.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Memento/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can produce snapshots of the object\u2019s state without violating its encapsulation. The app might consume lots of RAM if clients create mementos too often. You can simplify the originator\u2019s code by letting the caretaker maintain the history of the originator\u2019s state. Caretakers should track the originator\u2019s lifecycle to be able to destroy obsolete mementos. Most dynamic programming languages, such as PHP, Python and JavaScript, can\u2019t guarantee that the state within the memento stays untouched.","tags":["cleancode_designpatterns"]},{"location":"hidden/Memento/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>You can use Command and Memento together when implementing \u201cundo\u201d. In this case, commands are responsible for performing various operations over a target object, while mementos save the state of that object just before a Command gets executed.</li> <li>You can use Memento along with Iterator to capture the current iteration state and roll it back if necessary.</li> <li>Sometimes Prototype can be a simpler alternative to Memento. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn\u2019t have links to external resources, or the links are easy to re-establish.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Message%20Queues/","title":"Message Queues","text":"<p>Source:</p> <p>https://www.baeldung.com/cs/message-queues</p>"},{"location":"hidden/Message%20Queues/#1-introduction","title":"1. Introduction","text":"<p>A response to a request in a real-world application is not always instantaneous. We often assume that our applications would process everything instantaneously, or in a REST API, we often believe that we discard all unsuccessful requests, but the reality is slightly different. We can often process these unsuccessful requests later, or we can also send responses asynchronously.</p> <p>In this tutorial, we\u2019ll take a look at how we can leverage message queues to achieve this.</p>"},{"location":"hidden/Message%20Queues/#2-asynchronous-and-synchronous-communication","title":"2. Asynchronous and Synchronous Communication","text":"<p>Asynchronous communication is a mode of communication where the sender and receiver are not required to be active simultaneously. It is often referred to as the fire-and-forget model of communication. Emails are a good example of asynchronous communication. A person can choose to read all their emails instantaneously or accumulate them to be read later at once. Similarly, a sender can send an email and move on to other tasks, without expecting an instantaneous reply.</p> <p>A telephone call can be an example of synchronous communication, where the sender and receiver interact in real-time, requiring both parties to be actively present and engaged simultaneously.</p> <p>Here is a diagram to illustrate the difference between asynchronous and synchronous communication:</p> <p></p>"},{"location":"hidden/Message%20Queues/#3-definition-of-message-queues","title":"3. Definition of Message Queues","text":"<p>We\u2019ll start by understanding the meaning of messages. In the context of a real-world software application, a message represents a piece of information that the application needs to process. This piece of information could be processed by another system or it can be an actual payload, like files or metadata that trigger some processing in another sub-system. Queues help in processing these messages sequentially.\u2003A message queue is like a buffer that receives messages in a specific order and forwards them to the concerned sub-system or application in the same order.</p> <p>Message queues decouple the sender and recipient, allowing them to operate independently and at their own pace. Consumers retrieve messages from the queue when they are ready to process them. They can retrieve and process messages independently and at their own pace, allowing for asynchronous processing.</p>"},{"location":"hidden/Message%20Queues/#4-examples-of-usage-of-message-queues","title":"4. Examples of Usage of Message Queues","text":"<p>Let\u2019s try to understand the scenarios in which message queues can be used through an example. Let\u2019s say we have a web form that requires some input. We might need to insert this data into a database or put it into another system for some marketing automation.</p> <p>These tasks if done in sync, can hamper the user experience as they might add some latency or slowness to the process. Thus, we can treat the inputs as messages and utilize a queue to process these messages based on our requirements. Meanwhile, the user can be redirected to another screen, displaying a predefined acknowledgment message.</p>"},{"location":"hidden/Message%20Queues/#5-common-terminologies-in-message-queues","title":"5. Common Terminologies in Message Queues","text":"<p>Let\u2019s go through some common terms used while working with message queues:</p>"},{"location":"hidden/Message%20Queues/#51-producer","title":"5.1. Producer","text":"<p>The producer, also known as the sender, generates and sends messages to the message queue.\u2003It creates and publishes messages that contain data, requests, or tasks to be processed by the consumer. The producer\u2019s role is to enqueue the messages into the message queue without waiting for an immediate response. A producer can be a software application, service, or any component that generates and sends messages.</p>"},{"location":"hidden/Message%20Queues/#52-consumer","title":"5.2. Consumer","text":"<p>The consumer, also known as the receiver, retrieves and processes messages from the message queue.\u2003It performs the necessary actions or operations based on the content of the messages. This can involve data processing, executing tasks, triggering workflows, or generating responses. Consumers can be separate software applications, services, or components designed to process specific messages or perform particular actions.</p>"},{"location":"hidden/Message%20Queues/#53-topic","title":"5.3. Topic","text":"<p>In the context of message queues, a topic refers to a mechanism that enables categorizing or grouping messages based on a specific subject or theme. It allows consumers to selectively subscribe to and receive messages based on their interest in specific topics. Topics enhance the flexibility and efficiency of message queues by allowing producers to categorize and target their messages while enabling consumers to consume messages based on their specific interests selectively.</p>"},{"location":"hidden/Message%20Queues/#54-message-broker","title":"5.4. Message Broker","text":"<p>In the context of message queues, a message broker is an intermediary component that facilitates the exchange of messages between producers and consumers.\u2003It acts as a central hub or mediator within the message queue system, responsible for receiving messages from producers, storing them, and delivering them to the appropriate consumers based on specified routing and subscription rules.</p>"},{"location":"hidden/Message%20Queues/#6-publisher-subscriber-model-in-message-queues","title":"6. Publisher-Subscriber Model in Message Queues","text":"<p>The\u2003publisher-subscriber\u2003model, also known as the pub-sub model, is a messaging pattern that facilitates communication between multiple publishers and multiple subscribers. In this model, publishers are responsible for producing messages, while subscribers receive and consume the messages based on their interests or subscriptions.</p> <p>Here\u2019s a simplified diagram illustrating the publisher-subscriber model:</p> <p></p> <p>In this diagram, Publisher 1 and Publisher 2 generate messages and publish them to the message queue. The message queue functions as an intermediary and retains the messages until the subscribers consume them. The subscribers (Subscriber 1, Subscriber 2, and Subscriber 3) subscribe to specific topics or channels of interest within the message queue. The message queue then delivers relevant messages to each subscriber based on their subscriptions, guaranteeing they receive only the messages aligned with their interests.</p> <p>The publisher-subscriber model allows for decoupling between publishers and subscribers. Publishers don\u2019t need to have direct knowledge of the subscribers, and subscribers can receive messages from multiple publishers. It provides a flexible and scalable approach for distributing messages to interested parties in a loosely coupled manner.</p>"},{"location":"hidden/Message%20Queues/#7-benefits-of-using-message-queues","title":"7. Benefits of Using Message Queues","text":"<p>Message queues help in decoupling parts of an application. While we can have a part that accepts data from the user, another part can process the data. Thus, we can move away from a huge monolithic application to a smaller, modular approach in development. By breaking it into smaller modules, we can test each module separately, without having to worry about all other parts in a system.</p> <p>Another benefit of decoupling is that different teams can work on different parts of the system in parallel and improve development times significantly. We can also improve scalability by allowing certain processing to happen async during high traffic, without affecting user experience.</p>"},{"location":"hidden/Message%20Queues/#8-conclusion","title":"8. Conclusion","text":"<p>In conclusion, message queues serve as a valuable tool for efficient and reliable communication in various applications. In this tutorial, we\u2019ve looked at message queues, the common terminologies used in message queues, the publisher-subscriber model, and some benefits of using message queues.</p>"},{"location":"hidden/Mockups/","title":"Mockups","text":"","tags":["cleancode"]},{"location":"hidden/Mockups/#mockups","title":"Mockups","text":"<p>Warum? Ohne Attrappen keine einfach kontrollierbaren Tests.</p> <p>In der Regel verwenden Komponenten andere Komponenten. Will man eine Komponente isoliert testen, m\u00fcssen diese Abh\u00e4ngigkeiten abgetrennt werden. Dabei interessiert uns nun ausschlie\u00dflich die Funktionalit\u00e4t der zu testenden Komponente (System Under Test (SUT)). Und es interessiert uns, wie die Komponente mit den anderen interagiert.</p> <p>Beim Isolieren verwenden wir sogenannte Mockups. Diese werden anstelle der echten Komponenten verwendet. So interagiert das System Under Test w\u00e4hrend der Tests mit gut kontrollierbaren Attrappen statt mit realen Komponenten.</p> <p>Die Literatur kennt noch andere Bezeichnungen f\u00fcr Attrappen wie\u2003Stub,\u2003Dummy\u2003oder\u2003Fake, die teilweise synonym zu Mockup benutzt werden, aber durchaus f\u00fcr\u2003unterschiedliche Funktionsweisen\u2003stehen. Bevor man ein Mock Framework wie z.B.\u2003Rhino Mocks\u2003verwendet, sollte man ein Mockup zun\u00e4chst \u201eper Hand\u201c implementieren. Dies hilft, den Mechanismus zu verstehen.</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"hidden/Model-View-Controller%20%28MVC%29/","title":"Model View Controller (MVC)","text":""},{"location":"hidden/Model-View-Controller%20%28MVC%29/#model","title":"Model","text":"<p>Manages the Data, independant from the user interface</p>"},{"location":"hidden/Model-View-Controller%20%28MVC%29/#view","title":"View","text":"<p>The visual representation of a model. Does not handle input</p>"},{"location":"hidden/Model-View-Controller%20%28MVC%29/#controller","title":"Controller","text":"<p>Accepts input and converts it to commands for the model or view.</p>"},{"location":"hidden/Model-View-ViewModel%20%28MVVM%29/","title":"Model View ViewModel (MVVM)","text":""},{"location":"hidden/Model-View-ViewModel%20%28MVVM%29/#model","title":"Model","text":"<p>The domain model of the application (oop)</p>"},{"location":"hidden/Model-View-ViewModel%20%28MVVM%29/#view","title":"View","text":"<p>The visual representation of the model.</p>"},{"location":"hidden/Model-View-ViewModel%20%28MVVM%29/#viewmodel","title":"ViewModel","text":"<p>Abstraction of the view with public properties and commands. The View direclty has bindings on the properties of the view model.</p>"},{"location":"hidden/Observer/","title":"Observer","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Observer/#observer","title":"Observer","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Observer/#intent","title":"Intent","text":"<p>Observer\u2003is a behavioral design pattern that lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they\u2019re\u2003observing.</p> <p></p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Observer/#problem","title":"Problem","text":"<p>Imagine that you have two types of objects: a\u2003<code>Customer</code>\u2003and a\u2003<code>Store</code>. The customer is very interested in a particular brand of product (say, it\u2019s a new model of the iPhone) which should become available in the store very soon.</p> <p>The customer could visit the store every day and check product availability. But while the product is still en route, most of these trips would be pointless.</p> <p></p> <p>Visiting the store vs. sending\u2003spam</p> <p>On the other hand, the store could send tons of emails (which might be considered spam) to all customers each time a new product becomes available. This would save some customers from endless trips to the store. At the same time, it\u2019d upset other customers who aren\u2019t interested in new products.</p> <p>It looks like we\u2019ve got a conflict. Either the customer wastes time checking product availability or the store wastes resources notifying the wrong customers.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Observer/#solution","title":"Solution","text":"<p>The object that has some interesting state is often called\u2003subject, but since it\u2019s also going to notify other objects about the changes to its state, we\u2019ll call it\u2003publisher. All other objects that want to track changes to the publisher\u2019s state are called\u2003subscribers.</p> <p>The Observer pattern suggests that you add a subscription mechanism to the publisher class so individual objects can subscribe to or unsubscribe from a stream of events coming from that publisher. Fear not! Everything isn\u2019t as complicated as it sounds. In reality, this mechanism consists of 1) an array field for storing a list of references to subscriber objects and 2) several public methods which allow adding subscribers to and removing them from that list.</p> <p></p> <p>A subscription mechanism lets individual objects subscribe to event\u2003notifications.</p> <p>Now, whenever an important event happens to the publisher, it goes over its subscribers and calls the specific notification method on their objects.</p> <p>Real apps might have dozens of different subscriber classes that are interested in tracking events of the same publisher class. You wouldn\u2019t want to couple the publisher to all of those classes. Besides, you might not even know about some of them beforehand if your publisher class is supposed to be used by other people.</p> <p>That\u2019s why it\u2019s crucial that all subscribers implement the same interface and that the publisher communicates with them only via that interface. This interface should declare the notification method along with a set of parameters that the publisher can use to pass some contextual data along with the notification.</p> <p></p> <p>Publisher notifies subscribers by calling the specific notification method on their\u2003objects.</p> <p>If your app has several different types of publishers and you want to make your subscribers compatible with all of them, you can go even further and make all publishers follow the same interface. This interface would only need to describe a few subscription methods. The interface would allow subscribers to observe publishers\u2019 states without coupling to their concrete classes.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Observer/#real-world-analogy","title":"Real-World Analogy","text":"<p>Magazine and newspaper\u2003subscriptions.</p> <p>If you subscribe to a newspaper or magazine, you no longer need to go to the store to check if the next issue is available. Instead, the publisher sends new issues directly to your mailbox right after publication or even in advance.</p> <p>The publisher maintains a list of subscribers and knows which magazines they\u2019re interested in. Subscribers can leave the list at any time when they wish to stop the publisher sending new magazine issues to them.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Observer/#structure","title":"Structure","text":"<ol> <li> <p>The\u2003Publisher\u2003issues events of interest to other objects. These events occur when the publisher changes its state or executes some behaviors. Publishers contain a subscription infrastructure that lets new subscribers join and current subscribers leave the list.</p> </li> <li> <p>When a new event happens, the publisher goes over the subscription list and calls the notification method declared in the subscriber interface on each subscriber object.</p> </li> <li> <p>The\u2003Subscriber\u2003interface declares the notification interface. In most cases, it consists of a single\u2003<code>update</code>\u2003method. The method may have several parameters that let the publisher pass some event details along with the update.</p> </li> <li> <p>Concrete Subscribers\u2003perform some actions in response to notifications issued by the publisher. All of these classes must implement the same interface so the publisher isn\u2019t coupled to concrete classes.</p> </li> <li> <p>Usually, subscribers need some contextual information to handle the update correctly. For this reason, publishers often pass some context data as arguments of the notification method. The publisher can pass itself as an argument, letting subscriber fetch any required data directly.</p> </li> <li> <p>The\u2003Client\u2003creates publisher and subscriber objects separately and then registers subscribers for publisher updates.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Observer/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Observer\u2003pattern lets the text editor object notify other service objects about changes in its state.</p> <p></p> <p>Notifying objects about events that happen to other\u2003objects.</p> <p>The list of subscribers is compiled dynamically: objects can start or stop listening to notifications at runtime, depending on the desired behavior of your app.</p> <p>In this implementation, the editor class doesn\u2019t maintain the subscription list by itself. It delegates this job to the special helper object devoted to just that. You could upgrade that object to serve as a centralized event dispatcher, letting any object act as a publisher.</p> <p>Adding new subscribers to the program doesn\u2019t require changes to existing publisher classes, as long as they work with all subscribers through the same interface. <pre><code>// The base publisher class includes subscription management\n// code and notification methods.\nclass EventManager is\n    private field listeners: hash map of event types and listeners\n\n    method subscribe(eventType, listener) is\n        listeners.add(eventType, listener)\n\n    method unsubscribe(eventType, listener) is\n        listeners.remove(eventType, listener)\n\n    method notify(eventType, data) is\n        foreach (listener in listeners.of(eventType)) do\n            listener.update(data)\n\n// The concrete publisher contains real business logic that's\n// interesting for some subscribers. We could derive this class\n// from the base publisher, but that isn't always possible in\n// real life because the concrete publisher might already be a\n// subclass. In this case, you can patch the subscription logic\n// in with composition, as we did here.\nclass Editor is\n    public field events: EventManager\n    private field file: File\n\n    constructor Editor() is\n        events = new EventManager()\n\n    // Methods of business logic can notify subscribers about\n    // changes.\n    method openFile(path) is\n        this.file = new File(path)\n        events.notify(\"open\", file.name)\n\n    method saveFile() is\n        file.write()\n        events.notify(\"save\", file.name)\n\n    // ...\n\n// Here's the subscriber interface. If your programming language\n// supports functional types, you can replace the whole\n// subscriber hierarchy with a set of functions.\ninterface EventListener is\n    method update(filename)\n\n// Concrete subscribers react to updates issued by the publisher\n// they are attached to.\nclass LoggingListener implements EventListener is\n    private field log: File\n    private field message: string\n\n    constructor LoggingListener(log_filename, message) is\n        this.log = new File(log_filename)\n        this.message = message\n\n    method update(filename) is\n        log.write(replace('%s',filename,message))\n\nclass EmailAlertsListener implements EventListener is\n    private field email: string\n    private field message: string\n\n    constructor EmailAlertsListener(email, message) is\n        this.email = email\n        this.message = message\n\n    method update(filename) is\n        system.email(email, replace('%s',filename,message))\n\n// An application can configure publishers and subscribers at\n// runtime.\nclass Application is\n    method config() is\n        editor = new Editor()\n\n        logger = new LoggingListener(\n            \"/path/to/log.txt\",\n            \"Someone has opened the file: %s\")\n        editor.events.subscribe(\"open\", logger)\n\n        emailAlerts = new EmailAlertsListener(\n            \"admin@example.com\",\n            \"Someone has changed the file: %s\")\n        editor.events.subscribe(\"save\", emailAlerts)\n</code></pre></p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Observer/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Observer pattern when changes to the state of one object may require changing other objects, and the actual set of objects is unknown beforehand or changes dynamically.</p> <p>You can often experience this problem when working with classes of the graphical user interface. For example, you created custom button classes, and you want to let the clients hook some custom code to your buttons so that it fires whenever a user presses a button.</p> <p>The Observer pattern lets any object that implements the subscriber interface subscribe for event notifications in publisher objects. You can add the subscription mechanism to your buttons, letting the clients hook up their custom code via custom subscriber classes.</p> </li> <li> <p>Use the pattern when some objects in your app must observe others, but only for a limited time or in specific cases.     \u2003The subscription list is dynamic, so subscribers can join or leave the list whenever they need to.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Observer/#how-to-implement","title":"How to Implement","text":"<ol> <li>Look over your business logic and try to break it down into two parts: the core functionality, independent from other code, will act as the publisher; the rest will turn into a set of subscriber classes.</li> <li>Declare the subscriber interface. At a bare minimum, it should declare a single\u2003<code>update</code>\u2003method.</li> <li>Declare the publisher interface and describe a pair of methods for adding a subscriber object to and removing it from the list. Remember that publishers must work with subscribers only via the subscriber interface.</li> <li> <p>Decide where to put the actual subscription list and the implementation of subscription methods. Usually, this code looks the same for all types of publishers, so the obvious place to put it is in an abstract class derived directly from the publisher interface. Concrete publishers extend that class, inheriting the subscription behavior.</p> <p>However, if you\u2019re applying the pattern to an existing class hierarchy, consider an approach based on composition: put the subscription logic into a separate object, and make all real publishers use it.</p> </li> <li> <p>Create concrete publisher classes. Each time something important happens inside a publisher, it must notify all its subscribers.</p> </li> <li> <p>Implement the update notification methods in concrete subscriber classes. Most subscribers would need some context data about the event. It can be passed as an argument of the notification method.</p> <p>But there\u2019s another option. Upon receiving a notification, the subscriber can fetch any data directly from the notification. In this case, the publisher must pass itself via the update method. The less flexible option is to link a publisher to the subscriber permanently via the constructor.</p> </li> <li> <p>The client must create all necessary subscribers and register them with proper publishers.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Observer/#pros-and-cons","title":"Pros and Cons","text":"Pros Cons Open Closed Principle. You can introduce new subscriber classes without having to change the publisher\u2019s code (and vice versa if there\u2019s a publisher interface). Subscribers are notified in random order. \u2003You can establish relations between objects at runtime.","tags":["cleancode_designpatterns"]},{"location":"hidden/Observer/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li> <p>Chain of Responsibility,\u2003Command,\u2003Mediator\u2003and\u2003Observer\u2003address various ways of connecting senders and receivers of requests:</p> <ul> <li>Chain of Responsibility\u2003passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.</li> <li>Command\u2003establishes unidirectional connections between senders and receivers.</li> <li>Mediator\u2003eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.</li> <li>Observer\u2003lets receivers dynamically subscribe to and unsubscribe from receiving requests.</li> <li>The difference between\u2003Mediator\u2003and\u2003Observer\u2003is often elusive. In most cases, you can implement either of these patterns; but sometimes you can apply both simultaneously. Let\u2019s see how we can do that.</li> </ul> <p>The primary goal of\u2003Mediator\u2003is to eliminate mutual dependencies among a set of system components. Instead, these components become dependent on a single mediator object. The goal of\u2003Observer\u2003is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.</p> <p>There\u2019s a popular implementation of the\u2003Mediator\u2003pattern that relies on\u2003Observer. The mediator object plays the role of publisher, and the components act as subscribers which subscribe to and unsubscribe from the mediator\u2019s events. When\u2003Mediator\u2003is implemented this way, it may look very similar to\u2003Observer.</p> <p>When you\u2019re confused, remember that you can implement the Mediator pattern in other ways. For example, you can permanently link all the components to the same mediator object. This implementation won\u2019t resemble\u2003Observer\u2003but will still be an instance of the Mediator pattern.</p> <p>Now imagine a program where all components have become publishers, allowing dynamic connections between each other. There won\u2019t be a centralized mediator object, only a distributed set of observers.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Open%20Closed%20Principle/","title":"Open Closed Principle (OCP)","text":"","tags":["cleancode"]},{"location":"hidden/Open%20Closed%20Principle/#open-closed-principle-ocp","title":"Open Closed Principle (OCP)","text":"<p>Warum?</p> <p>Weil das Risiko, durch neue Features ein bisher fehlerfreies System zu instabilisieren, so gering wie m\u00f6glich gehalten werden sollte.</p> <p>Das\u2003Open Closed Principle (OCP) besagt, dass eine Klasse offen f\u00fcr Erweiterungen sein muss, jedoch geschlossen gegen\u00fcber Modifikationen. Es ist ein weiteres der SOLID-Prinzipien</p> <p>Prinzipien. Folgendes Codebeispiel soll verdeutlichen, wo das Problem liegt, wenn das Prinzip nicht befolgt wird:</p> <pre><code>public double Preis() {\n\n&amp;emsp; &amp;emsp; const decimal StammkundenRabatt = 0.95m;\n\n&amp;emsp; &amp;emsp; switch(kundenart) {\n\n&amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; case Kundenart.Einmalkunde:\n\n&amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; return menge * einzelpreis;\n\n&amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; case Kundenart.Stammkunde:\n\n&amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; return menge * einzelpreis * StammkundenRabatt;\n\n&amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; default:\n\n&amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; throw new ArgumentOutOfRangeException();\n\n&amp;emsp; &amp;emsp; }\n&amp;emsp; &amp;emsp; \n}\n</code></pre> <p>Das problematische an dieser Form der Implementierung ist, dass die Klasse modifiziert werden muss, wenn eine weitere Art der Preisberechnung erforderlich wird. Die Gefahr dabei ist, dass bei dieser Modifikation Fehler gemacht werden und die bisher schon vorhandenen Funktionen nicht mehr ordnungsgem\u00e4\u00df funktionieren. Auch wenn automatisierte Unit Tests und Integrationstests vorhanden sind besteht das Risiko, neue Bugs zu hinterlassen, weil man keine hundertprozentige Testabdeckung erreichen kann. Gesucht ist also generell ein Verfahren, welches die Klasse erweiterbar macht, ohne dass dazu die Klasse selbst modifiziert werden muss. Dies kann z.B. mit Hilfe des\u2003Strategy Patterns erreicht werden:</p> <pre><code>public interface IPreisRechner {\n\n&amp;emsp; &amp;emsp; double Preis(int menge, double einzelpreis);\n\n}\n\nprivate IPreisRechner preisRechner;\n\npublic double Preis() {\n&amp;emsp; &amp;emsp; return preisRechner.Preis(menge, einzelpreis);\n} \n\npublic class Einmalkunde : IPreisRechner {\n\n&amp;emsp; &amp;emsp; public double Preis(int menge, double einzelpreis) {\n&amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; return menge * einzelpreis;\n&amp;emsp; &amp;emsp; }\n\n}\npublic class Stammkunde : IPreisRechner {\n\n&amp;emsp; &amp;emsp; const decimal StammkundenRabatt = 0.95m;\n&amp;emsp; &amp;emsp; \n&amp;emsp; &amp;emsp; public double Preis(int menge, double einzelpreis) {\n&amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; return menge * einzelpreis * StammkundenRabatt;\n&amp;emsp; &amp;emsp; }\n\n}\n</code></pre> <p>Die konkrete Berechnung des Preises wird \u00fcber ein Interface in andere Klassen ausgelagert. Dadurch ist es m\u00f6glich, jederzeit neue Implementierungen des Interfaces zu erg\u00e4nzen. Damit ist die Klasse offen f\u00fcr Erweiterungen, gleichzeitig aber geschlossen gegen\u00fcber Modifikationen. Bestehender Code kann z.B. mit dem Refactoring Replace Conditional with Strategy so umgestaltet werden, dass das Open Closed Principle eingehalten wird.</p>","tags":["cleancode"]},{"location":"hidden/Orangener%20Grad/","title":"Orangener Grad","text":"","tags":["cleancode"]},{"location":"hidden/Orangener%20Grad/#orangener-grad","title":"Orangener Grad","text":"","tags":["cleancode"]},{"location":"hidden/Orangener%20Grad/#prinzipien","title":"Prinzipien","text":"<ul> <li>Single Level of Abstraction</li> <li>Single Responsibility Principle</li> <li>Separation of Concerns</li> <li>Source Code Conventions</li> </ul>","tags":["cleancode"]},{"location":"hidden/Orangener%20Grad/#praktiken","title":"Praktiken","text":"<ul> <li>Issue Tracking</li> <li>Automated Integrationtests</li> <li>Read, Read, Read</li> <li>Code Reviews</li> </ul>","tags":["cleancode"]},{"location":"hidden/Partizipation%20in%20Professional%20Events/","title":"Partizipation in Professional Events","text":"","tags":["cleancode"]},{"location":"hidden/Partizipation%20in%20Professional%20Events/#partizipation-in-professional-events","title":"Partizipation in Professional Events","text":"<p>Warum? Am besten lernen wir von anderen und in Gemeinschaft.</p> <p>Um nicht nur \u201eim eigenen Saft zu schmoren\u201c, ist es wichtig, regelm\u00e4\u00dfig mit anderen Softwareentwicklern zu diskutieren und Erfahrungen auszutauschen. Um dabei auch \u00fcber den Tellerrand zu blicken, sollte der Austausch mit Entwicklern au\u00dferhalb des eigenen Teams, der t\u00e4glichen Routine, erfolgen. Gut geeignet sind User Groups, die sich in allen Regionen Deutschlands finden lassen.</p> <p>Bei den regionalen User Groups steht der Erfahrungsaustausch im Vordergrund. Der ist wichtig. Je l\u00e4nger der aber innerhalb derselben Gruppe stattfindet, je besser man die Gespr\u00e4chspartner kennt, desto mehr gleichen sich die Meinungen auch in einer User Group wieder an. Deshalb ist es wichtig, immer wieder auch \u00fcber diesen Tellerrand hinaus zu schauen. Neues Gedankenfutter und Diskussionen mit ganz anderen Entwicklern bieten daf\u00fcr \u00fcberregionale Entwicklerkonferenzen.</p> <p>F\u00fcr Gedankenaustausch und Inspiration sollte ein CCD also drei Ebenen im Blick behalten: das eigene Entwicklerteam, die regionale User Group und die \u00fcberregionale Konferenz. Jede Ebene hat dabei ihren eigenen Rhythmus: t\u00e4glich, monatlich, j\u00e4hrlich.</p> <p>Links:</p> <ul> <li>.Net User Groups in Deutschlands</li> <li>Python User Groups in Deutschland</li> <li>Einige deutsche Java User Groups</li> <li>IT-Termine in Karlsruhe</li> </ul>","tags":["cleancode"]},{"location":"hidden/Penne%20all%20arrabbiata/","title":"Penne all arrabbiata","text":"","tags":["cooking","italian"]},{"location":"hidden/Penne%20all%20arrabbiata/#zutaten","title":"Zutaten","text":"<ul> <li>Penne</li> <li>Zwiebeln</li> <li>Ingwer</li> <li>Knoblauch</li> <li>Chili</li> <li>Gem\u00fcsebr\u00fche (am besten W\u00fcrfel)</li> <li>Petersilie (und andere Kr\u00e4uter nach belieben)</li> <li>Tomaten Gehackt</li> </ul>","tags":["cooking","italian"]},{"location":"hidden/Penne%20all%20arrabbiata/#ablauf","title":"Ablauf","text":"<p>Nudeln normal in Salzwasser kochen.</p> <p>Erst Zwiebeln hacken und in \u00d6l and\u00fcnsten. Knoblauch, Ingwer und Chili klein Hacken. Chili und Knoblauch zu den Zwiebeln geben. Dann nach einer Minute zwei Gem\u00fcsebr\u00fche W\u00fcrfel hinzugeben und mit den Tomaten abl\u00f6schen. Dann Ingwer hinzugeben. Ca. 30 Minuten auf schwacher/mittlerer Hitze k\u00f6cheln lassen. W\u00e4hrenddessen die Kr\u00e4uter klein hacken und dazu geben.</p>","tags":["cooking","italian"]},{"location":"hidden/Principle%20of%20Least%20Astonishment/","title":"Principle of Least Astonishment","text":"","tags":["cleancode"]},{"location":"hidden/Principle%20of%20Least%20Astonishment/#principle-of-least-astonishment","title":"Principle of Least Astonishment","text":"<p>Warum? Wenn sich eine Komponente \u00fcberraschenderweise anders verh\u00e4lt als erwartet, wird ihre Anwendung unn\u00f6tig kompliziert und fehleranf\u00e4llig.</p> <p>Softwareentwicklung ist in hohem Ma\u00dfe ein kreativer Prozess. In diesem Prozess ist es wichtig, in den Fluss einzutauchen (engl. Flow). Wenn man diesen Zustand erreicht hat, sprudelt der Code nur so heraus. Jegliche St\u00f6rung des Flow f\u00fchrt zu Unterbrechungen und letztlich dazu, dass in der zur Verf\u00fcgung stehenden Zeit nur wenig Code produziert wird bzw. die Qualit\u00e4t des Code nicht optimal ist. Denn nach jeder Unterbrechung muss der Entwickler erst wieder Fahrt aufnehmen und erneut in den Fluss zu kommen. \u00dcberraschungen stellen St\u00f6rungen dar. Sie f\u00fchren zu Unterbrechungen und Fehlern. Dazu ein Beispiel: Ist die Tastenbelegung in der Entwicklungsumgebung so gew\u00e4hlt, dass eine \u00fcbliche Tastenkombination wie z.B. Ctrl-C eine v\u00f6llig andere Bedeutung hat, behindert dies den Entwickler. Ein Entwickler wird sich jedes mal \u00e4rgern, wenn er die \u201efalsche\u201c Tastenkombination verwendet. Dies behindert kreatives Arbeiten.</p> <p>Software sollte \u00fcberraschungsarm implementiert sein. Wenn eine Abfragemethode namens\u2003<code>GetValue()</code>\u2003nicht nur einen Wert liefert, sondern gleichzeitig den Zustand des Systems \u00e4ndert, wird der Entwickler diese Methode im besten Fall meiden, da er mit b\u00f6sen \u00dcberraschungen rechnet. Im ung\u00fcnstigen Fall f\u00e4llt ihm dieses merkw\u00fcrdige Verhalten nicht rechtzeitig auf. (Abfragemethoden die den Zustand \u00e4ndern, versto\u00dfen gegen das\u2003Command Query Separation\u2003Prinzip). Die Test-Driven-Development f\u00f6rdert \u00fcberraschungsarme Schnittstellen, da die Schnittstelle aus der Sichtweise ihrer Verwendung entworfen und implementiert wird.</p>","tags":["cleancode"]},{"location":"hidden/Protobuf/","title":"Protobuf","text":"<p>Source</p> <p>https://protobuf.dev/overview/</p> <p>It\u2019s like JSON, except it\u2019s smaller and faster, and it generates native language bindings. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.</p> <p>Protocol buffers are a combination of the definition language (created in\u2003<code>.proto</code>\u2003files), the code that the proto compiler generates to interface with data, language-specific runtime libraries, and the serialization format for data that is written to a file (or sent across a network connection).</p>"},{"location":"hidden/Protobuf/#what-problems-do-protocol-buffers-solve","title":"What Problems do Protocol Buffers Solve?","text":"<p>Protocol buffers provide a serialization format for packets of typed, structured data that are up to a few megabytes in size. The format is suitable for both ephemeral network traffic and long-term data storage. Protocol buffers can be extended with new information without invalidating existing data or requiring code to be updated.</p> <p>Protocol buffers are the most commonly-used data format at Google. They are used extensively in inter-server communications as well as for archival storage of data on disk. Protocol buffer\u2003messages\u2003and\u2003services\u2003are described by engineer-authored\u2003<code>.proto</code>\u2003files. The following shows an example\u2003<code>message</code>:</p> <pre><code>message Person {\n  optional string name = 1;\n  optional int32 id = 2;\n  optional string email = 3;\n}\n</code></pre>"},{"location":"hidden/Prototype/","title":"Prototype","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Prototype/#prototype","title":"Prototype","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Prototype/#intent","title":"Intent","text":"<p>Prototype\u2003is a creational design pattern that lets you copy existing objects without making your code dependent on their\u2003classes.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Prototype/#problem","title":"Problem","text":"<p>Say you have an object, and you want to create an exact copy of it. How would you do it? First, you have to create a new object of the same class. Then you have to go through all the fields of the original object and copy their values over to the new object.</p> <p>Nice! But there\u2019s a catch. Not all objects can be copied that way because some of the object\u2019s fields may be private and not visible from outside of the object itself.</p> <p></p> <p>Copying an object \u201cfrom the outside\u201d\u2003isn\u2019t\u2003always\u2003possible.</p> <p>There\u2019s one more problem with the direct approach. Since you have to know the object\u2019s class to create a duplicate, your code becomes dependent on that class. If the extra dependency doesn\u2019t scare you, there\u2019s another catch. Sometimes you only know the interface that the object follows, but not its concrete class, when, for example, a parameter in a method accepts any objects that follow some interface.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Prototype/#solution","title":"Solution","text":"<p>The Prototype pattern delegates the cloning process to the actual objects that are being cloned. The pattern declares a common interface for all objects that support cloning. This interface lets you clone an object without coupling your code to the class of that object. Usually, such an interface contains just a single\u2003<code>clone</code>\u2003method.</p> <p>The implementation of the\u2003<code>clone</code>\u2003method is very similar in all classes. The method creates an object of the current class and carries over all of the field values of the old object into the new one. You can even copy private fields because most programming languages let objects access private fields of other objects that belong to the same class.</p> <p>An object that supports cloning is called a\u2003prototype. When your objects have dozens of fields and hundreds of possible configurations, cloning them might serve as an alternative to subclassing.</p> <p></p> <p>Pre-built prototypes can be an alternative to\u2003subclassing.</p> <p>Here\u2019s how it works: you create a set of objects, configured in various ways. When you need an object like the one you\u2019ve configured, you just clone a prototype instead of constructing a new object from scratch.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Prototype/#real-world-analogy","title":"Real-World Analogy","text":"<p>In real life, prototypes are used for performing various tests before starting mass production of a product. However, in this case, prototypes don\u2019t participate in any actual production, playing a passive role instead.</p> <p></p> <p>The division of a\u2003cell.</p> <p>Since industrial prototypes don\u2019t really copy themselves, a much closer analogy to the pattern is the process of mitotic cell division (biology, remember?). After mitotic division, a pair of identical cells is formed. The original cell acts as a prototype and takes an active role in creating the copy.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Prototype/#structure","title":"Structure","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Prototype/#basic-implementation","title":"Basic implementation","text":"<ol> <li>The\u2003Prototype\u2003interface declares the cloning methods. In most cases, it\u2019s a single\u2003<code>clone</code>\u2003method.</li> <li>The\u2003Concrete Prototype\u2003class implements the cloning method. In addition to copying the original object\u2019s data to the clone, this method may also handle some edge cases of the cloning process related to cloning linked objects, untangling recursive dependencies,\u2003etc.</li> <li>The\u2003Client\u2003can produce a copy of any object that follows the prototype interface.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Prototype/#prototype-registry-implementation","title":"Prototype registry implementation","text":"<ol> <li>The\u2003Prototype Registry\u2003provides an easy way to access frequently-used prototypes. It stores a set of pre-built objects that are ready to be copied. The simplest prototype registry is a\u2003<code>name \u2192 prototype</code>\u2003hash map. However, if you need better search criteria than a simple name, you can build a much more robust version of the registry.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Prototype/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Prototype\u2003pattern lets you produce exact copies of geometric objects, without coupling the code to their classes.</p> <p></p> <p>Cloning a set of objects that belong to a class\u2003hierarchy.</p> <p>All shape classes follow the same interface, which provides a cloning method. A subclass may call the parent\u2019s cloning method before copying its own field values to the resulting object.</p> <pre><code>// Base prototype.\nabstract class Shape is\n    field X: int\n    field Y: int\n    field color: string\n\n    // A regular constructor.\n    constructor Shape() is\n        // ...\n\n    // The prototype constructor. A fresh object is initialized\n    // with values from the existing object.\n    constructor Shape(source: Shape) is\n        this()\n        this.X = source.X\n        this.Y = source.Y\n        this.color = source.color\n\n    // The clone operation returns one of the Shape subclasses.\n    abstract method clone():Shape\n\n// Concrete prototype. The cloning method creates a new object\n// in one go by calling the constructor of the current class and\n// passing the current object as the constructor's argument.\n// Performing all the actual copying in the constructor helps to\n// keep the result consistent: the constructor will not return a\n// result until the new object is fully built; thus, no object\n// can have a reference to a partially-built clone.\nclass Rectangle extends Shape is\n    field width: int\n    field height: int\n\n    constructor Rectangle(source: Rectangle) is\n        // A parent constructor call is needed to copy private\n        // fields defined in the parent class.\n        super(source)\n        this.width = source.width\n        this.height = source.height\n\n    method clone():Shape is\n        return new Rectangle(this)\n\nclass Circle extends Shape is\n    field radius: int\n\n    constructor Circle(source: Circle) is\n        super(source)\n        this.radius = source.radius\n\n    method clone():Shape is\n        return new Circle(this)\n\n// Somewhere in the client code.\nclass Application is\n    field shapes: array of Shape\n\n    constructor Application() is\n        Circle circle = new Circle()\n        circle.X = 10\n        circle.Y = 10\n        circle.radius = 20\n        shapes.add(circle)\n\n        Circle anotherCircle = circle.clone()\n        shapes.add(anotherCircle)\n        // The `anotherCircle` variable contains an exact copy\n        // of the `circle` object.\n\n        Rectangle rectangle = new Rectangle()\n        rectangle.width = 10\n        rectangle.height = 20\n        shapes.add(rectangle)\n\n    method businessLogic() is\n        // Prototype rocks because it lets you produce a copy of\n        // an object without knowing anything about its type.\n        Array shapesCopy = new Array of Shapes.\n\n        // For instance, we don't know the exact elements in the\n        // shapes array. All we know is that they are all\n        // shapes. But thanks to polymorphism, when we call the\n        // `clone` method on a shape the program checks its real\n        // class and runs the appropriate clone method defined\n        // in that class. That's why we get proper clones\n        // instead of a set of simple Shape objects.\n        foreach (s in shapes) do\n            shapesCopy.add(s.clone())\n\n        // The `shapesCopy` array contains exact copies of the\n        // `shape` array's children.\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/Prototype/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Prototype pattern when your code shouldn\u2019t depend on the concrete classes of objects that you need to copy.     This happens a lot when your code works with objects passed to you from 3rd-party code via some interface. The concrete classes of these objects are unknown, and you couldn\u2019t depend on them even if you wanted to.</p> <p>The Prototype pattern provides the client code with a general interface for working with all objects that support cloning. This interface makes the client code independent from the concrete classes of objects that it clones.</p> </li> <li> <p>Use the pattern when you want to reduce the number of subclasses that only differ in the way they initialize their respective objects.     \u2003Suppose you have a complex class that requires a laborious configuration before it can be used. There are several common ways to configure this class, and this code is scattered through your app. To reduce the duplication, you create several subclasses and put every common configuration code into their constructors. You solved the duplication problem, but now you have lots of dummy subclasses.</p> <p>The Prototype pattern lets you use a set of pre-built objects configured in various ways as prototypes. Instead of instantiating a subclass that matches some configuration, the client can simply look for an appropriate prototype and clone it.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Prototype/#how-to-implement","title":"How to Implement","text":"<ol> <li>Create the prototype interface and declare the\u2003<code>clone</code>\u2003method in it. Or just add the method to all classes of an existing class hierarchy, if you have one.</li> <li> <p>A prototype class must define the alternative constructor that accepts an object of that class as an argument. The constructor must copy the values of all fields defined in the class from the passed object into the newly created instance. If you\u2019re changing a subclass, you must call the parent constructor to let the superclass handle the cloning of its private fields.</p> <p>If your programming language doesn\u2019t support method overloading, you won\u2019t be able to create a separate \u201cprototype\u201d constructor. Thus, copying the object\u2019s data into the newly created clone will have to be performed within the\u2003<code>clone</code>\u2003method. Still, having this code in a regular constructor is safer because the resulting object is returned fully configured right after you call the\u2003<code>new</code>\u2003operator.</p> </li> <li> <p>The cloning method usually consists of just one line: running a\u2003<code>new</code>\u2003operator with the prototypical version of the constructor. Note, that every class must explicitly override the cloning method and use its own class name along with the\u2003<code>new</code>\u2003operator. Otherwise, the cloning method may produce an object of a parent class.</p> </li> <li> <p>Optionally, create a centralized prototype registry to store a catalog of frequently used prototypes.</p> <p>You can implement the registry as a new factory class or put it in the base prototype class with a static method for fetching the prototype. This method should search for a prototype based on search criteria that the client code passes to the method. The criteria might either be a simple string tag or a complex set of search parameters. After the appropriate prototype is found, the registry should clone it and return the copy to the client.</p> <p>Finally, replace the direct calls to the subclasses\u2019 constructors with calls to the factory method of the prototype registry.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Prototype/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can clone objects without coupling to their concrete classes. Cloning complex objects that have circular references might be very tricky. You can get rid of repeated initialization code in favor of cloning pre-built prototypes. You can produce complex objects more conveniently. You get an alternative to inheritance when dealing with configuration presets for complex objects.","tags":["cleancode_designpatterns"]},{"location":"hidden/Prototype/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).</li> <li>Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.</li> <li>Prototype can help when you need to save copies of Commands into history.</li> <li>Designs that make heavy use of Composite and Decorator can often benefit from using Prototype. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.</li> <li>Prototype isn\u2019t based on inheritance, so it doesn\u2019t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. Factory Method is based on inheritance but doesn\u2019t require an initialization step.</li> <li>Sometimes Prototype can be a simpler alternative to Memento. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn\u2019t have links to external resources, or the links are easy to re-establish.</li> <li>Abstract Factory, Builders and Prototype can all be implemented as Singleton.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Proxy/","title":"Proxy","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Proxy/#proxy","title":"Proxy","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Proxy/#intent","title":"Intent","text":"<p>Proxy\u2003is a structural design pattern that lets you provide a substitute or placeholder for another object. A proxy controls access to the original object, allowing you to perform something either before or after the request gets through to the original\u2003object.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Proxy/#problem","title":"Problem","text":"<p>Why would you want to control access to an object? Here is an example: you have a massive object that consumes a vast amount of system resources. You need it from time to time, but not always.</p> <p></p> <p>Database queries can be really\u2003slow.</p> <p>You could implement lazy initialization: create this object only when it\u2019s actually needed. All of the object\u2019s clients would need to execute some deferred initialization code. Unfortunately, this would probably cause a lot of code duplication.</p> <p>In an ideal world, we\u2019d want to put this code directly into our object\u2019s class, but that isn\u2019t always possible. For instance, the class may be part of a closed 3rd-party library.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Proxy/#solution","title":"Solution","text":"<p>The Proxy pattern suggests that you create a new proxy class with the same interface as an original service object. Then you update your app so that it passes the proxy object to all of the original object\u2019s clients. Upon receiving a request from a client, the proxy creates a real service object and delegates all the work to it.</p> <p></p> <p>The proxy disguises itself as a database object. It can handle lazy initialization and result caching without the client or the real database object even\u2003knowing.</p> <p>But what\u2019s the benefit? If you need to execute something either before or after the primary logic of the class, the proxy lets you do this without changing that class. Since the proxy implements the same interface as the original class, it can be passed to any client that expects a real service object.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Proxy/#real-world-analogy","title":"Real-World Analogy","text":"<p>Credit cards can be used for payments just the same as\u2003cash.</p> <p>A credit card is a proxy for a bank account, which is a proxy for a bundle of cash. Both implement the same interface: they can be used for making a payment. A consumer feels great because there\u2019s no need to carry loads of cash around. A shop owner is also happy since the income from a transaction gets added electronically to the shop\u2019s bank account without the risk of losing the deposit or getting robbed on the way to the bank.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Proxy/#structure","title":"Structure","text":"<ol> <li> <p>The\u2003Service Interface\u2003declares the interface of the Service. The proxy must follow this interface to be able to disguise itself as a service object.</p> </li> <li> <p>The\u2003Service\u2003is a class that provides some useful business logic.</p> </li> <li> <p>The\u2003Proxy\u2003class has a reference field that points to a service object. After the proxy finishes its processing (e.g., lazy initialization, logging, access control, caching,\u2003etc.), it passes the request to the service object.</p> <p>Usually, proxies manage the full lifecycle of their service objects.</p> </li> <li> <p>The\u2003Client\u2003should work with both services and proxies via the same interface. This way you can pass a proxy into any code that expects a service object.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Proxy/#pseudocode","title":"Pseudocode","text":"<p>This example illustrates how the\u2003Proxy\u2003pattern can help to introduce lazy initialization and caching to a 3rd-party YouTube integration library.</p> <p></p> <p>Caching results of a service with a\u2003proxy.</p> <p>The library provides us with the video downloading class. However, it\u2019s very inefficient. If the client application requests the same video multiple times, the library just downloads it over and over, instead of caching and reusing the first downloaded file.</p> <p>The proxy class implements the same interface as the original downloader and delegates it all the work. However, it keeps track of the downloaded files and returns the cached result when the app requests the same video multiple times. <pre><code>// The interface of a remote service.\ninterface ThirdPartyYouTubeLib is\n    method listVideos()\n    method getVideoInfo(id)\n    method downloadVideo(id)\n\n// The concrete implementation of a service connector. Methods\n// of this class can request information from YouTube. The speed\n// of the request depends on a user's internet connection as\n// well as YouTube's. The application will slow down if a lot of\n// requests are fired at the same time, even if they all request\n// the same information.\nclass ThirdPartyYouTubeClass implements ThirdPartyYouTubeLib is\n    method listVideos() is\n        // Send an API request to YouTube.\n\n    method getVideoInfo(id) is\n        // Get metadata about some video.\n\n    method downloadVideo(id) is\n        // Download a video file from YouTube.\n\n// To save some bandwidth, we can cache request results and keep\n// them for some time. But it may be impossible to put such code\n// directly into the service class. For example, it could have\n// been provided as part of a third party library and/or defined\n// as `final`. That's why we put the caching code into a new\n// proxy class which implements the same interface as the\n// service class. It delegates to the service object only when\n// the real requests have to be sent.\nclass CachedYouTubeClass implements ThirdPartyYouTubeLib is\n    private field service: ThirdPartyYouTubeLib\n    private field listCache, videoCache\n    field needReset\n\n    constructor CachedYouTubeClass(service: ThirdPartyYouTubeLib) is\n        this.service = service\n\n    method listVideos() is\n        if (listCache == null || needReset)\n            listCache = service.listVideos()\n        return listCache\n\n    method getVideoInfo(id) is\n        if (videoCache == null || needReset)\n            videoCache = service.getVideoInfo(id)\n        return videoCache\n\n    method downloadVideo(id) is\n        if (!downloadExists(id) || needReset)\n            service.downloadVideo(id)\n\n// The GUI class, which used to work directly with a service\n// object, stays unchanged as long as it works with the service\n// object through an interface. We can safely pass a proxy\n// object instead of a real service object since they both\n// implement the same interface.\nclass YouTubeManager is\n    protected field service: ThirdPartyYouTubeLib\n\n    constructor YouTubeManager(service: ThirdPartyYouTubeLib) is\n        this.service = service\n\n    method renderVideoPage(id) is\n        info = service.getVideoInfo(id)\n        // Render the video page.\n\n    method renderListPanel() is\n        list = service.listVideos()\n        // Render the list of video thumbnails.\n\n    method reactOnUserInput() is\n        renderVideoPage()\n        renderListPanel()\n\n// The application can configure proxies on the fly.\nclass Application is\n    method init() is\n        aYouTubeService = new ThirdPartyYouTubeClass()\n        aYouTubeProxy = new CachedYouTubeClass(aYouTubeService)\n        manager = new YouTubeManager(aYouTubeProxy)\n        manager.reactOnUserInput()     \n</code></pre></p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Proxy/#applicability","title":"Applicability","text":"<p>There are dozens of ways to utilize the Proxy pattern. Let\u2019s go over the most popular uses.</p> <ul> <li>Lazy initialization (virtual proxy). This is when you have a heavyweight service object that wastes system resources by being always up, even though you only need it from time to time.     Instead of creating the object when the app launches, you can delay the object\u2019s initialization to a time when it\u2019s really needed.</li> <li>Access control (protection proxy). This is when you want only specific clients to be able to use the service object; for instance, when your objects are crucial parts of an operating system and clients are various launched applications (including malicious ones).     The proxy can pass the request to the service object only if the client\u2019s credentials match some criteria.</li> <li>Local execution of a remote service (remote proxy). This is when the service object is located on a remote server.     \u2003In this case, the proxy passes the client request over the network, handling all of the nasty details of working with the network.</li> <li>Logging requests (logging proxy). This is when you want to keep a history of requests to the service object.     The proxy can log each request before passing it to the service.</li> <li>Caching request results (caching proxy). This is when you need to cache results of client requests and manage the life cycle of this cache, especially if results are quite large.     The proxy can implement caching for recurring requests that always yield the same results. The proxy may use the parameters of requests as the cache keys.</li> <li> <p>Smart reference. This is when you need to be able to dismiss a heavyweight object once there are no clients that use it.     The proxy can keep track of clients that obtained a reference to the service object or its results. From time to time, the proxy may go over the clients and check whether they are still active. If the client list gets empty, the proxy might dismiss the service object and free the underlying system resources.</p> <p>The proxy can also track whether the client had modified the service object. Then the unchanged objects may be reused by other clients.</p> </li> </ul> <ol> <li> <p>If there\u2019s no pre-existing service interface, create one to make proxy and service objects interchangeable. Extracting the interface from the service class isn\u2019t always possible, because you\u2019d need to change all of the service\u2019s clients to use that interface. Plan B is to make the proxy a subclass of the service class, and this way it\u2019ll inherit the interface of the service.</p> </li> <li> <p>Create the proxy class. It should have a field for storing a reference to the service. Usually, proxies create and manage the whole life cycle of their services. On rare occasions, a service is passed to the proxy via a constructor by the client.</p> </li> <li> <p>Implement the proxy methods according to their purposes. In most cases, after doing some work, the proxy should delegate the work to the service object.</p> </li> <li> <p>Consider introducing a creation method that decides whether the client gets a proxy or a real service. This can be a simple static method in the proxy class or a full-blown factory method.</p> </li> <li> <p>Consider implementing lazy initialization for the service object.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Proxy/#how-to-implement","title":"How to Implement","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Proxy/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can control the service object without clients knowing about it. The code may become more complicated since you need to introduce a lot of new classes. You can manage the lifecycle of the service object when clients don\u2019t care about it. The response from the service might get delayed. The proxy works even if the service object isn\u2019t ready or is not available. Open Closed Principle. You can introduce new proxies without changing the service or clients.","tags":["cleancode_designpatterns"]},{"location":"hidden/Proxy/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Adapter provides a different interface to the wrapped object, Proxy provides it with the same interface, and Decorator provides it with an enhanced interface.</li> <li>Facade is similar to Proxy in that both buffer a complex entity and initialize it on its own. Unlike Facade, Proxy has the same interface as its service object, which makes them interchangeable.</li> <li>Decorator and Proxy have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a Proxy usually manages the life cycle of its service object on its own, whereas the composition of Decorators is always controlled by the client.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Read%2C%20Read%2C%20Read/","title":"Read, Read, Read","text":"","tags":["cleancode"]},{"location":"hidden/Read%2C%20Read%2C%20Read/#read-read-read","title":"Read, Read, Read","text":"<p>Warum? Lesen bildet!</p> <p>Lesen bildet \u2013 wir sind jedenfalls fest davon \u00fcberzeugt, dass dies auch f\u00fcr Software-Entwickler gilt. Die Softwaretechnik entwickelt sich nach wie vor weiter. Neben den gro\u00dfen Entwicklungsschritten wie Prozedurale Programmierung, Objektorientierte Programmierung, Funktionale Programmierung, Aspektorientierte Programmierung, etc. gibt es st\u00e4ndig Entwicklungen im Kleinen mit denen sich ein professioneller Software-Entwickler auseinandersetzen muss. Da w\u00e4ren zum einen Techniken wie etwa\u2003Dependency Injection\u2003oder\u2003Object Relational Mapper. Aber auch innerhalb dieser Techniken gibt es Entwicklungsschritte wie etwa\u2003Domain Specific Languages (DSLs)\u2003zur Konfiguration vs. XML basierende Konfiguration. Neben den technischen Aspekten der Softwareentwicklung wird auch der Prozess st\u00e4ndig weiterentwickelt. So hat sich die Erkenntnis durchgesetzt, dass Wasserfallmodelle nicht funktionieren, verschiedene agile Prozesse werden entwickelt. All dies muss der Clean Code Developer im Blick haben.</p> <p>Wir schlagen daher vor, pro Jahr wenigstens 6 Fachb\u00fccher zu lesen. Ferner sollten Periodika regelm\u00e4\u00dfig gelesen werden und darunter verstehen wir neben Fachzeitschriften auch Blogs.</p> <p>Anregungen finden Sie in der\u2003Literaturliste.</p>","tags":["cleancode"]},{"location":"hidden/Reduktion%20der%20kognitiven%20Belastung/","title":"Reduktion der kognitiven Belastung","text":"<ul> <li>Wartezeiten und Verz\u00f6gerungen auf ein Minimum reduzieren</li> <li>Feedback geben</li> <li>Angst bei der Benutzung vermeiden<ul> <li>vgl. exploratives Lernen in der ACT-Theorie</li> <li>robuste Systeme entwickeln</li> </ul> </li> <li>Wut vermeiden<ul> <li>insb. bei der Nutzung durch Experten</li> </ul> </li> </ul>","tags":["is"]},{"location":"hidden/Reduktion%20der%20kognitiven%20Belastung/#methoden","title":"Methoden","text":"<ul> <li>Chunking</li> <li>Wichtige Informationen, Systemzust\u00e4nde, Modi persistent anzeigen (vgl. Systemzustand)</li> <li>Weniger wichtige Informationen ausblenden</li> <li>Komplexe Aktionen in einzelne Schritte zerlegen (Teilziele)</li> <li>Gestaltung von Hilfen, direkt nutzbar</li> <li>Vereinfachung von Hilfetexten, Systemausgaben und Fehlerdialogen</li> </ul>","tags":["is"]},{"location":"hidden/Reduktion%20der%20kognitiven%20Belastung/#probleme","title":"Probleme","text":"<ul> <li>Aufmerksamkeit und Arbeitsged\u00e4chtnis sind beschr\u00e4nkt</li> <li>Starke Belastung des Arbeitsged\u00e4chtnis bei der Nutzung interaktiver Systeme</li> <li>Hohe Belastung bei komplexen Dialogen und Formularen</li> <li>Urspr\u00fcngliches Ziel wird vergessen</li> <li>Wartezeiten f\u00fchren zu Vergessen der Ziele und dadurch zu Fehlern</li> <li>Zu einfache Benutzungsschnittstellen k\u00f6nnen professionelle Benutzer/Experten einschr\u00e4nken</li> </ul>","tags":["is"]},{"location":"hidden/Refaktorisieren/","title":"Refaktorisieren","text":"","tags":["cleancode_refactoring"]},{"location":"hidden/Refaktorisieren/#refaktorisieren","title":"Refaktorisieren","text":"","tags":["cleancode_refactoring"]},{"location":"hidden/Refaktorisieren/#what","title":"What?","text":"<p>Struktur\u00e4nderungen ohne beobachtbares Verhalten zu \u00e4ndern.</p>","tags":["cleancode_refactoring"]},{"location":"hidden/Refaktorisieren/#functional","title":"Functional","text":"<p>Was tut die Software? =&gt; Features Beim Ausf\u00fchren beobachtbar</p>","tags":["cleancode_refactoring"]},{"location":"hidden/Refaktorisieren/#operation","title":"Operation","text":"<p>Wie tut die Software Dinge? =&gt; Performance, Stabilit\u00e4t Beim Ausf\u00fchren bobachtbar.</p>","tags":["cleancode_refactoring"]},{"location":"hidden/Refaktorisieren/#developmental","title":"Developmental","text":"<p>Wie einfach ist es, die Software zu \u00e4ndern? =&gt; Wartbarkeit Nicht beim Ausf\u00fchren beobachtbar</p>","tags":["cleancode_refactoring"]},{"location":"hidden/Refaktorisieren/#arten-von-refactorings","title":"Arten von Refactorings","text":"<ul> <li>Rename</li> <li>Extract</li> <li>Inline</li> <li>Move</li> </ul>","tags":["cleancode_refactoring"]},{"location":"hidden/Rider%20Shortcuts%20%28IntelliJ%20IDEA%29/","title":"Rider Shortcuts (IntelliJ IDEA)","text":"","tags":["cheat","refactoring","rider","keymap","shortcuts"]},{"location":"hidden/Rider%20Shortcuts%20%28IntelliJ%20IDEA%29/#refactoring","title":"Refactoring","text":"Name Shortcut Refactor This CTRL+ALT+SHIFT+T Rename SHIFT+F6 Inline CTRL+ALT+N Move F6 Extract Method CTRL+ALT+M Introduce Field CTRL+ALT+F Introduce Parameter CTRL+ALT+P Introduce Varialbe CTRL+ALT+V Safe Delete ALT+DELETE Change Signature CTRL+F6 Toggle Casing CTRL+SHIFT+U ##  Live Templates Name Description ---- ------------------ prop Generates Property","tags":["cheat","refactoring","rider","keymap","shortcuts"]},{"location":"hidden/Root%20Cause%20Analysis/","title":"Root Cause Anaysis","text":"","tags":["cleancode"]},{"location":"hidden/Root%20Cause%20Analysis/#root-cause-anaysis","title":"Root Cause Anaysis","text":"<p>Warum? Symptome behandeln bringt vielleicht schnell eine Linderung \u2013 langfristig kostet es aber mehr Aufwand. Wer stattdessen unter die Oberfl\u00e4che von Problemen schaut, arbeitet am Ende effizienter.</p> <p>Regel vom ersten Tag als Clean Code Developer an sollte sein, bei Problemen immer intensiv nach der wahren Wurzel des \u00dcbels zu suchen. Clean Code Developer geben sich nicht mit einer Symptomkur zufrieden. Beispiel: Die Sortierung von Daten im Speicher ist zu langsam. Eine oberfl\u00e4chliche Kur w\u00fcrde jetzt daran gehen, einzelne Anweisungen oder Anweisungsbl\u00f6cke zu beschleunigen. Vielleicht wird der Einsatz von unsafe Code probiert, vielleicht eine Parallelisierung. Eine n\u00e4here Problemanalyse jedoch h\u00e4tte ergeben, dass ein suboptimaler Algorithmus die Wurzel des \u00dcbels ist. Schwer verst\u00e4ndliche Optimierungen auf niedriger Abstraktionsebene k\u00f6nnen also vermieden werden. Ein besserer Algorithmus ist die saubere L\u00f6sung.</p> <p>Wurzelproblemanalyse ist also ein Dienst an der Verst\u00e4ndlichkeit und am Aufwand. Denn bei Kenntnis des Wurzelproblems ist die Bereinigung meist weniger aufw\u00e4ndig als eine Symptomkur. St\u00f6\u00dft der Clean Code Developer auf ein Problem, so h\u00e4lt er also als erstes inne, um sich eine Chance zu geben, hinter die Symptome zu schauen.</p> <p>Die Root Cause Analysis ist auch unter dem Begriff Five Why\u2019s bekannt. Dieser Begriff stammt aus der Terminologie des Toyota Produktions SystemsToyota Produktions Systems (TPS). Die Grundidee: frage mindestens f\u00fcnf mal \u201eWarum?\u201c.</p>","tags":["cleancode"]},{"location":"hidden/Roter%20Grad/","title":"Roter Grad","text":"","tags":["cleancode"]},{"location":"hidden/Roter%20Grad/#roter-grad","title":"Roter Grad","text":"","tags":["cleancode"]},{"location":"hidden/Roter%20Grad/#prinzipien","title":"Prinzipien","text":"<ul> <li>DRY</li> <li>KISS</li> <li>Beware of Premature Optimization</li> <li>Favour Composition over Inheritance</li> <li>Integration Operation Segregation Principle (IOSP)</li> </ul>","tags":["cleancode"]},{"location":"hidden/Roter%20Grad/#praktiken","title":"Praktiken","text":"<ul> <li>Boy Scout Rule</li> <li>Root Cause Analysis</li> <li>Version Control System</li> <li>Simple Refactorings</li> <li>Daily Reflection</li> </ul>","tags":["cleancode"]},{"location":"hidden/SOLID/","title":"SOLID","text":"","tags":["cleancode"]},{"location":"hidden/SOLID/#solid","title":"SOLID","text":"<p>The SOLID Principles are a part of the Clean Code Principles. The letters stand for:</p> <ul> <li>Single Responsibility Principle</li> <li>Open Closed Principle</li> <li>Liskov Substitution Principle</li> <li>Interface Segragation Principle</li> <li>Dependency Inversion Principle</li> </ul>","tags":["cleancode"]},{"location":"hidden/SSH/","title":"SSH","text":""},{"location":"hidden/SSH/#ssh","title":"SSH","text":""},{"location":"hidden/SSH/#autostart-ssh-agent-with-zsh","title":"Autostart SSH-Agent with Zsh","text":"<p>Add Plugin in <code>~/.zshrc</code>: <pre><code>plugins(git ssh-agent)\n</code></pre> And then reload the zsh session from the config file <pre><code>source ~/.zshrc\n</code></pre></p>"},{"location":"hidden/SSH/#config-hierarchie","title":"Config-Hierarchie","text":"<ol> <li>CMD-Line Options</li> <li>User-Config (<code>~/.ssh/config</code>)</li> <li>Systemwide-Config (<code>/etc/ssh/ssh_config</code>)</li> </ol> <p>Warning</p> <p>For each parameter, the first obtained value will be used   So more specific config entries should be at the top of the configs  \\(\\rightarrow\\) Defaults at the end</p>"},{"location":"hidden/SSH/#hostname-alias","title":"Hostname Alias","text":""},{"location":"hidden/SSH/#simple","title":"Simple","text":"<pre><code>Host demo\n HostName ssh-server.example.com\n</code></pre>"},{"location":"hidden/SSH/#multiple","title":"Multiple","text":"<pre><code>Host demo d1 popocatepetl\n HostName ssh-server.example.com\n</code></pre>"},{"location":"hidden/SSH/#dynamic-hostname","title":"Dynamic Hostname","text":"<pre><code>Host smtp imap www\n HostName %h.example.com\n</code></pre>"},{"location":"hidden/SSH/#ssh-public-key-authentication","title":"SSH Public Key authentication","text":""},{"location":"hidden/SSH/#generate-key","title":"Generate Key","text":"<pre><code>ssh-keygen -t ed25519 \\\n -a 420 \\\n -f ~/.ssh/demo.ed25519 \\\n -C \"Sinnvoller Kommentar!\"\n</code></pre> <p>WICHTIG</p> <p>IMMER eine Passphrase definieren!</p>"},{"location":"hidden/SSH/#result","title":"Result","text":"<pre><code>~/.ssh/demo.ed25519\n~/.ssh/demo.ed25519.pub\n</code></pre> <p>Warning</p> <p>Nur die .pub Datei darf \u00f6ffentlich gemacht werden</p>"},{"location":"hidden/SSH/#best-practice","title":"Best Practice","text":"<p>Create one for each server, customer or service you connect to.</p>"},{"location":"hidden/SSH/#get-key-to-server","title":"Get Key to Server","text":"<ul> <li> <p>Automatic</p> <pre><code>ssh-copy-id \\\n -i ~/.ssh/demo.ed25519.pub \\\n demo\n</code></pre> </li> <li> <p>Manual</p> <ul> <li>copy content of local <code>~/.ssh/demo.ed25519.pub</code></li> <li>paste it into <code>~/.ssh/authorized_keys</code> on servers</li> </ul> </li> </ul>"},{"location":"hidden/SSH/#enable-key-auth-in-config","title":"Enable Key Auth in Config","text":"<pre><code>Host demo bastion\n PreferredAuthentications publickey\n IdentityFile ~/.ssh/demo.ed25519\n</code></pre>"},{"location":"hidden/SSH/#full-config-example","title":"Full Config Example","text":"<pre><code>Host demo bastion\n\tHostName ssh.example.com\n\tUser demoUser\n\tPreferredAuthentications publickey\n\tIdentityFile ~/.ssh/demo.ed25519\n</code></pre>"},{"location":"hidden/SSH/#enable-ssh-agent","title":"Enable ssh-agent","text":"<p>Why? Saves key Passphrase</p> <ul> <li>ssh-add<ul> <li>\u201c-c\u201d ask for permission before use</li> <li>\u201c-d\u201d removes key from ssh-agent</li> </ul> </li> </ul> <pre><code>ssh-add ~/.ssh/demo.ed25519\n</code></pre>"},{"location":"hidden/SSH/#sane-defaults","title":"Sane Defaults","text":"<pre><code>Host *\n IdentitiesOnly yes\n UseRoaming no\n SendEnv LANG LC_*\n Compression yes\n</code></pre>"},{"location":"hidden/SSH/#sshconfd","title":"~/.ssh/conf.d","text":"<p>Multiple files i.E for multiple Customers</p>"},{"location":"hidden/SSH/#bastionjump-hosts","title":"Bastion/Jump Hosts","text":""},{"location":"hidden/SSH/#manual","title":"Manual","text":"<pre><code>$ ssh bastion\nWelcome to demo.example.com\n\nleyrer@demo:~$ ssh target.local\nWelcome to target.local\n</code></pre>"},{"location":"hidden/SSH/#explicit","title":"Explicit","text":"<pre><code>ssh -J bastion target.local\n</code></pre>"},{"location":"hidden/SSH/#elegant","title":"Elegant","text":"<pre><code>Host demo bastion\n\tHostName ssh.example.com\n\tUser leyrer\n\tPreferredAuthentications publickey\n\tIdentityFile ~/.ssh/demo.ed25519\n\nHost internal\n\tHostName target.local\n\tProxyJump bastion\n\tUser leyrer\n\tPreferredAuthentications publickey\n\tIdentityFile ~/.ssh/demo.ed25519\n</code></pre>"},{"location":"hidden/SSH/#fallback","title":"Fallback","text":"<pre><code>ssh \\\n -o ProxyCommand=\"ssh -W %h:%p bastion\" \\\n target.local\n</code></pre> <pre><code>.ssh/config:\n\tHost internal\n\tProxyCommand ssh -W %h:%p bastion\n</code></pre> <p>Warning</p> <p>Do not use Agent Forwarding (<code>ssh -A</code>)</p>"},{"location":"hidden/Separation%20of%20Concerns/","title":"Separation of Concerns (SoC)","text":"","tags":["cleancode"]},{"location":"hidden/Separation%20of%20Concerns/#separation-of-concerns-soc","title":"Separation of Concerns (SoC)","text":"<p>Warum? Wenn eine Codeeinheit keine klare Aufgabe hat, ist es schwer sie zu verstehen, sie anzuwenden und sie ggf. zu korrigieren oder zu erweitern.</p> <p>\u00dcbersetzt mit Trennung der Belange bedeutet dieses Prinzip, dass man nicht mehrere Belange in einer Klasse zusammenfassen soll. Was sind Belange? Belange sind \u201ekomplett verschiedene\u201c Zwecke. Man sagt auch, Belange seien orthogonal zu einander und vor allem orthogonal zur Hauptfunktionalit\u00e4t einer Funktionseinheit. Beispiele f\u00fcr typische Belange sind: Tracing, Logging, Transaktionalit\u00e4t, Caching. Diese Belange sollen nach dem Prinzip der Separation of Concerns in spezialisierte Funktionseinheiten ausgelagert werden.</p> <p>Das Separation of Concerns Prinzip h\u00e4ngt eng mit dem Single Responsibility Prinzip zusammen. Dabei sind Concerns eine \u00dcbermenge von Responsibilities. Jede Responsibility besteht im Idealfall aus genau einem Concern, n\u00e4mlich ihrer Kernfunktionalit\u00e4t. Oft sind in einer Responsibility jedoch mehrere Concerns vermischt. Da sich dies technisch meist nicht ganz vermeiden l\u00e4\u00dft, besagt das Prinzip nicht etwa, dass eine Responsibility nur aus einem Concern bestehen darf, sondern dass die Concerns getrennt sein sollten. Innerhalb einer Methode sollte beispielsweise klar erkennbar sein, dass es mehrere Concerns gibt. Ferner sollten die Concerns nicht irgendwie \u00fcber die Methode verstreut sein, sondern so gruppiert, dass klar ist, was zu einem Concern geh\u00f6rt.</p> <p>Im Domain Driven Design versucht man beispielsweise die Business Domain von der Infrastruktur strikt zu trennen. So darf dort eine Klasse aus der Business Domain keinerlei Infrastruktur, etwa f\u00fcr Datenbankzugriffe, enthalten, sondern soll ausschlie\u00dflich die Gesch\u00e4ftslogik abbilden. Persistenz ist ein \u201eConcern\u201c der nichts mit der Business Logik zu tun hat. Separation of Concerns f\u00fchrt zu loser Kopplung und hoher Koh\u00e4sion. Die einzelnen Komponenten sind jeweils auf eine Aufgabe, einen Concern, fokussiert und dadurch leicht verst\u00e4ndlich. Alle Teile aus denen die Komponente besteht, sind auf diese eine Aufgabe ausgerichtet, dadurch h\u00e4ngen die Teile eng zusammen (hohe Koh\u00e4sion). Separation of Concerns f\u00fchrt dar\u00fcber hinaus auch zu gut testbaren Komponenten. Denn wenn der Zweck einer Codeeinheit fokussiert ist, muss weniger breit getestet werden. In Bezug auf die zu testende Codeeinheit sind weniger Testparameterkombinationen zu pr\u00fcfen. Soll die Trennung der Belange konsequent betrieben werden, muss die Objektorientierung um das Konzept der Aspektorientierten Programmierung (AOP) erweitert werden. Dadurch wird es m\u00f6glich, Aspekte wie etwa Transaktionalit\u00e4t, Tracing oder Caching vollst\u00e4ndig aus einer Methode herauszuziehen.</p>","tags":["cleancode"]},{"location":"hidden/Share%20Experience/","title":"Share Experience","text":"","tags":["cleancode"]},{"location":"hidden/Share%20Experience/#share-experience","title":"Share Experience","text":"<p>Warum? Wer sein Wissen weitergibt, hilft nicht nur anderen, sondern auch sich selbst.</p> <p>Zu professioneller Arbeit geh\u00f6rt selbstverst\u00e4ndlich ein st\u00e4ndig akuelles Wissen. Das bedeutet nat\u00fcrlich nicht, dass irgendjemand alles zum Thema Softwareentwicklung und sei es auch nur auf der .NET-Plattform wissen kann und soll. Aktuelles Wissen bezieht sich auf die eigenen Spezialgebiete \u2013 welche das auch immer sein m\u00f6gen. Bestandteil anderer Grade ist deshalb die Praktik der regelm\u00e4\u00dfigen Informationsaufnahme \u00fcber verschiedene Medien.</p> <p>Aus mehreren Gr\u00fcnden sollte solche Informationssammlung jedoch nur eine von zwei Seiten der Medaille \u201eLernen\u201c sein. Die andere ist die Informationsweitergabe, die Wissensvermittlung. Zur wahren Professionalit\u00e4t geh\u00f6rt unserer Ansicht nach nicht nur \u201eForschung\u201c, sonder auch \u201eLehre\u201c. Denn erst mit der \u201eLehre\u201c findet wahre Reflektion und Durchdringung eines Gegenstandes statt.</p> <p>Etwas Geh\u00f6rtes/Gelesenes anwenden, ist eine Sache. Nat\u00fcrlich bemerkt man dabei auch Verst\u00e4ndnisl\u00fccken. Die \u201eErforschung\u201c eines Gegenstandes ist dabei jedoch durch den Einsatzzweck nat\u00fcrlich begrenzt. Wer nur soweit forscht, wie er eine Technologie/Konzept gerade braucht, der taucht nicht unbedingt tief ein.</p> <p>Ganz anders ist das hingegen, wenn das Lernen mit dem Vorzeichen des Weitersagens stattfindet. Wer nicht nur f\u00fcr sich, sondern auch immer f\u00fcr andere lernt, der lernt tiefer. Das wird klar, wenn man versucht, (angeblich) Gelerntes anderen zu vermitteln. Wenn man das nicht beim Lernen im Blick hat, tauchen schnell Fragen auf, die man sich selbst nie gestellt hat. Andere haben eben immer ganz andere Blickwinkel.</p> <p>Deshalb meinen wir, dass wirklich solide nur lernt, wer sich auch immer wieder dem Lehren, dem Weitersagen, der Wissensvermittlung aussetzt. Nur wer Gelerntes nicht nur anwendet, sondern es mit eigenen Worten f\u00fcr ein Publikum formuliert, bemerkt in dem Prozess, wie tief sein Wissen wirklich ist. Denn wenn sich die Fragezeichen bei den \u201eSch\u00fclern\u201c h\u00e4ufen, dann stimmt irgendetwas noch nicht.</p> <p>Ein reales Publikum ist daf\u00fcr nat\u00fcrlich am besten. Jeder CCD sollte also m\u00f6glichst regelm\u00e4\u00dfig Gelegenheiten suchen, um sein Wissen m\u00fcndlich weiterzugeben (z.B. bei Veranstaltungen im Kollegenkreis oder User Group Treffen). Unmittelbares Feedback ist ihm dabei gewiss. Alternativ bzw. in Erg\u00e4nzung taugen aber auch schriftliche Kompetenz\u00e4u\u00dferungen. Ein Blog ist in 5 Minuten aufgesetzt und Fachzeitschriften suchen st\u00e4ndig nach neuen Autoren. Feedback kommt hier zwar nicht so direkt zur\u00fcck, dennoch ist die textuelle Ausformulierung von Kenntnissen eine sehr gute \u00dcbung.</p> <p>CCD ab dem gr\u00fcnen Grad lernen daher nicht nur \u201epassiv\u201c durch Informationsaufnahme, sondern \u201eaktiv\u201c durch Weitergabe ihres Wissens mittels Pr\u00e4sentationen oder Texten. Das mag ungewohnt sein \u2013 ungewohnt ist aber auch wom\u00f6glich Continuous Integration. In jedem Fall ist aktive Wissensvermittlung eine gute \u00dcbung zur Vertiefung der eigenen Kompetenzen frei nach dem Motto: \u201eTue Gutes und sprich dar\u00fcber\u201c ;-)</p> <p>Dass das \u201eLehren\u201c auch noch einen Nutzen f\u00fcr die Zuh\u00f6rer/Leser hat, ist selbstverst\u00e4ndlich. Vorteile f\u00fcr andere sind aber nicht so motivierend wie eigene Vorteile. Deshalb betonen wir hier vor allem den Nutzen der Wissensvermittlung f\u00fcr den CCD.</p>","tags":["cleancode"]},{"location":"hidden/Sichtbarkeit%20von%20Systemzust%C3%A4nden%20und%20m%C3%B6glichen%20Aktionen/","title":"Sichtbarkeit von Systemzust\u00e4nden und m\u00f6glichen Aktionen","text":"<ul> <li>Verschiedene Modi erkennbar anzeigen</li> <li>Ausblenden von nicht aktivierbaren Dialogelementen</li> <li>Zul\u00e4ssige Wertbereiche anzeigen (numerische Werte)</li> <li>Erkl\u00e4rung, warum etwas nicht m\u00f6glich ist</li> </ul>","tags":["is"]},{"location":"hidden/Simple%20Refactorings/","title":"Simple Refactorings","text":"","tags":["cleancode"]},{"location":"hidden/Simple%20Refactorings/#simple-refactorings","title":"Simple Refactorings","text":"<p>Warum? Code verbessern ist leichter, wenn man typische Verbesserungshandgriffe kennt. Ihre Anwendungsszenarien machen sensibel f\u00fcr Schwachpunkte im eigenen Code. Als anerkannte Muster st\u00e4rken sie den Mut, sie anzuwenden.</p> <p>Um Code immer ein wenig besser zu hinterlassen, als man ihn vorgefunden hat, sind mehr oder weniger gro\u00dfe Eingriffe n\u00f6tig. Die kann ein Clean Code Developer dank des Versionskontrollsystems angstfrei vornehmen. Doch wie macht er sich die Arbeit m\u00f6glichst einfach?</p> <p>Das Schl\u00fcsselwort lautet \u201eRefaktorisierung\u201c.\u2003Martin Fowler\u2003hat das\u2003Refaktorisieren/Refactoring\u2003in seinem gleichnamigen Buch als grundlegende Technik zur Erh\u00f6hung der Codequalit\u00e4t beschrieben. Er definiert darin eine Anzahl von Codever\u00e4nderungsmustern, um \u201ecode smells\u201c, d.h. suboptimale Strukturen oder allgemeiner Missachtungen von Prinzipien, zu bereinigen.</p> <p>F\u00fcr den roten Grad ist darin vor allem die Refaktorisierung\u2003Methode extrahieren\u2003relevant, um dem DRY-Prinzip zu gen\u00fcgen. Die wenden Clean Code Developer an, um mehrfach vorkommenden Code in eine Methode zu extrahieren, die statt seiner an den Wiederholungsorten aufgerufen wird.</p> <p>Als zweite Refaktorisierung sollte bei der Arbeit am roten Grad das\u2003Umbenennen\u2003wo n\u00f6tig eingesetzt werden. Sie passt zur Pfadfinderregel, denn eine oft anzutreffende \u201eUnsauberkeit\u201c im Quellcode sind kryptische Namen.</p> <p>Refaktorisierungen k\u00f6nnen von Hand angewandt werden, doch es gibt auch Werkzeugunterst\u00fctzung. Moderne IDEs wie Visual Studio bieten einige Refactoringmuster, weitere Tools listet unsere\u2003Werkzeugliste.</p> <p>\u201eRefactoring\u201c wie \u201eClean Code\u201c geh\u00f6ren zur\u2003Pflichtlekt\u00fcre\u2003jedes Clean Code Developers ab dem roten Grad.</p> <p>F\u00fcr weitere Informationen siehe auch unter\u2003refactoring-legacy-code.net.</p>","tags":["cleancode"]},{"location":"hidden/Single%20Level%20of%20Abstraction/","title":"Single Level of Abstraction (SLA)","text":"","tags":["cleancode"]},{"location":"hidden/Single%20Level%20of%20Abstraction/#single-level-of-abstraction-sla","title":"Single Level of Abstraction (SLA)","text":"<p>Warum? Die Einhaltung eines Abstraktionsniveaus f\u00f6rdert die Lesbarkeit</p> <p>Eine Codezeile kann auf verschiedenen Abstraktionsniveaus liegen. Die Zuweisung eines Wertes an eine Variable liegt auf einem niedrigeren Abstraktionsniveau als etwa ein Methodenaufruf. Schlie\u00dflich kann sich hinter dem Methodenaufruf weit mehr Logik befinden als in der Zuweisung einer Variable. Selbst Methodenaufrufe k\u00f6nnen auf unterschiedlichen Abstraktionsniveaus stehen. Der Aufruf einer Methode aus einem Framework steht auf einem anderen Niveau, als der Aufruf einer Methode der Anwendung.</p> <p>Damit Code gut zu lesen und zu verstehen ist, sollte in einer Methode nur ein Abstraktionsniveau verwendet werden. Andernfalls f\u00e4llt es dem Leser schwer, Essentielles von Details zu unterscheiden. Wenn Bitpfriemeleien erforderlich sind, sollten diese nicht mit dem Aufruf von Methoden vermischt werden.</p> <p>Hilfreich als Analogie ist der Blick auf Artikel in der Tageszeitung: dort steht zu oberst das Allerwichtigste, die \u00dcberschrift. Aus ihr sollte in groben Z\u00fcgen hervorgehen, wovon der Artikel handelt. Im ersten Satz des Artikels wird dies auf einem hohen Abstraktionsniveau beschrieben. Je weiter man im Artikel fortschreitet, desto mehr Details tauchen auf. So k\u00f6nnen wir auch unseren Code strukturieren. Der Name der Klasse ist die \u00dcberschrift. Dann folgen die \u00f6ffentlichen Methoden auf hohem Abstraktionsniveau. Diese rufen m\u00f6glicherweise Methoden auf niedrigerem Niveau auf, bis zuletzt die \u201eBitpfriemelmethoden\u201c \u00fcbrig bleiben. Durch diese Einteilung kann ich als Leser der Klasse entscheiden, welchen Detaillierungsgrad ich mir ansehen m\u00f6chte. Interessiert mich nur grob, wie die Klasse arbeitet, brauche ich mir nur die \u00f6ffentlichen Methoden anzuschauen. In ihnen wird die Funktionalit\u00e4t auf einem hohen Abstraktionsniveau gel\u00f6st. Interessieren mich weitere Details, kann ich tiefer einsteigen und mir die privaten Methoden ansehen.</p>","tags":["cleancode"]},{"location":"hidden/Single%20Responsibility%20Principle/","title":"Single Responsibility Principle (SRP)","text":"","tags":["cleancode"]},{"location":"hidden/Single%20Responsibility%20Principle/#single-responsibility-principle-srp","title":"Single Responsibility Principle (SRP)","text":"<p>Warum?</p> <p>Fokus erleichtert das Verst\u00e4ndnis. Eine Klasse mit genau einer Aufgabe ist verst\u00e4ndlicher als ein Gemischtwarenladen.</p> <p>Das Single Responsibility Principle (SRP) ist eines der\u2003SOLID\u2003Prinzipien. Es lautet: Eine Klasse sollte nur\u2003eine\u2003Verantwortlichkeit haben.</p> <p>Hintergrund des Single Responsibility Principle ist die \u00dcberlegung, dass \u00c4nderungen oder Erweiterungen der Funktionalit\u00e4t einer Anwendung sich auf wenige Klassen beschr\u00e4nken sollen. Je mehr Klassen angepasst werden m\u00fcssen, desto gr\u00f6\u00dfer ist das Risiko, dass sich durch die erforderlichen \u00c4nderungen Probleme an Stellen ergeben, die im Kern nichts mit der Erweiterung zu tun haben. Eine Verletzung des Single Responsibility Principle f\u00fchrt zu Kopplung und damit zu erh\u00f6hter Komplexit\u00e4t, es wird schwieriger den Code zu verstehen.</p> <p>Sources:</p> <ul> <li>https://clean-code-developer.de/die-grade/orangener-grad/Single_Responsibility_Principle_SRP</li> <li>https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html</li> </ul>","tags":["cleancode"]},{"location":"hidden/Singleton/","title":"Singleton","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Singleton/#singleton","title":"Singleton","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Singleton/#intent","title":"Intent","text":"<p>Singleton\u2003is a creational design pattern that lets you ensure that a class has only one instance, while providing a global access point to this\u2003instance.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Singleton/#problem","title":"Problem","text":"<p>The Singleton pattern solves two problems at the same time, violating the\u2003Single Responsibility Principle:</p> <ol> <li> <p>Ensure that a class has just a single instance. Why would anyone want to control how many instances a class has? The most common reason for this is to control access to some shared resource\u2014for example, a database or a file.</p> <p>Here\u2019s how it works: imagine that you created an object, but after a while decided to create a new one. Instead of receiving a fresh object, you\u2019ll get the one you already created.</p> <p>Note that this behavior is impossible to implement with a regular constructor since a constructor call\u2003must\u2003always return a new object by design.</p> </li> </ol> <p></p> <p>Clients may not even realize that they\u2019re working with the same object all the\u2003time.</p> <ol> <li> <p>Provide a global access point to that instance. Remember those global variables that you (all right, me) used to store some essential objects? While they\u2019re very handy, they\u2019re also very unsafe since any code can potentially overwrite the contents of those variables and crash the app.</p> <p>Just like a global variable, the Singleton pattern lets you access some object from anywhere in the program. However, it also protects that instance from being overwritten by other code.</p> <p>There\u2019s another side to this problem: you don\u2019t want the code that solves problem 1 to be scattered all over your program. It\u2019s much better to have it within one class, especially if the rest of your code already depends on it.</p> </li> </ol> <p>Nowadays, the Singleton pattern has become so popular that people may call something a\u2003singleton\u2003even if it solves just one of the listed problems.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Singleton/#solution","title":"Solution","text":"<p>All implementations of the Singleton have these two steps in common:</p> <ul> <li>Make the default constructor private, to prevent other objects from using the\u2003<code>new</code>\u2003operator with the Singleton class.</li> <li>Create a static creation method that acts as a constructor. Under the hood, this method calls the private constructor to create an object and saves it in a static field. All following calls to this method return the cached object.</li> </ul> <p>If your code has access to the Singleton class, then it\u2019s able to call the Singleton\u2019s static method. So whenever that method is called, the same object is always returned.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Singleton/#real-world-analogy","title":"Real-World Analogy","text":"<p>The government is an excellent example of the Singleton pattern. A country can have only one official government. Regardless of the personal identities of the individuals who form governments, the title, \u201cThe Government of X\u201d, is a global point of access that identifies the group of people in charge.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Singleton/#structure","title":"Structure","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Singleton/#pseudocode","title":"Pseudocode","text":"<p>In this example, the database connection class acts as a\u2003Singleton. This class doesn\u2019t have a public constructor, so the only way to get its object is to call the\u2003<code>getInstance</code>\u2003method. This method caches the first created object and returns it in all subsequent calls.</p> <pre><code>// The Database class defines the `getInstance` method that lets\n// clients access the same instance of a database connection\n// throughout the program.\nclass Database is\n    // The field for storing the singleton instance should be\n    // declared static.\n    private static field instance: Database\n\n    // The singleton's constructor should always be private to\n    // prevent direct construction calls with the `new`\n    // operator.\n    private constructor Database() is\n        // Some initialization code, such as the actual\n        // connection to a database server.\n        // ...\n\n    // The static method that controls access to the singleton\n    // instance.\n    public static method getInstance() is\n        if (Database.instance == null) then\n            acquireThreadLock() and then\n                // Ensure that the instance hasn't yet been\n                // initialized by another thread while this one\n                // has been waiting for the lock's release.\n                if (Database.instance == null) then\n                    Database.instance = new Database()\n        return Database.instance\n\n    // Finally, any singleton should define some business logic\n    // which can be executed on its instance.\n    public method query(sql) is\n        // For instance, all database queries of an app go\n        // through this method. Therefore, you can place\n        // throttling or caching logic here.\n        // ...\n\nclass Application is\n    method main() is\n        Database foo = Database.getInstance()\n        foo.query(\"SELECT ...\")\n        // ...\n        Database bar = Database.getInstance()\n        bar.query(\"SELECT ...\")\n        // The variable `bar` will contain the same object as\n        // the variable `foo`.\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/Singleton/#applicability","title":"Applicability","text":"<ul> <li> <p> Use the Singleton pattern when a class in your program should have just a single instance available to all clients; for example, a single database object shared by different parts of the program.     \u2003The Singleton pattern disables all other means of creating objects of a class except for the special creation method. This method either creates a new object or returns an existing one if it has already been created.</p> </li> <li> <p>Use the Singleton pattern when you need stricter control over global variables.     Unlike global variables, the Singleton pattern guarantees that there\u2019s just one instance of a class. Nothing, except for the Singleton class itself, can replace the cached instance.</p> <p>Note that you can always adjust this limitation and allow creating any number of Singleton instances. The only piece of code that needs changing is the body of the\u2003<code>getInstance</code>\u2003method.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Singleton/#how-to-implement","title":"How to Implement","text":"<ol> <li>Add a private static field to the class for storing the singleton instance.</li> <li>Declare a public static creation method for getting the singleton instance.</li> <li>Implement \u201clazy initialization\u201d inside the static method. It should create a new object on its first call and put it into the static field. The method should always return that instance on all subsequent calls.</li> <li>Make the constructor of the class private. The static method of the class will still be able to call the constructor, but not the other objects.</li> <li>Go over the client code and replace all direct calls to the singleton\u2019s constructor with calls to its static creation method.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Singleton/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can be sure that a class has only a single instance. Violates the\u2003Single Responsibility Principle. The pattern solves two problems at the time. You gain a global access point to that instance. The Singleton pattern can mask bad design, for instance, when the components of the program know too much about each other. The singleton object is initialized only when it\u2019s requested for the first time. The Singleton pattern can mask bad design, for instance, when the components of the program know too much about each other. The Singleton pattern can mask bad design, for instance, when the components of the program know too much about each other. The pattern requires special treatment in a multithreaded environment so that multiple threads won\u2019t create a singleton object several times. It may be difficult to Unit Test the client code of the Singleton because many test frameworks rely on inheritance when producing mock objects. Since the constructor of the singleton class is private and overriding static methods is impossible in most languages, you will need to think of a creative way to mock the singleton. Or just don\u2019t write the tests. Or don\u2019t use the Singleton pattern.","tags":["cleancode_designpatterns"]},{"location":"hidden/Singleton/#relationship-with-other-patterns","title":"Relationship with Other Patterns","text":"<ul> <li> <p>A\u2003Facade\u2003class can often be transformed into a\u2003Singleton\u2003since a single facade object is sufficient in most cases.</p> </li> <li> <p>Flyweight\u2003would resemble\u2003Singleton\u2003if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:</p> <ol> <li>There should be only one Singleton instance, whereas a\u2003Flyweight\u2003class can have multiple instances with different intrinsic states.</li> <li>The\u2003Singleton\u2003object can be mutable. Flyweight objects are immutable.</li> </ol> </li> <li>Abstract Factory, Builder\u2003and\u2003Prototype\u2003can all be implemented as\u2003Singleton.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Source%20Code%20Conventions/","title":"Source Code Conventions","text":"","tags":["cleancode"]},{"location":"hidden/Source%20Code%20Conventions/#source-code-conventions","title":"Source Code Conventions","text":"<p>Warum? Code wird h\u00e4ufiger gelesen als geschrieben. Daher sind Konventionen wichtig, die ein schnelles Lesen und Erfassen des Codes unterst\u00fctzen.</p> <p>Wir betrachten die folgenden Aspekte als wichtig:</p> <ul> <li>Namensregeln</li> <li>Richtig Kommentieren</li> </ul> <p>Damit wollen wir nicht zum Ausdruck bringen, dass andere Konventionen unwichtig sind, wir wollen nur mit diesen beiden beginnen, weil sie uns elementar erscheinen. Bei allen Code Konventionen ist uns n\u00e4mlich eines ganz wichtig: es geht weniger um die konkrete Ausgestaltung, sondern um konsequentes Einhalten der Konvention. Und es geht um das Bewusstsein, dass Konventionen notwendig sind.</p>","tags":["cleancode"]},{"location":"hidden/Source%20Code%20Conventions/#namensregeln","title":"Namensregeln","text":"<p>Warum? Ohne Namensregeln muss man sich wieder und wieder auf den Stil einzelner Entwickler einstimmen.</p> <p>Namensregeln sollen den Leser des Codes dabei unterst\u00fctzen den Code zu verstehen. Da es z.B. hilfreich ist, Felder von lokalen Variablen zu unterscheiden, k\u00f6nnte dies durch eine Namensregel unterst\u00fctzt werden. Wie eine solche Konvention im Einzelfall aussieht ist Geschmacksache. Manche bevorzugen \u201ethis.xyz\u201c andere \u201e_xyz\u201c. Welche Variante man w\u00e4hlt ist uns nicht wichtig. Uns kommt es darauf an, dass die Konvention konsequent eingehalten wird. Die Notwendigkeit einer Namensregel f\u00fcr z.B. Felder h\u00e4ngt ferner vom Kontext ab. In einer Klasse mit 400 Zeilen w\u00e4re uns eine Namensregel, die Felder gegen\u00fcber Variablen hervorhebt, sehr wichtig, in \u00fcberschaubaren Klassen tritt sie dagegen eher in den Hintergrund. Mit Hilfe der Root Cause Analysis geht der Clean Code Developer der eigentlichen Ursache f\u00fcr die Notwendigkeit einer Namensregel auf den Grund.</p>","tags":["cleancode"]},{"location":"hidden/Source%20Code%20Conventions/#richtig-kommentieren","title":"Richtig kommentieren","text":"<p>Warum? Unn\u00f6tige oder gar falsche Kommentare halten beim Lesen auf. Der Code sollte so klar und deutlich sein, dass er m\u00f6glichst ohne Kommentare auskommt.</p> <p>Salopp gesagt ist ein Kommentar im Code ein Hinweis darauf, dass der Code noch verbessert werden kann. Typisch f\u00fcr solche F\u00e4lle sind 3 Zeilen Code, die mit einem Kommentar \u00fcberschrieben sind. An der Stelle hilft es wahrscheinlich, die drei Zeilen als Methode zu extrahieren (Refactoring: Extract Method) und den Kommentar als Name der Methode zu verwenden. Ganz allgemein kann der Bedarf an Kommentaren reduziert werden, in dem man gute Namen verwendet f\u00fcr Variablen, Methoden, Klassen, etc.</p> <p>Statt <pre><code>int laenge; // in mm\n</code></pre> besser <pre><code>int laengeInMM;\n</code></pre></p> <p>Statt <pre><code>public double Preis() {\n\t// Berechnet den Bruttopreis ...\n}\n</code></pre> besser <pre><code>public Money BruttoPreis() {\n\t...\n}\n</code></pre></p> <p>Kommentiert werden sollte nicht was man tut, sondern, wenn \u00fcberhaupt, wieso man etwas tut.</p>","tags":["cleancode"]},{"location":"hidden/Spinatnudeln/","title":"Spinatnudeln","text":"","tags":["Pasta","italian"]},{"location":"hidden/Spinatnudeln/#zutaten","title":"Zutaten","text":"<ul> <li>Spaghetti</li> <li>Sahne</li> <li>Scharlotte</li> <li>Knoblauch</li> <li>Butter</li> <li>Oliven\u00f6l</li> <li>Salz</li> <li>Pfeffer</li> <li>Muskatnuss</li> </ul>","tags":["Pasta","italian"]},{"location":"hidden/Spinatnudeln/#zubereitung","title":"Zubereitung","text":"<p>Salzwasser f\u00fcr die Nudeln aufsetzen. W\u00e4hrenddessen eine Scharlotte und ein/zwei Zehen Knoblauch fein w\u00fcrfeln. Butter und Oliven\u00f6l in der Pfanne auf mittlerer Hitze schmelzen und das geschnittene and\u00fcnsten.  </p> <p>Nudeln in den Topf und gleichzeitig die Sahne in die Pfanne und kurz aufkochen lassen. Den Tiefk\u00fchlspinat dazugeben und auftauen lassen. Die So\u00dfe mit Salz, schwarzen Pfeffer und Muskatnuss w\u00fcrzen. Die Nudeln zwei Minuten vor der Zeit von dem Top in die Pfanne dazugeben und eine Kelle Salzwasser zur Pfanne geben. Die Nudeln noch zwei Minuten fertig kochen lassen.</p>","tags":["Pasta","italian"]},{"location":"hidden/State/","title":"State","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/State/#state","title":"State","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/State/#intent","title":"Intent","text":"<p>State\u2003is a behavioral design pattern that lets an object alter its behavior when its internal state changes. It appears as if the object changed its\u2003class.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/State/#problem","title":"Problem","text":"<p>The State pattern is closely related to the concept of a\u2003Finite-State Machine\u2003.</p> <p></p> <p>Finite-State\u2003Machine.</p> <p>The main idea is that, at any given moment, there\u2019s a\u2003finite\u2003number of\u2003states\u2003which a program can be in. Within any unique state, the program behaves differently, and the program can be switched from one state to another instantaneously. However, depending on a current state, the program may or may not switch to certain other states. These switching rules, called\u2003transitions, are also finite and predetermined.</p> <p>You can also apply this approach to objects. Imagine that we have a\u2003<code>Document</code>\u2003class. A document can be in one of three states:\u2003<code>Draft</code>,\u2003<code>Moderation</code>\u2003and\u2003<code>Published</code>. The\u2003<code>publish</code>\u2003method of the document works a little bit differently in each state:</p> <ul> <li>In\u2003<code>Draft</code>, it moves the document to moderation.</li> <li>In\u2003<code>Moderation</code>, it makes the document public, but only if the current user is an administrator.</li> <li>In\u2003<code>Published</code>, it doesn\u2019t do anything at all.</li> </ul> <p></p> <p>Possible states and transitions of a document\u2003object.</p> <p>State machines are usually implemented with lots of conditional statements (<code>if</code>\u2003or\u2003<code>switch</code>) that select the appropriate behavior depending on the current state of the object. Usually, this \u201cstate\u201d is just a set of values of the object\u2019s fields. Even if you\u2019ve never heard about finite-state machines before, you\u2019ve probably implemented a state at least once. Does the following code structure ring a bell?</p> <pre><code>class Document is\n    field state: string\n    // ...\n    method publish() is\n        switch (state)\n            \"draft\":\n                state = \"moderation\"\n                break\n            \"moderation\":\n                if (currentUser.role == \"admin\")\n                    state = \"published\"\n                break\n            \"published\":\n                // Do nothing.\n                break\n    // ...\n\nThe biggest weakness of a state machine based on conditionals reveals itself once we start adding more and more states and state-dependent behaviors to the&amp;emsp;`Document`&amp;emsp;class. Most methods will contain monstrous conditionals that pick the proper behavior of a method according to the current state. Code like this is very difficult to maintain because any change to the transition logic may require changing state conditionals in every method.\n\nThe problem tends to get bigger as a project evolves. It\u2019s quite difficult to predict all possible states and transitions at the design stage. Hence, a lean state machine built with a limited set of conditionals can grow into a bloated mess over time.\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/State/#solution","title":"Solution","text":"<p>The State pattern suggests that you create new classes for all possible states of an object and extract all state-specific behaviors into these classes.</p> <p>Instead of implementing all behaviors on its own, the original object, called\u2003context, stores a reference to one of the state objects that represents its current state, and delegates all the state-related work to that object.</p> <p></p> <p>Document delegates the work to a state\u2003object.</p> <p>To transition the context into another state, replace the active state object with another object that represents that new state. This is possible only if all state classes follow the same interface and the context itself works with these objects through that interface.</p> <p>This structure may look similar to the\u2003Strategy Pattern, but there\u2019s one key difference. In the State pattern, the particular states may be aware of each other and initiate transitions from one state to another, whereas strategies almost never know about each other.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/State/#real-world-analogy","title":"Real-World Analogy","text":"<p>The buttons and switches in your smartphone behave differently depending on the current state of the device:</p> <ul> <li>When the phone is unlocked, pressing buttons leads to executing various functions.</li> <li>When the phone is locked, pressing any button leads to the unlock screen.</li> <li>When the phone\u2019s charge is low, pressing any button shows the charging screen.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/State/#structure","title":"Structure","text":"<ol> <li>Context\u2003stores a reference to one of the concrete state objects and delegates to it all state-specific work. The context communicates with the state object via the state interface. The context exposes a setter for passing it a new state object.</li> <li>The\u2003State\u2003interface declares the state-specific methods. These methods should make sense for all concrete states because you don\u2019t want some of your states to have useless methods that will never be called.</li> <li> <p>Concrete States\u2003provide their own implementations for the state-specific methods. To avoid duplication of similar code across multiple states, you may provide intermediate abstract classes that encapsulate some common behavior.</p> <p>State objects may store a backreference to the context object. Through this reference, the state can fetch any required info from the context object, as well as initiate state transitions.</p> </li> <li> <p>Both context and concrete states can set the next state of the context and perform the actual state transition by replacing the state object linked to the context.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/State/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003State\u2003pattern lets the same controls of the media player behave differently, depending on the current playback state.</p> <p></p> <p>Example of changing object behavior with state\u2003objects.</p> <p>The main object of the player is always linked to a state object that performs most of the work for the player. Some actions replace the current state object of the player with another, which changes the way the player reacts to user interactions. <pre><code>// The AudioPlayer class acts as a context. It also maintains a\n// reference to an instance of one of the state classes that\n// represents the current state of the audio player.\nclass AudioPlayer is\n    field state: State\n    field UI, volume, playlist, currentSong\n\n    constructor AudioPlayer() is\n        this.state = new ReadyState(this)\n\n        // Context delegates handling user input to a state\n        // object. Naturally, the outcome depends on what state\n        // is currently active, since each state can handle the\n        // input differently.\n        UI = new UserInterface()\n        UI.lockButton.onClick(this.clickLock)\n        UI.playButton.onClick(this.clickPlay)\n        UI.nextButton.onClick(this.clickNext)\n        UI.prevButton.onClick(this.clickPrevious)\n\n    // Other objects must be able to switch the audio player's\n    // active state.\n    method changeState(state: State) is\n        this.state = state\n\n    // UI methods delegate execution to the active state.\n    method clickLock() is\n        state.clickLock()\n    method clickPlay() is\n        state.clickPlay()\n    method clickNext() is\n        state.clickNext()\n    method clickPrevious() is\n        state.clickPrevious()\n\n    // A state may call some service methods on the context.\n    method startPlayback() is\n        // ...\n    method stopPlayback() is\n        // ...\n    method nextSong() is\n        // ...\n    method previousSong() is\n        // ...\n    method fastForward(time) is\n        // ...\n    method rewind(time) is\n        // ...\n\n// The base state class declares methods that all concrete\n// states should implement and also provides a backreference to\n// the context object associated with the state. States can use\n// the backreference to transition the context to another state.\nabstract class State is\n    protected field player: AudioPlayer\n\n    // Context passes itself through the state constructor. This\n    // may help a state fetch some useful context data if it's\n    // needed.\n    constructor State(player) is\n        this.player = player\n\n    abstract method clickLock()\n    abstract method clickPlay()\n    abstract method clickNext()\n    abstract method clickPrevious()\n\n// Concrete states implement various behaviors associated with a\n// state of the context.\nclass LockedState extends State is\n\n    // When you unlock a locked player, it may assume one of two\n    // states.\n    method clickLock() is\n        if (player.playing)\n            player.changeState(new PlayingState(player))\n        else\n            player.changeState(new ReadyState(player))\n\n    method clickPlay() is\n        // Locked, so do nothing.\n\n    method clickNext() is\n        // Locked, so do nothing.\n\n    method clickPrevious() is\n        // Locked, so do nothing.\n\n// They can also trigger state transitions in the context.\nclass ReadyState extends State is\n    method clickLock() is\n        player.changeState(new LockedState(player))\n\n    method clickPlay() is\n        player.startPlayback()\n        player.changeState(new PlayingState(player))\n\n    method clickNext() is\n        player.nextSong()\n\n    method clickPrevious() is\n        player.previousSong()\n\nclass PlayingState extends State is\n    method clickLock() is\n        player.changeState(new LockedState(player))\n\n    method clickPlay() is\n        player.stopPlayback()\n        player.changeState(new ReadyState(player))\n\n    method clickNext() is\n        if (event.doubleclick)\n            player.nextSong()\n        else\n            player.fastForward(5)\n\n    method clickPrevious() is\n        if (event.doubleclick)\n            player.previous()\n        else\n            player.rewind(5)\n</code></pre></p>","tags":["cleancode_designpatterns"]},{"location":"hidden/State/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the State pattern when you have an object that behaves differently depending on its current state, the number of states is enormous, and the state-specific code changes frequently.   The pattern suggests that you extract all state-specific code into a set of distinct classes. As a result, you can add new states or change existing ones independently of each other, reducing the maintenance cost.</p> </li> <li> <p>Use the pattern when you have a class polluted with massive conditionals that alter how the class behaves according to the current values of the class\u2019s fields.   The State pattern lets you extract branches of these conditionals into methods of corresponding state classes. While doing so, you can also clean temporary fields and helper methods involved in state-specific code out of your main class.</p> </li> <li> <p>Use State when you have a lot of duplicate code across similar states and transitions of a condition-based state machine.   The State pattern lets you compose hierarchies of state classes and reduce duplication by extracting common code into abstract base classes.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/State/#how-to-implement","title":"How to Implement","text":"<ol> <li>Decide what class will act as the context. It could be an existing class which already has the state-dependent code; or a new class, if the state-specific code is distributed across multiple classes.</li> <li>Declare the state interface. Although it may mirror all the methods declared in the context, aim only for those that may contain state-specific behavior.</li> <li> <p>For every actual state, create a class that derives from the state interface. Then go over the methods of the context and extract all code related to that state into your newly created class.</p> <p>While moving the code to the state class, you might discover that it depends on private members of the context. There are several workarounds:</p> <ul> <li>Make these fields or methods public.</li> <li>Turn the behavior you\u2019re extracting into a public method in the context and call it from the state class. This way is ugly but quick, and you can always fix it later.</li> <li>Nest the state classes into the context class, but only if your programming language supports nesting classes. 4.  In the context class, add a reference field of the state interface type and a public setter that allows overriding the value of that field. 5.  Go over the method of the context again and replace empty state conditionals with calls to corresponding methods of the state object. 6.  To switch the state of the context, create an instance of one of the state classes and pass it to the context. You can do this within the context itself, or in various states, or in the client. Wherever this is done, the class becomes dependent on the concrete state class that it instantiates.</li> </ul> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/State/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons Single Responsibility Principle. Organize the code related to particular states into separate classes. Applying the pattern can be overkill if a state machine has only a few states or rarely changes. Open Closed Principle. Introduce new states without changing existing state classes or the context. Simplify the code of the context by eliminating bulky state machine conditionals.","tags":["cleancode_designpatterns"]},{"location":"hidden/State/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Bridge, State, Strategy Pattern (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn\u2019t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.</li> <li>State can be considered as an extension of Strategy Pattern. Both patterns are based on composition: they change the behavior of the context by delegating some work to helper objects. Strategy Pattern makes these objects completely independent and unaware of each other. However, State doesn\u2019t restrict dependencies between concrete states, letting them alter the state of the context at will.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Statical%20Code%20Analysis/","title":"Statical Code Analysis","text":"","tags":["cleancode"]},{"location":"hidden/Statical%20Code%20Analysis/#statical-code-analysis","title":"Statical Code Analysis","text":"<p>Warum? Vertrauen ist gut, Kontrolle ist besser \u2013 und je automatischer, desto leichter ist sie.</p> <p>Wie definiert sich eigentlich die Qualit\u00e4t einer Codeeinheit, z.B. einer Klasse oder Komponente? Reicht es, dass sie funktional die Anforderungen des Kunden erf\u00fcllt? Reicht es, dass er schnell genug und skalierbar genug ist? Automatische Tests und schlie\u00dflich Tests durch den Kunden geben dar\u00fcber ja Auskunft. Ohne solche Anforderungskonformit\u00e4t hat Software nat\u00fcrlich keine relevante Qualit\u00e4t. Wenn sie dem Kunden nicht n\u00fctzt, er\u00fcbrigt sich jede weitere Frage.</p> <p>Auf der anderen Seite reicht es, entgegen immer noch weit verbreiteter Annahme, allerdings auch nicht, anforderungskonform zu sein. Hohe Qualit\u00e4t ergibt sich nicht allein aus Funktionalit\u00e4t und z.B. Performance. Denn neben den funktionalen und nicht funktionalen Anforderungen gibt es auch noch eine meist unausgesprochene verborgene Anforderung: Kunden wollen auch immer, dass Software nicht nur heute ihre Anforderungen erf\u00fcllt, sondern auch noch morgen und \u00fcbermorgen. Kunden wollen Investitionsschutz durch Wandelbarkeit.</p> <p>F\u00fcr Kunden ist diese Anforderung meist implizit. Sie glauben, es sei selbstverst\u00e4ndlich, dass ein immaterielles Produkt wie Software sich quasi unendlich und auf Knopfdruck an neue Anforderungen anpassen lie\u00dfe. Auch F\u00fchrungskr\u00e4fte, die nicht aus der Softwareentwicklung stammen, glauben das oft. Und sogar Softwareentwickler selbst!</p> <p>Gr\u00f6\u00dfer k\u00f6nnte das Missverst\u00e4ndnis \u00fcber Software jedoch kaum sein. Wandelbarkeit ist weder selbstverst\u00e4ndlich im Sinne eines von jedem Softwareentwickler ohnehin verfolgten Zieles, noch ergibt sie sich durch irgendetwas quasi von selbst. Wandelbarkeit ist vielmehr harte Arbeit und muss st\u00e4ndig gegen andere Werte abgewogen werden.</p> <p>Wenn sonstige Anforderungskonformit\u00e4t sich nun durch (automatisierte) Tests feststellen l\u00e4sst, wie steht es dann mit der Wandelbarkeit? L\u00e4sst sich die Qualit\u00e4t von Code im Hinblick auf seine (\u00dcber)Lebensf\u00e4higkeit auch automatisch messen? Zum Teil. Nicht alle Aspekte, die Software evolvierbar machen, sind automatisch pr\u00fcfbar. Ob zum Beispiel Software offen f\u00fcr Erweiterungen durch ein Add-In-Konzept gehalten wird, ist nicht automatisiert erkennbar.</p> <p>Dennoch gibt es\u2003Metriken, deren Wert f\u00fcr eine Software sich \u201eausrechnen\u201c l\u00e4sst.\u2003Tools\u2003helfen dabei. Diese Tools sollten daher in jedem Softwareprojekt zum Einsatz kommen.</p> <ul> <li>F\u00fcr Legacy Code k\u00f6nnen die Tools den Status Quo erheben und somit eine Grundlinie definieren, mit der die weitere Entwicklung des Codes (zum Besseren) verglichen werden kann.</li> <li>F\u00fcr neuen Code, der mit Wandelbarkeit im Blick geplant wurde, zeigt solch statische Codeanalyse, ob er das Ideal der Planung erf\u00fcllt.</li> </ul> <p>CCD sind nicht damit zufrieden, Code nur automatisiert zu testen. Sie haben auch immer ein Auge auf seine Wandelbarkeit, denn sie wissen, dass Kunden daran genauso interessiert sind \u2013 egal, ob sie es explizit gesagt haben oder nicht.</p> <p>Siehe auch unter\u2003Tools.</p>","tags":["cleancode"]},{"location":"hidden/Strategy/","title":"Strategy","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Strategy/#strategy","title":"Strategy","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Strategy/#intent","title":"Intent","text":"<p>Strategy\u2003is a behavioral design pattern that lets you define a family of algorithms, put each of them into a separate class, and make their objects\u2003interchangeable.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Strategy/#problem","title":"Problem","text":"<p>One day you decided to create a navigation app for casual travelers. The app was centered around a beautiful map which helped users quickly orient themselves in any city.</p> <p>One of the most requested features for the app was automatic route planning. A user should be able to enter an address and see the fastest route to that destination displayed on the map.</p> <p>The first version of the app could only build the routes over roads. People who traveled by car were bursting with joy. But apparently, not everybody likes to drive on their vacation. So with the next update, you added an option to build walking routes. Right after that, you added another option to let people use public transport in their routes.</p> <p>However, that was only the beginning. Later you planned to add route building for cyclists. And even later, another option for building routes through all of a city\u2019s tourist attractions.</p> <p></p> <p>The code of the navigator became\u2003bloated.</p> <p>While from a business perspective the app was a success, the technical part caused you many headaches. Each time you added a new routing algorithm, the main class of the navigator doubled in size. At some point, the beast became too hard to maintain.</p> <p>Any change to one of the algorithms, whether it was a simple bug fix or a slight adjustment of the street score, affected the whole class, increasing the chance of creating an error in already-working code.</p> <p>In addition, teamwork became inefficient. Your teammates, who had been hired right after the successful release, complain that they spend too much time resolving merge conflicts. Implementing a new feature requires you to change the same huge class, conflicting with the code produced by other people.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Strategy/#solution","title":"Solution","text":"<p>The Strategy pattern suggests that you take a class that does something specific in a lot of different ways and extract all of these algorithms into separate classes called\u2003strategies.</p> <p>The original class, called\u2003context, must have a field for storing a reference to one of the strategies. The context delegates the work to a linked strategy object instead of executing it on its own.</p> <p>The context isn\u2019t responsible for selecting an appropriate algorithm for the job. Instead, the client passes the desired strategy to the context. In fact, the context doesn\u2019t know much about strategies. It works with all strategies through the same generic interface, which only exposes a single method for triggering the algorithm encapsulated within the selected strategy.</p> <p>This way the context becomes independent of concrete strategies, so you can add new algorithms or modify existing ones without changing the code of the context or other strategies.</p> <p></p> <p>Route planning\u2003strategies.</p> <p>In our navigation app, each routing algorithm can be extracted to its own class with a single\u2003<code>buildRoute</code>\u2003method. The method accepts an origin and destination and returns a collection of the route\u2019s checkpoints.</p> <p>Even though given the same arguments, each routing class might build a different route, the main navigator class doesn\u2019t really care which algorithm is selected since its primary job is to render a set of checkpoints on the map. The class has a method for switching the active routing strategy, so its clients, such as the buttons in the user interface, can replace the currently selected routing behavior with another one.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Strategy/#real-world-analogy","title":"Real-World Analogy","text":"<p>Various strategies for getting to the\u2003airport.</p> <p>Imagine that you have to get to the airport. You can catch a bus, order a cab, or get on your bicycle. These are your transportation strategies. You can pick one of the strategies depending on factors such as budget or time constraints.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Strategy/#structure","title":"Structure","text":"<ol> <li> <p>The\u2003Context\u2003maintains a reference to one of the concrete strategies and communicates with this object only via the strategy interface.</p> </li> <li> <p>The\u2003Strategy\u2003interface is common to all concrete strategies. It declares a method the context uses to execute a strategy.</p> </li> <li> <p>Concrete Strategies\u2003implement different variations of an algorithm the context uses.</p> </li> <li> <p>The context calls the execution method on the linked strategy object each time it needs to run the algorithm. The context doesn\u2019t know what type of strategy it works with or how the algorithm is executed.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Strategy/#pseudocode","title":"Pseudocode","text":"<p>In this example, the context uses multiple\u2003strategies\u2003to execute various arithmetic operations.</p> <pre><code>// The strategy interface declares operations common to all\n// supported versions of some algorithm. The context uses this\n// interface to call the algorithm defined by the concrete\n// strategies.\ninterface Strategy is\n    method execute(a, b)\n\n// Concrete strategies implement the algorithm while following\n// the base strategy interface. The interface makes them\n// interchangeable in the context.\nclass ConcreteStrategyAdd implements Strategy is\n    method execute(a, b) is\n        return a + b\n\nclass ConcreteStrategySubtract implements Strategy is\n    method execute(a, b) is\n        return a - b\n\nclass ConcreteStrategyMultiply implements Strategy is\n    method execute(a, b) is\n        return a * b\n\n// The context defines the interface of interest to clients.\nclass Context is\n    // The context maintains a reference to one of the strategy\n    // objects. The context doesn't know the concrete class of a\n    // strategy. It should work with all strategies via the\n    // strategy interface.\n    private strategy: Strategy\n\n    // Usually the context accepts a strategy through the\n    // constructor, and also provides a setter so that the\n    // strategy can be switched at runtime.\n    method setStrategy(Strategy strategy) is\n        this.strategy = strategy\n\n    // The context delegates some work to the strategy object\n    // instead of implementing multiple versions of the\n    // algorithm on its own.\n    method executeStrategy(int a, int b) is\n        return strategy.execute(a, b)\n\n// The client code picks a concrete strategy and passes it to\n// the context. The client should be aware of the differences\n// between strategies in order to make the right choice.\nclass ExampleApplication is\n    method main() is\n        Create context object.\n\n        Read first number.\n        Read last number.\n        Read the desired action from user input.\n\n        if (action == addition) then\n            context.setStrategy(new ConcreteStrategyAdd())\n\n        if (action == subtraction) then\n            context.setStrategy(new ConcreteStrategySubtract())\n\n        if (action == multiplication) then\n            context.setStrategy(new ConcreteStrategyMultiply())\n\n        result = context.executeStrategy(First number, Second number)\n\n        Print result.\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/Strategy/#applicability","title":"Applicability","text":"<ul> <li>Use the Strategy pattern when you want to use different variants of an algorithm within an object and be able to switch from one algorithm to another during runtime.   The Strategy pattern lets you indirectly alter the object\u2019s behavior at runtime by associating it with different sub-objects which can perform specific sub-tasks in different ways.</li> <li>Use the Strategy when you have a lot of similar classes that only differ in the way they execute some behavior. \u2003  The Strategy pattern lets you extract the varying behavior into a separate class hierarchy and combine the original classes into one, thereby reducing duplicate code.</li> <li>Use the pattern to isolate the business logic of a class from the implementation details of algorithms that may not be as important in the context of that logic.   The Strategy pattern lets you isolate the code, internal data, and dependencies of various algorithms from the rest of the code. Various clients get a simple interface to execute the algorithms and switch them at runtime.</li> <li>Use the pattern when your class has a massive conditional statement that switches between different variants of the same algorithm.   The Strategy pattern lets you do away with such a conditional by extracting all algorithms into separate classes, all of which implement the same interface. The original object delegates execution to one of these objects, instead of implementing all variants of the algorithm.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Strategy/#how-to-implement","title":"How to Implement","text":"<ol> <li>In the context class, identify an algorithm that\u2019s prone to frequent changes. It may also be a massive conditional that selects and executes a variant of the same algorithm at runtime.</li> <li>Declare the strategy interface common to all variants of the algorithm.</li> <li>One by one, extract all algorithms into their own classes. They should all implement the strategy interface.</li> <li>In the context class, add a field for storing a reference to a strategy object. Provide a setter for replacing values of that field. The context should work with the strategy object only via the strategy interface. The context may define an interface which lets the strategy access its data.</li> <li>Clients of the context must associate it with a suitable strategy that matches the way they expect the context to perform its primary job.</li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Strategy/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can swap algorithms used inside an object at runtime. If you only have a couple of algorithms and they rarely change, there\u2019s no real reason to overcomplicate the program with new classes and interfaces that come along with the pattern. You can isolate the implementation details of an algorithm from the code that uses it. Clients must be aware of the differences between strategies to be able to select a proper one. You can replace inheritance with composition. A lot of modern programming languages have functional type support that lets you implement different versions of an algorithm inside a set of anonymous functions. Then you could use these functions exactly as you\u2019d have used the strategy objects, but without bloating your code with extra classes and interfaces. Open Closed Principle. You can introduce new strategies without having to change the context.","tags":["cleancode_designpatterns"]},{"location":"hidden/Strategy/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn\u2019t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.</li> <li>Command and Strategy may look similar because you can use both to parameterize an object with some action. However, they have very different intents.<ul> <li>You can use Command to convert any operation into an object. The operation\u2019s parameters become fields of that object. The conversion lets you defer execution of the operation, queue it, store the history of commands, send commands to remote services, etc.</li> <li>On the other hand, Strategy usually describes different ways of doing the same thing, letting you swap these algorithms within a single context class.</li> </ul> </li> <li>Decorator lets you change the skin of an object, while Strategy lets you change the guts.</li> <li>Template Method is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. Strategy is based on composition: you can alter parts of the object\u2019s behavior by supplying it with different strategies that correspond to that behavior. Template Method works at the class level, so it\u2019s static. Strategy works on the object level, letting you switch behaviors at runtime.</li> <li>State can be considered as an extension of Strategy. Both patterns are based on composition: they change the behavior of the context by delegating some work to helper objects. Strategy makes these objects completely independent and unaware of each other. However, State doesn\u2019t restrict dependencies between concrete states, letting them alter the state of the context at will.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Strukturierung%20der%20Benutzungsschnittstelle/","title":"Strukturierung der Benutzungsschnittstelle","text":"<ul> <li>Zusammenfassen von Bedienelementen in Gruppen</li> <li>Zusammengeh\u00f6rige Informationen (Chunks) werden visuell besonders effizient verarbeitet (Chunking)</li> <li>Problem: Eine ideale L\u00f6sung gibt es nicht</li> </ul>","tags":["is"]},{"location":"hidden/Strukturierung%20der%20Benutzungsschnittstelle/#methoden","title":"Methoden","text":"<ul> <li>Strukturierung auf Detailebene (Untermen\u00fcs, Gliederungen)</li> <li>Zusammengeh\u00f6rige Elemente von einem Rahmen umgeben</li> <li>\u00dcbersichtliche Anordnung</li> <li>Benennung von zusammengeh\u00f6rigen Elementen</li> <li>Zusammenfassung in Werkzeugleisten</li> <li>Beachtung der Gestaltgesetze</li> <li>Zusammenarbeit mit Designer</li> </ul>","tags":["is"]},{"location":"hidden/T-Shaped%20Profile/","title":"T Shaped Profile","text":""},{"location":"hidden/T-Shaped%20Profile/#definition","title":"Definition","text":"<p>The components of a T-Shaped personality profile are:</p> <ul> <li>Specialist Deep skills in one area of expertise. Know every deep details of the area.</li> <li>Generalist: Broad knowledge across domains and soft skills.</li> <li>Interdiciplinary thinking: Are able to make connections between different areas or subdivisions of a company / teams. Do not only see what they are doing by themselfs but have a broad understanding of what brings the whole project forward.</li> </ul>"},{"location":"hidden/T-Shaped%20Profile/#benefits","title":"Benefits","text":"<ul> <li>T-Employees can be used everywhere because they can adapt quickly. They can take on almost any task.</li> <li>They always consider the problem as a whole not only in a small area by always thinking outside of the box</li> <li>They always have overview over the project as a whole. This helps to improve collaboration.</li> <li>They find solitions that are future prove</li> </ul>"},{"location":"hidden/Tell%20do%20not%20ask/","title":"Tell, don\u2019t ask","text":"","tags":["cleancode"]},{"location":"hidden/Tell%20do%20not%20ask/#tell-dont-ask","title":"Tell, don\u2019t ask","text":"<p>Warum? Hohe Koh\u00e4sion und lose Kopplung sind Tugenden. \u00d6ffentliche Zustandsdetails einer Klasse widersprechen dem.</p> <p>Etwas provokant formuliert, sollten Klassen keine Property Getter haben. Diese verf\u00fchren den Verwender einer Klasse dazu, anhand von Werten, die ein Objekt liefert, Entscheidungen zu treffen. Statt also dem Objekt mitzuteilen, was es tun soll, wird es befragt, um dann von au\u00dfen Betrachtungen \u00fcber den internen Zustand des Objektes anzustellen.</p> <p>Eines der Kernprinzipien der OOP lautet\u2003Information Hiding Principle\u2003(siehe dazu auch im\u2003gelben Grad). Keine Klasse soll Details nach au\u00dfen tragen, aus denen hervorgeht, wie sie intern implementiert ist. Ben\u00f6tigt eine Klasse f\u00fcr ihre Arbeit einen internen Zustand, wird dieser typischerweise in einem internen Feld abgelegt. Wenn nun dieser Wert auch nach au\u00dfen sichtbar ist, werden Verwender verleitet, diesen eigentlich internen Zustand des Objektes f\u00fcr eigene Entscheidungen heranzuziehen. Dadurch wird die Klasse schnell zur reinen Datenhaltung degradiert. Eine Implementierung, bei der einem Objekt mitgeteilt wird, was es tun soll, ist in jedem Fall vorzuziehen. Dadurch muss es den Verwender nicht mehr interessieren, wie die Klasse die Aufgabe intern bewerkstelligt.</p> <p>Als Ergebnis des\u2003Tell don\u2019t ask\u2003Prinzips entstehen Objekte mit Verhalten statt \u201edummer\u201c Datenhaltungsobjekte. Das Zusammenspiel der Objekte ist lose gekoppelt, da die Objekte keine Annahmen \u00fcber die kollaborierenden Objekte machen m\u00fcssen. Aber nicht nur das! Wenn Objekte ihren Zustand nicht ver\u00f6ffentlichen, behalten sie die Entscheidungshoheit. Die Koh\u00e4sion des entscheidenden Codes w\u00e4chst damit, weil er an einem Ort zusammengelegt wird.</p> <p>Ein typisches Codebeispiel ist im folgenden zu sehen. Statt hier zun\u00e4chst zu fragen, ob im Logging die Tracemeldungen aktiviert sind (Ask), sollte die Logging Bibliothek direkt angewiesen werden, die Tracemeldung auszugeben (Tell). Die Bibliothek soll dann intern selbst entscheiden, ob die Meldung geloggt wird oder nicht. <pre><code>if (_logger.Trace()) {\n\t_logger.TraceMsg(\u201e\u2026 eine Meldung\u2026 \u201e);\n}\n</code></pre></p>","tags":["cleancode"]},{"location":"hidden/Template%20Method/","title":"Template Method","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Template%20Method/#template-method","title":"Template Method","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Template%20Method/#intent","title":"Intent","text":"<p>Template Method\u2003is a behavioral design pattern that defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its\u2003structure.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Template%20Method/#problem","title":"Problem","text":"<p>Imagine that you\u2019re creating a data mining application that analyzes corporate documents. Users feed the app documents in various formats (PDF, DOC, CSV), and it tries to extract meaningful data from these docs in a uniform format.</p> <p>The first version of the app could work only with DOC files. In the following version, it was able to support CSV files. A month later, you \u201ctaught\u201d it to extract data from PDF files.</p> <p></p> <p>Data mining classes contained a lot of duplicate\u2003code.</p> <p>At some point, you noticed that all three classes have a lot of similar code. While the code for dealing with various data formats was entirely different in all classes, the code for data processing and analysis is almost identical. Wouldn\u2019t it be great to get rid of the code duplication, leaving the algorithm structure intact?</p> <p>There was another problem related to client code that used these classes. It had lots of conditionals that picked a proper course of action depending on the class of the processing object. If all three processing classes had a common interface or a base class, you\u2019d be able to eliminate the conditionals in client code and use polymorphism when calling methods on a processing object.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Template%20Method/#solution","title":"Solution","text":"<p>The Template Method pattern suggests that you break down an algorithm into a series of steps, turn these steps into methods, and put a series of calls to these methods inside a single\u2003template method.\u2003The steps may either be\u2003<code>abstract</code>, or have some default implementation. To use the algorithm, the client is supposed to provide its own subclass, implement all abstract steps, and override some of the optional ones if needed (but not the template method itself).</p> <p>Let\u2019s see how this will play out in our data mining app. We can create a base class for all three parsing algorithms. This class defines a template method consisting of a series of calls to various document-processing steps.</p> <p></p> <p>Template method breaks the algorithm into steps, allowing subclasses to override these steps but not the actual\u2003method.</p> <p>At first, we can declare all steps\u2003<code>abstract</code>, forcing the subclasses to provide their own implementations for these methods. In our case, subclasses already have all necessary implementations, so the only thing we might need to do is adjust signatures of the methods to match the methods of the superclass.</p> <p>Now, let\u2019s see what we can do to get rid of the duplicate code. It looks like the code for opening/closing files and extracting/parsing data is different for various data formats, so there\u2019s no point in touching those methods. However, implementation of other steps, such as analyzing the raw data and composing reports, is very similar, so it can be pulled up into the base class, where subclasses can share that code.</p> <p>As you can see, we\u2019ve got two types of steps:</p> <ul> <li>abstract steps\u2003must be implemented by every subclass</li> <li>optional steps\u2003already have some default implementation, but still can be overridden if needed</li> </ul> <p>There\u2019s another type of step, called\u2003hooks. A hook is an optional step with an empty body. A template method would work even if a hook isn\u2019t overridden. Usually, hooks are placed before and after crucial steps of algorithms, providing subclasses with additional extension points for an algorithm.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Template%20Method/#real-world-analogy","title":"Real-World Analogy","text":"<p>A typical architectural plan can be slightly altered to better fit the client\u2019s\u2003needs.</p> <p>The template method approach can be used in mass housing construction. The architectural plan for building a standard house may contain several extension points that would let a potential owner adjust some details of the resulting house.</p> <p>Each building step, such as laying the foundation, framing, building walls, installing plumbing and wiring for water and electricity,\u2003etc., can be slightly changed to make the resulting house a little bit different from others.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Template%20Method/#structure","title":"Structure","text":"<ol> <li> <p>The\u2003Abstract Class\u2003declares methods that act as steps of an algorithm, as well as the actual template method which calls these methods in a specific order. The steps may either be declared\u2003<code>abstract</code>\u2003or have some default implementation.</p> </li> <li> <p>Concrete Classes\u2003can override all of the steps, but not the template method itself.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Template%20Method/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Template Method\u2003pattern provides a \u201cskeleton\u201d for various branches of artificial intelligence in a simple strategy video game.</p> <p></p> <p>AI classes of a simple video\u2003game.</p> <p>All races in the game have almost the same types of units and buildings. Therefore you can reuse the same AI structure for various races, while being able to override some of the details. With this approach, you can override the orcs\u2019 AI to make it more aggressive, make humans more defense-oriented, and make monsters unable to build anything. Adding a new race to the game would require creating a new AI subclass and overriding the default methods declared in the base AI class.</p> <pre><code>// The abstract class defines a template method that contains a\n// skeleton of some algorithm composed of calls, usually to\n// abstract primitive operations. Concrete subclasses implement\n// these operations, but leave the template method itself\n// intact.\nclass GameAI is\n    // The template method defines the skeleton of an algorithm.\n    method turn() is\n        collectResources()\n        buildStructures()\n        buildUnits()\n        attack()\n\n    // Some of the steps may be implemented right in a base\n    // class.\n    method collectResources() is\n        foreach (s in this.builtStructures) do\n            s.collect()\n\n    // And some of them may be defined as abstract.\n    abstract method buildStructures()\n    abstract method buildUnits()\n\n    // A class can have several template methods.\n    method attack() is\n        enemy = closestEnemy()\n        if (enemy == null)\n            sendScouts(map.center)\n        else\n            sendWarriors(enemy.position)\n\n    abstract method sendScouts(position)\n    abstract method sendWarriors(position)\n\n// Concrete classes have to implement all abstract operations of\n// the base class but they must not override the template method\n// itself.\nclass OrcsAI extends GameAI is\n    method buildStructures() is\n        if (there are some resources) then\n            // Build farms, then barracks, then stronghold.\n\n    method buildUnits() is\n        if (there are plenty of resources) then\n            if (there are no scouts)\n                // Build peon, add it to scouts group.\n            else\n                // Build grunt, add it to warriors group.\n\n    // ...\n\n    method sendScouts(position) is\n        if (scouts.length &gt; 0) then\n            // Send scouts to position.\n\n    method sendWarriors(position) is\n        if (warriors.length &gt; 5) then\n            // Send warriors to position.\n\n// Subclasses can also override some operations with a default\n// implementation.\nclass MonstersAI extends GameAI is\n    method collectResources() is\n        // Monsters don't collect resources.\n\n    method buildStructures() is\n        // Monsters don't build structures.\n\n    method buildUnits() is\n        // Monsters don't build units.\n</code></pre>","tags":["cleancode_designpatterns"]},{"location":"hidden/Template%20Method/#applicability","title":"Applicability","text":"<ul> <li> <p>Use the Template Method pattern when you want to let clients extend only particular steps of an algorithm, but not the whole algorithm or its structure.     The Template Method lets you turn a monolithic algorithm into a series of individual steps which can be easily extended by subclasses while keeping intact the structure defined in a superclass.</p> </li> <li> <p>Use the pattern when you have several classes that contain almost identical algorithms with some minor differences. As a result, you might need to modify all classes when the algorithm changes.     When you turn such an algorithm into a template method, you can also pull up the steps with similar implementations into a superclass, eliminating code duplication. Code that varies between subclasses can remain in subclasses.</p> </li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Template%20Method/#how-to-implement","title":"How to Implement","text":"<ol> <li> <p>Analyze the target algorithm to see whether you can break it into steps. Consider which steps are common to all subclasses and which ones will always be unique.</p> </li> <li> <p>Create the abstract base class and declare the template method and a set of abstract methods representing the algorithm\u2019s steps. Outline the algorithm\u2019s structure in the template method by executing corresponding steps. Consider making the template method\u2003<code>final</code>\u2003to prevent subclasses from overriding it.</p> </li> <li> <p>It\u2019s okay if all the steps end up being abstract. However, some steps might benefit from having a default implementation. Subclasses don\u2019t have to implement those methods.</p> </li> <li> <p>Think of adding hooks between the crucial steps of the algorithm.</p> </li> <li> <p>For each variation of the algorithm, create a new concrete subclass. It\u2003must\u2003implement all of the abstract steps, but\u2003may\u2003also override some of the optional ones.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Template%20Method/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons You can let clients override only certain parts of a large algorithm, making them less affected by changes that happen to other parts of the algorithm. Some clients may be limited by the provided skeleton of an algorithm. You can pull the duplicate code into a superclass. You might violate the Liskov Substitution Principle by suppressing a default step implementation via a subclass. Template methods tend to be harder to maintain the more steps they have.","tags":["cleancode_designpatterns"]},{"location":"hidden/Template%20Method/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.</li> <li>Template Method is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. Strategy is based on composition: you can alter parts of the object\u2019s behavior by supplying it with different strategies that correspond to that behavior. Template Method works at the class level, so it\u2019s static. Strategy works on the object level, letting you switch behaviors at runtime.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Terminologie%20der%20Benutzer%20verwenden/","title":"Terminologie der Benutzer verwenden","text":"<ul> <li>Benutzungsschnittstellen sollen Sprache des Benutzers sprechen</li> <li>Fachsprache der Benutzer konsequent und korrekt verwenden</li> <li>Antizipation der Denkweise des Benutzers</li> <li>Klare, eindeutige Icons</li> </ul>","tags":["is"]},{"location":"hidden/Terminologie%20der%20Benutzer%20verwenden/#benutzungsschnittstellen-sollen-sprache-des-benutzers-sprechen","title":"Benutzungsschnittstellen sollen Sprache des Benutzers sprechen","text":"<ul> <li>Kein Fachjargon der Entwickler</li> <li>Kein ungebr\u00e4uchliches Vokabular</li> </ul>","tags":["is"]},{"location":"hidden/Terminologie%20der%20Benutzer%20verwenden/#fachsprache-der-benutzer-konsequent-und-korrekt-verwenden","title":"Fachsprache der Benutzer konsequent und korrekt verwenden","text":"<ul> <li>Benutzer denken nicht in Men\u00fcpunkten sondern Aufgaben</li> </ul>","tags":["is"]},{"location":"hidden/Terminologie%20der%20Benutzer%20verwenden/#klare-eindeutige-icons","title":"Klare, eindeutige Icons","text":"<ul> <li>Geeignete Metaphern nutzen</li> <li>Dom\u00e4nenspezifische Darstellungen nutzen</li> <li>Zielgruppengerichtete Formulierungen (z.B. Manager vs. Jugendliche)</li> </ul>","tags":["is"]},{"location":"hidden/Terminologie%20der%20Benutzer%20verwenden/#methoden","title":"Methoden","text":"<ul> <li>Auf wichtige Begriffe, Symbole und grafische Darstellungen achten (\u00c4hnlich der Identifizierung von geeigneten Metaphern)</li> <li>Terminologie auch in Diskussion mit Anwendern nutzen</li> <li>Grafische Prototypen und informelle Szenario-Beschreibungen</li> </ul>","tags":["is"]},{"location":"hidden/Terminologie%20der%20Benutzer%20verwenden/#probleme","title":"Probleme","text":"<ul> <li>Bei Diskussion mit Benutzern Abstand zu den formalen Notationen der Entwickler nehmen</li> <li>Nutzung von unpassenden oder missverst\u00e4ndlichen Begriffen</li> <li>Benutzer wird nicht \u201cernst genommen\u201d</li> </ul>","tags":["is"]},{"location":"hidden/Test%20First/","title":"Test First","text":"","tags":["cleancode"]},{"location":"hidden/Test%20First/#test-first","title":"Test First","text":"<p>Warum?</p> <p>Der Kunde ist K\u00f6nig und bestimmt die Form einer Dienstleistung. Service-Implementationen sind also nur passgenau, wenn sie durch einen Client getrieben werden.</p> <p>Wenn Komponentenorientierung fordert, die Kontrakte f\u00fcr Komponenten unabh\u00e4ngig von ihrer Implementation zu definieren, stellt sich die Frage, wie das denn geschehen soll. Durch Diskussion am runden Tisch? Das ist sicherlich ein Weg. Ein besserer ist jedoch, Kontrakte nicht erst lange an einer Tafel zu entwerfen, sondern sie sofort in Code zu gie\u00dfen. Komponentenkontrakte \u2013 oder allgemeiner: jede Codeschnittstelle \u2013 dient letztlich anderem Code als API. Es ist daher konsequent und effektiv, von diesem Code ausgehend Schnittstellen zu spezifizieren.</p> <p>Das ist das Anliegen von\u2003Test First. Test first basiert auf dem Gedanken, dass Funktionseinheiten (Methoden, Klassen, usw.) durch Client-Service-Verh\u00e4ltnisse charakterisiert sind. Diese Verh\u00e4ltnisse drehen sich um die Schnittstelle zwischen Client und Service. Und diese Schnittstelle sollte durch den Client bestimmt werden. Der Client ist als Kunde des Service K\u00f6nig. Ihm soll der Service dienen, nach ihm soll sich deshalb die Schnittstelle des Service richten.</p> <p>Die Definition der Schnittstellen der Codeeinheiten einer Software erfolgt aus diesem Grund von au\u00dfen nach innen. Au\u00dfen, an der Benutzeroberfl\u00e4che, sitzt der ultimative Client, der Anwender. Er definiert die visuelle/haptische Schnittstelle der UI-Codeeinheiten. Die wiederum sind die Clients von darunterliegenden Codeschichten. Die sind dann Clients von tieferliegenden Schichten usw. Die Leistungen und Schnittstellen der tiefsten Codeschichten kann somit nur bestimmt werden, wenn die der dar\u00fcberliegenden schon bestimmt sind usw.</p> <p>Das widerspricht dem h\u00e4ufigen Ansatz der bottom-up Definition von Codeeinheiten. Gern fangen Projekte an, eine Datenzugriffsschicht zu definieren und zu implementieren. Das ist verst\u00e4ndlich, weil solch fundamentale Funktionalit\u00e4t doch scheinbar die Voraussetzung f\u00fcr alles weitere ist. Aber dieses Vorgehen ist problematisch, wie viele gescheiterte Projekte zeigen:</p> <ul> <li>Wer von unten nach oben, von innen nach au\u00dfen spezifiziert und implementiert, bietet dem Kunden erst sehr sp\u00e4t einen Wert an. Das ist zumindest frustrierend, wenn nicht gar kontraproduktiv.</li> <li>Wer bottom-up in der Spezifikation vorgeht, der spezifiziert ohne genaue Anforderungen des ultimativen Clients, des Benutzers. Was er also spezifiziert l\u00e4uft Gefahr, am Ende zu allgemein und damit unhandlich zu sein \u2013 oder schlicht nicht gebraucht zu werden (eine Verletzung des YAGNI-Prinzips, s.o. und im\u2003roten Grad</li> <li>Wer von unten nach oben implementiert, l\u00e4uft Gefahr, nicht wirklich zu entkoppeln. Denn wenn tiefere Schichten n\u00f6tig sind, um dar\u00fcberliegende zu implementieren, dann werden wahrscheinlich keine wirklich isolierten Unit Tests mit Attrappen eingesetzt und auch keine Inversion of Control.</li> </ul> <p>Clean Code Developer vermeiden diese Probleme jedoch. Sie spezifizieren Schnittstelle nicht nur vor den Implementationen (Contract-first, s.o. Komponentenorientierung), sondern auch von au\u00dfen nach innen und ganz praktisch durch Codierung. Mit den Mitteln des automatisierten Testens ist es n\u00e4mlich sehr einfach, Schnittstellen in kleinen Schritten in Form von Tests zu definieren.</p> <p>Test first f\u00fcgt dadurch syntaktischen Kontrakten (z.B. Interfaces) eine semantische Seite hinzu. In Ermangelung anderer, formaler Methoden, um Semantik zu spezifizieren, sind Tests der einzige Weg, um Anforderungen zu formalisieren. Wer einem Entwickler eine Komponente zur Implementierung zuweisen will, der tut daher gut daran, nicht nur ihre \u201eOberfl\u00e4che\u201c (API) syntaktisch vorzugeben, sondern auch das gew\u00fcnschte Verhalten in Form von Tests.</p> <p>Das hat viele Vorteile:</p> <ul> <li>Die Form einer Schnittstelle ist unmittelbar Client-getrieben und damit maximal relevant. YAGNI hat keine Chance.</li> <li>Die Tests sind nicht nur Tests, sondern auch Spezifikationsdokumentation. Nutzer einer Schnittstelle und Implementierer k\u00f6nnen sie gleicherma\u00dfen studieren. Eine separate Dokumentation er\u00fcbrigt sich weitgehend. Das tut dem DRY-Prinzip gen\u00fcge.</li> <li>Die Spezifikationen sind nicht nur passive Texte, sondern ausf\u00fchrbarer Code. Wenn dann eine Implementation vorliegt, kann sie gegen diese Tests gepr\u00fcft werden. Spezifikation und Test sind damit nicht zeitraubend aufeinanderfolgende Phasen. Das erh\u00f6ht die Produktivit\u00e4t. Qualit\u00e4tssicherung ist so der Implementation schon vorgeschaltet.</li> </ul> <p>Siehe auch unter\u2003Tools.</p> <p>Weiter geht\u2019s mit dem\u2003wei\u00dfen Grad.</p>","tags":["cleancode"]},{"location":"hidden/Unit%20Test/","title":"Unit Test","text":"","tags":["cleancode"]},{"location":"hidden/Unit%20Test/#unit-test","title":"Unit Test","text":"","tags":["cleancode"]},{"location":"hidden/Unit%20of%20Work/","title":"Unit of Work","text":""},{"location":"hidden/Unit%20of%20Work/#unit-of-work","title":"Unit of Work","text":"<p>Maintains a list of objects affected by a business transaction and coordinates the writing out of changes and the resolution of concurrency problems.</p> <p>For a full description see P of EAA page 184</p> <p></p> <p>When you\u2019re pulling data in and out of a database, it\u2019s important to keep track of what you\u2019ve changed; otherwise, that data won\u2019t be written back into the database. Similarly you have to insert new objects you create and remove any objects you delete.</p> <p>You can change the database with each change to your object model, but this can lead to lots of very small database calls, which ends up being very slow. Furthermore it requires you to have a transaction open for the whole interaction, which is impractical if you have a business transaction that spans multiple requests. The situation is even worse if you need to keep track of the objects you\u2019ve read so you can avoid inconsistent reads.</p> <p>A Unit of Work keeps track of everything you do during a business transaction that can affect the database. When you\u2019re done, it figures out everything that needs to be done to alter the database as a result of your work.</p>"},{"location":"hidden/Unit%20of%20Work/#implementation-and-integration-in-net","title":"Implementation and Integration in .NET","text":"<p>During our implementation in a project we did several iterations on a unit of work using dependency injection. The following is the concept we finalised on:</p> <pre><code>public&amp;emsp;class&amp;emsp;UnitOfWork&amp;emsp;:&amp;emsp;IUnitOfWork  \n{  \n&amp;emsp;&amp;emsp;private&amp;emsp;readonly&amp;emsp;DataStoreContext&amp;emsp;dataStoreContext;\n&amp;emsp;&amp;emsp;private&amp;emsp;readonly&amp;emsp;CreateRepository&amp;emsp;createRepository;\n&amp;emsp;&amp;emsp;\n&amp;emsp;&amp;emsp;public&amp;emsp;UnitOfWork(\n\t&amp;emsp;&amp;emsp;DataStoreContext&amp;emsp;dataStoreContext,\n&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;CreateRepository&amp;emsp;createRepository)\n  {\n&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;this.dataStoreContext&amp;emsp;=&amp;emsp;dataStoreContext;\n&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;this.createRepository&amp;emsp;=&amp;emsp;createRepository;&amp;emsp;&amp;emsp;\n  }  \n&amp;emsp;&amp;emsp;\n&amp;emsp;&amp;emsp;public&amp;emsp;delegate&amp;emsp;IRepository&amp;emsp;CreateRepository(DataStoreContext&amp;emsp;context);&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;\n&amp;emsp;&amp;emsp;\n&amp;emsp;&amp;emsp;public&amp;emsp;IRepository&amp;emsp;Repository \n\t&amp;emsp;&amp;emsp;=&gt;&amp;emsp;this.createRepository(this.dataStoreContext);  \n&amp;emsp;&amp;emsp;public&amp;emsp;async&amp;emsp;Task&amp;emsp;Commit()&amp;emsp;=&gt;&amp;emsp;await&amp;emsp;this.dataStoreContext.SaveChangesAsync();}\n</code></pre> <p>And the registration in the DI.</p> <pre><code>services.AddTransient&lt;UnitOfWork.CreateRepository&gt;(  \n&amp;emsp;&amp;emsp;&amp;emsp;sp&amp;emsp;=&gt;&amp;emsp;context&amp;emsp;=&gt;&amp;emsp;new&amp;emsp;Repository(context,&amp;emsp;sp.GetRequiredService&lt;IObjectSerializer&gt;()));\n</code></pre> <p>This enables us to created the repositories in DI where all the dependencies are resolved, but they all can share the same context so the unit of work can do all actions in one transaction.</p> <p>We also create a factory for the Unit of Work, which creates the context.</p>"},{"location":"hidden/Unterst%C3%BCtzung%20beim%20Aufbau%20mentaler%20Modelle/","title":"Unterst\u00fctzung beim Aufbau mentaler Modelle","text":"<ul> <li>Wenn Menschen etwas lernen, versuchen sie es zu verstehen (Modellentwicklung)</li> <li>Ziele des Prinzips<ul> <li>Lernaufwand verringern</li> <li>Zahl der Fehler verringern</li> <li>langfristiges Behandeln von Bedienhandlungen</li> </ul> </li> <li>Schwer zu Lernen, was im Widerspruch zu Bekanntem steht</li> <li>Bekannte Metaphern verwenden</li> </ul>","tags":["is"]},{"location":"hidden/Unterst%C3%BCtzung%20beim%20Aufbau%20mentaler%20Modelle/#methoden","title":"Methoden","text":"<ul> <li>Orientierung an Terminologien und Abl\u00e4ufen in bekannten Anwendungen (vgl. n\u00e4chstes Prinzip)</li> <li>Konsistenz im Layout, in der Terminologie, in der Bildung von Abk\u00fcrzungen, in der Gestaltung von Piktogrammen, Icons, Darstellungen</li> <li>Tests zur Analyse, welche Assoziationen der Benutzer bei der Systemnutzung entwickelt</li> </ul>","tags":["is"]},{"location":"hidden/Unterst%C3%BCtzung%20beim%20Aufbau%20mentaler%20Modelle/#probleme","title":"Probleme","text":"<ul> <li>Modellgenerierung nur schwer absch\u00e4tzbar</li> <li>Auswertung der Tests (s.o.) anspruchsvoll und aufwendig. Muss intensiv diskutiert werden, um falsche Konzepte zu erkennen</li> </ul>","tags":["is"]},{"location":"hidden/Version%20Control%20System/","title":"Version Control System","text":"","tags":["cleancode"]},{"location":"hidden/Version%20Control%20System/#version-control-system","title":"Version Control System","text":"<p>Warum? Symptome behandeln bringt vielleicht schnell eine Linderung \u2013 langfristig kostet es aber mehr Aufwand. Wer stattdessen unter die Oberfl\u00e4che von Problemen schaut, arbeitet am Ende effizienter.</p> <p>Unabdingbare Voraussetzung f\u00fcr jeden Clean Code Developer ist es, seinen Code unter den Schutz eines Versionskontrollsystems zu stellen. Ob das Mercurial, Git, Subversion, VSS, TFS oder Vault ist, spielt dabei keine Rolle. Wir meinen nur, dass heute keine Arbeit an Code mehr durchgef\u00fchrt werden sollte, ohne ihn in einem Versionskontrollsystem zu pflegen. Der Grund daf\u00fcr ist ganz simpel: Ein Versionskontrollsystem befreit von Angst. Und Angstfreiheit ist n\u00f6tig, um mutig die Prinzipien und Praktiken des CCD-Wertesystems umzusetzen.</p> <p>Ein Versionskontrollsystem nimmt die Angst, etwas falsch und damit kaputt zu machen. Wenn Code in ihm gehalten wird, kann jeder CCD den Code nach Belieben ver\u00e4ndern, ohne bef\u00fcrchten zu m\u00fcssen, einen erreichten Stand zu zerst\u00f6ren. Nichts geht verloren. Das Versionskontrollsystem ist wie eine Zeitmaschine f\u00fcr Code.</p> <p>Damit ist ein Versionskontrollsystem die allerbeste Grundlage f\u00fcr alles Lernen. Denn Lernen bedeutet Fehler machen. Mit einem Versionskontrollsystem als Sicherheitsnetz k\u00f6nnen wir uns alle Fehler erlauben. Deshalb: Erste Voraussetzung f\u00fcr den Einstieg ins Clean Code Development ist der st\u00e4ndige Gebrauch eines Versionskontrollsystems.</p> <p>Wo das im Projekt nicht m\u00f6glich ist, sehen wir das Fundament f\u00fcr Clean Code Development abwesend. Wir w\u00fcrden auch nicht verstehen, warum der Einsatz eines Versionskontrollwerkzeuges nicht m\u00f6glich sein sollte. Kosten m\u00fcssen daf\u00fcr nicht anfallen und der Einarbeitungsaufwand in die einfachsten Funktionen ist minimal. CCD schreibt ja keine bestimmte Nutzung eines Versionskontrollsystems vor, sondern nur, dass eines benutzt werden muss.</p>","tags":["cleancode"]},{"location":"hidden/Visitor/","title":"Visitor","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Visitor/#visitor","title":"Visitor","text":"","tags":["cleancode_designpatterns"]},{"location":"hidden/Visitor/#intent","title":"Intent","text":"<p>Visitor\u2003is a behavioral design pattern that lets you separate algorithms from the objects on which they\u2003operate.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Visitor/#problem","title":"Problem","text":"<p>Imagine that your team develops an app which works with geographic information structured as one colossal graph. Each node of the graph may represent a complex entity such as a city, but also more granular things like industries, sightseeing areas,\u2003etc. The nodes are connected with others if there\u2019s a road between the real objects that they represent. Under the hood, each node type is represented by its own class, while each specific node is an object.</p> <p></p> <p>Exporting the graph into\u2003XML.</p> <p>At some point, you got a task to implement exporting the graph into XML format. At first, the job seemed pretty straightforward. You planned to add an export method to each node class and then leverage recursion to go over each node of the graph, executing the export method. The solution was simple and elegant: thanks to polymorphism, you weren\u2019t coupling the code which called the export method to concrete classes of nodes.</p> <p>Unfortunately, the system architect refused to allow you to alter existing node classes. He said that the code was already in production and he didn\u2019t want to risk breaking it because of a potential bug in your changes.</p> <p></p> <p>The XML export method had to be added into all node classes, which bore the risk of breaking the whole application if any bugs slipped through along with the\u2003change.</p> <p>Besides, he questioned whether it makes sense to have the XML export code within the node classes. The primary job of these classes was to work with geodata. The XML export behavior would look alien there.</p> <p>There was another reason for the refusal. It was highly likely that after this feature was implemented, someone from the marketing department would ask you to provide the ability to export into a different format, or request some other weird stuff. This would force you to change those precious and fragile classes again.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Visitor/#solution","title":"Solution","text":"<p>The Visitor pattern suggests that you place the new behavior into a separate class called\u2003visitor, instead of trying to integrate it into existing classes. The original object that had to perform the behavior is now passed to one of the visitor\u2019s methods as an argument, providing the method access to all necessary data contained within the object.</p> <p>Now, what if that behavior can be executed over objects of different classes? For example, in our case with XML export, the actual implementation will probably be a little bit different across various node classes. Thus, the visitor class may define not one, but a set of methods, each of which could take arguments of different types, like this:</p> <pre><code>class ExportVisitor implements Visitor is\n    method doForCity(City c) { ... }\n    method doForIndustry(Industry f) { ... }\n    method doForSightSeeing(SightSeeing ss) { ... }\n    // ...\n</code></pre> <p>But how exactly would we call these methods, especially when dealing with the whole graph? These methods have different signatures, so we can\u2019t use polymorphism. To pick a proper visitor method that\u2019s able to process a given object, we\u2019d need to check its class. Doesn\u2019t this sound like a nightmare?</p> <pre><code>foreach (Node node in graph)\n    if (node instanceof City)\n        exportVisitor.doForCity((City) node)\n    if (node instanceof Industry)\n        exportVisitor.doForIndustry((Industry) node)\n    // ...\n}\n</code></pre> <p>You might ask, why don\u2019t we use method overloading? That\u2019s when you give all methods the same name, even if they support different sets of parameters. Unfortunately, even assuming that our programming language supports it at all (as Java and C# do), it won\u2019t help us. Since the exact class of a node object is unknown in advance, the overloading mechanism won\u2019t be able to determine the correct method to execute. It\u2019ll default to the method that takes an object of the base\u2003<code>Node</code>\u2003class.</p> <p>However, the Visitor pattern addresses this problem. It uses a technique called\u2003Double Dispatch, which helps to execute the proper method on an object without cumbersome conditionals. Instead of letting the client select a proper version of the method to call, how about we delegate this choice to objects we\u2019re passing to the visitor as an argument? Since the objects know their own classes, they\u2019ll be able to pick a proper method on the visitor less awkwardly. They \u201caccept\u201d a visitor and tell it what visiting method should be executed.</p> <pre><code>// Client code\nforeach (Node node in graph)\n    node.accept(exportVisitor)\n\n// City\nclass City is\n    method accept(Visitor v) is\n        v.doForCity(this)\n    // ...\n\n// Industry\nclass Industry is\n    method accept(Visitor v) is\n        v.doForIndustry(this)\n    // ...\n</code></pre> <p>I confess. We had to change the node classes after all. But at least the change is trivial and it lets us add further behaviors without altering the code once again.</p> <p>Now, if we extract a common interface for all visitors, all existing nodes can work with any visitor you introduce into the app. If you find yourself introducing a new behavior related to nodes, all you have to do is implement a new visitor class.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Visitor/#real-world-analogy","title":"Real-World Analogy","text":"<p>A good insurance agent is always ready to offer different policies to various types of\u2003organizations.</p> <p>Imagine a seasoned insurance agent who\u2019s eager to get new customers. He can visit every building in a neighborhood, trying to sell insurance to everyone he meets. Depending on the type of organization that occupies the building, he can offer specialized insurance policies:</p> <ul> <li>If it\u2019s a residential building, he sells medical insurance.</li> <li>If it\u2019s a bank, he sells theft insurance.</li> <li>If it\u2019s a coffee shop, he sells fire and flood insurance.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Visitor/#structure","title":"Structure","text":"<ol> <li> <p>The\u2003Visitor\u2003interface declares a set of visiting methods that can take concrete elements of an object structure as arguments. These methods may have the same names if the program is written in a language that supports overloading, but the type of their parameters must be different.</p> </li> <li> <p>Each\u2003Concrete Visitor\u2003implements several versions of the same behaviors, tailored for different concrete element classes.</p> </li> <li> <p>The\u2003Element\u2003interface declares a method for \u201caccepting\u201d visitors. This method should have one parameter declared with the type of the visitor interface.</p> </li> <li> <p>Each\u2003Concrete Element\u2003must implement the acceptance method. The purpose of this method is to redirect the call to the proper visitor\u2019s method corresponding to the current element class. Be aware that even if a base element class implements this method, all subclasses must still override this method in their own classes and call the appropriate method on the visitor object.</p> </li> <li> <p>The\u2003Client\u2003usually represents a collection or some other complex object (for example, a\u2003Composite\u2003tree). Usually, clients aren\u2019t aware of all the concrete element classes because they work with objects from that collection via some abstract interface.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Visitor/#pseudocode","title":"Pseudocode","text":"<p>In this example, the\u2003Visitor\u2003pattern adds XML export support to the class hierarchy of geometric shapes.</p> <p></p> <p>Exporting various types of objects into XML format via a visitor\u2003object.</p> <pre><code>// The element interface declares an `accept` method that takes\n// the base visitor interface as an argument.\ninterface Shape is\n    method move(x, y)\n    method draw()\n    method accept(v: Visitor)\n\n// Each concrete element class must implement the `accept`\n// method in such a way that it calls the visitor's method that\n// corresponds to the element's class.\nclass Dot implements Shape is\n    // ...\n\n    // Note that we're calling `visitDot`, which matches the\n    // current class name. This way we let the visitor know the\n    // class of the element it works with.\n    method accept(v: Visitor) is\n        v.visitDot(this)\n\nclass Circle implements Shape is\n    // ...\n    method accept(v: Visitor) is\n        v.visitCircle(this)\n\nclass Rectangle implements Shape is\n    // ...\n    method accept(v: Visitor) is\n        v.visitRectangle(this)\n\nclass CompoundShape implements Shape is\n    // ...\n    method accept(v: Visitor) is\n        v.visitCompoundShape(this)\n\n// The Visitor interface declares a set of visiting methods that\n// correspond to element classes. The signature of a visiting\n// method lets the visitor identify the exact class of the\n// element that it's dealing with.\ninterface Visitor is\n    method visitDot(d: Dot)\n    method visitCircle(c: Circle)\n    method visitRectangle(r: Rectangle)\n    method visitCompoundShape(cs: CompoundShape)\n\n// Concrete visitors implement several versions of the same\n// algorithm, which can work with all concrete element classes.\n//\n// You can experience the biggest benefit of the Visitor pattern\n// when using it with a complex object structure such as a\n// Composite tree. In this case, it might be helpful to store\n// some intermediate state of the algorithm while executing the\n// visitor's methods over various objects of the structure.\nclass XMLExportVisitor implements Visitor is\n    method visitDot(d: Dot) is\n        // Export the dot's ID and center coordinates.\n\n    method visitCircle(c: Circle) is\n        // Export the circle's ID, center coordinates and\n        // radius.\n\n    method visitRectangle(r: Rectangle) is\n        // Export the rectangle's ID, left-top coordinates,\n        // width and height.\n\n    method visitCompoundShape(cs: CompoundShape) is\n        // Export the shape's ID as well as the list of its\n        // children's IDs.\n\n// The client code can run visitor operations over any set of\n// elements without figuring out their concrete classes. The\n// accept operation directs a call to the appropriate operation\n// in the visitor object.\nclass Application is\n    field allShapes: array of Shapes\n\n    method export() is\n        exportVisitor = new XMLExportVisitor()\n\n        foreach (shape in allShapes) do\n            shape.accept(exportVisitor)\n</code></pre> <p>If you wonder why we need the\u2003<code>accept</code>\u2003method in this example, my article\u2003Visitor and Double Dispatch\u2003addresses this question in detail.</p>","tags":["cleancode_designpatterns"]},{"location":"hidden/Visitor/#applicability","title":"Applicability","text":"<ul> <li>Use the Visitor when you need to perform an operation on all elements of a complex object structure (for example, an object tree).     The Visitor pattern lets you execute an operation over a set of objects with different classes by having a visitor object implement several variants of the same operation, which correspond to all target classes.</li> <li>Use the Visitor to clean up the business logic of auxiliary behaviors.     The pattern lets you make the primary classes of your app more focused on their main jobs by extracting all other behaviors into a set of visitor classes.</li> <li>Use the pattern when a behavior makes sense only in some classes of a class hierarchy, but not in others.     You can extract this behavior into a separate visitor class and implement only those visiting methods that accept objects of relevant classes, leaving the rest empty.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/Visitor/#how-to-implement","title":"How to Implement","text":"<ol> <li> <p>Declare the visitor interface with a set of \u201cvisiting\u201d methods, one per each concrete element class that exists in the program.</p> </li> <li> <p>Declare the element interface. If you\u2019re working with an existing element class hierarchy, add the abstract \u201cacceptance\u201d method to the base class of the hierarchy. This method should accept a visitor object as an argument.</p> </li> <li> <p>Implement the acceptance methods in all concrete element classes. These methods must simply redirect the call to a visiting method on the incoming visitor object which matches the class of the current element.</p> </li> <li> <p>The element classes should only work with visitors via the visitor interface. Visitors, however, must be aware of all concrete element classes, referenced as parameter types of the visiting methods.</p> </li> <li> <p>For each behavior that can\u2019t be implemented inside the element hierarchy, create a new concrete visitor class and implement all of the visiting methods.</p> <p>You might encounter a situation where the visitor will need access to some private members of the element class. In this case, you can either make these fields or methods public, violating the element\u2019s encapsulation, or nest the visitor class in the element class. The latter is only possible if you\u2019re lucky to work with a programming language that supports nested classes.</p> </li> <li> <p>The client must create visitor objects and pass them into elements via \u201cacceptance\u201d methods.</p> </li> </ol>","tags":["cleancode_designpatterns"]},{"location":"hidden/Visitor/#pro-and-cons","title":"Pro and  Cons","text":"Pros Cons Open Closed Principle. You can introduce a new behavior that can work with objects of different classes without changing these classes. \u2003You need to update all visitors each time a class gets added to or removed from the element hierarchy. Single Responsibility Principle. You can move multiple versions of the same behavior into the same class. Visitors might lack the necessary access to the private fields and methods of the elements that they\u2019re supposed to work with. A visitor object can accumulate some useful information while working with various objects. This might be handy when you want to traverse some complex object structure, such as an object tree, and apply the visitor to each object of this structure.","tags":["cleancode_designpatterns"]},{"location":"hidden/Visitor/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>You can treat Visitor as a powerful version of the Command pattern. Its objects can execute operations over various objects of different classes.</li> <li>You can use Visitor to execute an operation over an entire object tree tree.</li> <li>You can use Visitor along with Iterator to traverse a complex data structure and execute some operation over its elements, even if they all have different classes.</li> </ul>","tags":["cleancode_designpatterns"]},{"location":"hidden/WTF%20Book/","title":"WTF Book","text":"<p>Source</p> <p>https://www.simplermachines.com/why-you-need-a-wtf-notebook/</p> <p>In the mentioned article a nice practice for handling issues in new projects is explained. </p>"},{"location":"hidden/WTF%20Book/#what-is-a-wtf-book","title":"What is a WTF Book","text":"<p>A WTF Book can be a new page in a bullet journal, in which you write down all the annoying things where you think \u201cWTF is this. Why is it done like this?\u201d. You do not communicate the issues with the team you are new in. </p>"},{"location":"hidden/WTF%20Book/#whats-the-use-of-a-wtf-book","title":"Whats the use of a WTF Book","text":"<p>Over the timespan of a month you might figure out that some of these issues have actually valid reasons why they are like they are, or they might already be known and being addressed somehow. If you would have mentioned all of the issues up front, you might establish an image of \u201cthats the person who always complains\u201d. If you wait what the real unknown issues are you can use this as an advantage and establish an image that you are a person who can help if problems arise.</p>"},{"location":"hidden/Wei%C3%9Fer%20Grad/","title":"Wei\u00dfer Grad","text":"","tags":["cleancode"]},{"location":"hidden/Wei%C3%9Fer%20Grad/#weier-grad","title":"Wei\u00dfer Grad","text":"<p>Vereinigung aller Prinzipien und Praktiken</p>","tags":["cleancode"]},{"location":"hidden/YAGNI/","title":"You Ain\u2019t Gonna Need It","text":"<p>$# You Ain\u2019t Gonna Need It </p> <p>Warum? Dinge die niemand braucht, haben keinen Wert. Verschwende an sie also keine Zeit.</p> <p>Das YAGNI-Prinzip (You Ain\u00b4t Gonna Need It) ist eines der einfachsten in der Softwareentwicklung \u2013 und doch wohl das nach dem DRY-Prinzip am h\u00e4ufigsten verletzte Prinzip. Deshalb steht YAGNI nicht nur am Anfang des\u2003roten Grades, sondern auch hier gegen Ende des Weges durch das\u2003Wertesystem.</p> <p>Geschuldet ist das YAGNI-Prinzip dem in der Softwareentwicklung besonderen Verh\u00e4ltnis von Anforderungsgenauigkeit und Produktmaterialit\u00e4t. Anforderungen sind notorisch ungenau oder wechselnd und das Produkt, in dem sie umgesetzt werden sollen, immateriell. Im Vergleich zum Maschinen- oder Geb\u00e4udebau ist das Material also unendlich flexibel und kann sich prinzipiell mit vergleichsweise wenig Aufwand an quasi jede Anforderung anpassen lassen. Hohe Volatili\u00e4t bzw. Ungenauigkeit trifft also auf hohe Flexibilit\u00e4t. Das scheint zun\u00e4chst einmal ideal.</p> <p>Die Praxis zeigt jedoch, dass gerade in diesem Verh\u00e4ltnis der Keim des Misserfolges vieler Projekte liegt. Kurzfristig betrachtet, versuchen die Projekte mit dem Naheliegenden auch das Richtige zu tun:</p> <ul> <li>Ungenaue Anforderungen werden oft kompensiert durch Produkte, die versuchen, die Ungenauigkeit zu kompensieren. Die Immaterialit\u00e4t von Software wird dazu genutzt, so breit und flexibel zu implementieren, dass auch noch unbekannte oder schwammige Anforderungen quasi schon im vorauseilenden Gehorsam erf\u00fcllt werden.</li> <li>St\u00e4ndig wechselnde Anforderungen werden im Produkt m\u00f6glichst schnell nachgef\u00fchrt, weil das dank seiner Immaterialit\u00e4t m\u00f6glich ist.</li> </ul> <p>Langfristig ist solches Verhalten allerdings kontraproduktiv:</p> <ul> <li>Der vorauseilende Gehorsam f\u00fchrt zu Breite und Flexibilit\u00e4t, die nicht wirklich gebraucht werden. Er realisiert Features, die keine Anwendung finden.</li> <li>Schnelle Umbauten an Software aufgrund wechselnder Anforderungen f\u00fchren zu Qualit\u00e4tserosionen im Code. Software ist zwar immateriell und flexibel \u2013 aber nicht jede Softwarestruktur ist evolvierbar oder auch nur verst\u00e4ndlich.</li> </ul> <p>Unklare und wechselnde Anforderungssituationen vor dem Hintergrund der hohen grunds\u00e4tzlichen Flexibilit\u00e4t von Software f\u00fchren schnell zu unn\u00f6tigen Aufw\u00e4nden und spr\u00f6dem Code. Eine gro\u00dfe Anzahl von Projekten, die ihre Budgetgrenzen gesprengt haben, und eine noch gr\u00f6\u00dfere Zahl von Projekten, die schon nach wenigen Jahren unwartbar geworden sind, sind daf\u00fcr beredtes Zeugnis.</p> <p>CCD als professionelle Softwareentwickler sehen es als ihre Pflicht, sich solcher Entwicklung jeden Tag entgegen zu stemmen. Angesichts der nicht zu leugnenden Natur von Software \u2013 sie ist und bleibt immateriell -, liegt der Ansatz daf\u00fcr beim Umgang mit den Anforderungen. Das ist der Ursprung des YAGNI-Prinzips.</p> <p>Das YAGNI-Prinzip ist wie ein scharfes Messer: Wer sie anwendet, schneidet ein Problem in kleine W\u00fcrfel des unmittelbar N\u00f6tigen. Nach dem YAGNI-Prinzip wird nur das unzweifelhaft und unmittelbar Nutzbringende implementiert. Alles andere\u2026 nun, das kommt sp\u00e4ter. Insofern geht YAGNI Hand in Hand mit der Regel \u201eEntscheide so sp\u00e4t wie m\u00f6glich\u201c des\u2003Lean Software Development.</p> <p>Das YAGNI-Prinzip ist relevant auf allen Ebenen der Softwareentwicklung und in allen Phasen. Wann immer Sie sich Fragen \u201eSollte ich diesen Aufwand wirklich treiben?\u201c oder \u201eBrauchen wir das wirklich?\u201c \u2013 und sei es auch nur ganz versch\u00e4mt und leise im Hinterkopf -, dann ist das ein Anwendungsfall f\u00fcr das YAGNI-Prinzip. Es besagt: Wenn im Zweifel, entscheide dich gegen den Aufwand.</p> <p>Das klingt leicht, ist aber schwer. Daher auch die h\u00e4ufigen Zuwiderhandlungen. Es gibt viele Kr\u00e4fte, die der Entscheidung gegen einen Aufwand widersprechen. \u201eAch, das ist doch gar nicht soviel Aufwand\u201c oder \u201eWenn wir jetzt nicht vorausschauen, dann k\u00f6nnen wir in Zukunft nicht mehr anders\u201c sind nur zwei naheliegende Begr\u00fcndungen f\u00fcr Aufwand, auch wenn Zweifel an seinem Nutzen bestehen. Das betrifft architektonische Entscheidungen (z.B. Soll schon mit einer verteilten Architektur begonnen werden, auch wenn die heutige Last sie noch nicht br\u00e4uchte?) wie lokale Entscheidungen (z.B. Soll der Algorithmus schon jetzt optimiert werden, auch wenn er im Augenblick noch keine Performanceprobleme macht?).</p> <p>Der Kunde bezahlt nur f\u00fcr unmittelbaren Nutzen. Was er heute nicht klar spezifizieren kann, nutzt ihm nicht. Es in der Implementation voraussehen zu wollen, investiert also Aufwand ohne Nutzen zu generieren. Wenn der Kunde sp\u00e4ter einmal genauer wei\u00df, was er will, dann \u2013 und nicht fr\u00fcher! \u2013 ist es Zeit, seinem Willen nachzukommen. Wo immer aber ein Projekt versucht, diesen Willen vorwegzunehmen riskiert es, von der morgigen Willensrealit\u00e4t des Kunden widerlegt zu werden. Ein Feature \u2013 funktional oder nicht-funktional -, das heute ohne klare Anforderung implementiert wird, interessiert den Kunden morgen vielleicht schon nicht mehr. Oder es ist ihm nicht mehr so wichtig wie ein anderes Feature.</p> <p>Das bedeutet f\u00fcr die Softwareentwicklung:</p> <ul> <li>Ausschlie\u00dflich klare Anforderungen implementieren.</li> <li>Der Kunde priorisiert seine klaren Anforderungen.</li> <li>Die klaren Anforderungen in der Reihenfolge ihrer Priorisierung umsetzen.</li> <li>Entwicklungsprozess und Codestruktur im Gro\u00dfen und Kleinen so aufsetzen, dass keine Angst aufkommt, sich \u00e4ndernde und neue Anforderungen zu realisieren.</li> </ul> <p>CCD als professionelle Entwickler kommunizieren diese Vorgehensweise unmissverst\u00e4ndlich dem Kunden gegen\u00fcber. Dadurch werden sie:</p> <ul> <li>servicewillig, denn sie m\u00fcssen dem Kunden keine klare Anforderung abschlagen</li> <li>verantwortungsbewusst, weil sie das Budget nur f\u00fcr klar formulierten Nutzen einsetzen</li> <li>besch\u00fctzend dem Code gegen\u00fcber, weil sie ihn gegen \u00dcberladung mit letztlich Unn\u00f6tigem bewahren</li> </ul> <p>YAGNI ist deshalb nicht nur ein Prinzip, das jeder Entwickler befolgen soll, sondern auch ein Prinzip f\u00fcr Projekte und Teams, also auf Organisationsebene. YAGNI ist immer in Anschlag zu bringen, genauso wie DRY. Wenn im Zweifel, dann verschiebe die Entscheidung falls m\u00f6glich. Ansonsten entscheide dich gegen den Aufwand. Das entspannt und entschlackt und f\u00fchrt schneller zum Erfolg.</p>","tags":["cleancode"]},{"location":"hidden/gRPC/","title":"gRPC","text":""},{"location":"hidden/gRPC/#grpc","title":"gRPC","text":"<p>Source</p> <p>https://grpc.io/docs/</p>"},{"location":"hidden/gRPC/#overview","title":"Overview","text":"<p>In gRPC, a client application can directly call a method on a server application on a different machine as if it were a local object, making it easier for you to create distributed applications and services. As in many RPC systems, gRPC is based around the idea of defining a service, specifying the methods that can be called remotely with their parameters and return types. On the server side, the server implements this interface and runs a gRPC server to handle client calls. On the client side, the client has a stub (referred to as just a client in some languages) that provides the same methods as the server.</p> <p></p>"},{"location":"hidden/gRPC/#service-definitions","title":"Service definitions","text":"<p>Like many RPC systems, gRPC is based around the idea of defining a service, specifying the methods that can be called remotely with their parameters and return types. By default, gRPC uses\u2003Protobuf\u2003as the Interface Definition Language (IDL) for describing both the service interface and the structure of the payload messages. It is possible to use other alternatives if desired</p> <pre><code>service HelloService {\n  rpc SayHello (HelloRequest) returns (HelloResponse);\n}\n\nmessage HelloRequest {\n  string greeting = 1;\n}\n\nmessage HelloResponse {\n  string reply = 1;\n}\n</code></pre> <p>gRPC lets you define four kinds of service method:</p> <ul> <li> <p>Unary RPCs where the client sends a single request to the server and gets a single response back, just like a normal function call.  <pre><code>rpc SayHello(HelloRequest) returns (HelloResponse);\n</code></pre></p> </li> <li> <p>Server streaming RPCs where the client sends a request to the server and gets a stream to read a sequence of messages back. The client reads from the returned stream until there are no more messages. gRPC guarantees message ordering within an individual RPC call.</p> </li> </ul> <pre><code>rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);\n</code></pre> <ul> <li>Client streaming RPCs where the client writes a sequence of messages and sends them to the server, again using a provided stream. Once the client has finished writing the messages, it waits for the server to read them and return its response. Again gRPC guarantees message ordering within an individual RPC call.</li> </ul> <pre><code>rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);\n</code></pre> <ul> <li>Bidirectional streaming RPCs where both sides send a sequence of messages using a read-write stream. The two streams operate independently, so clients and servers can read and write in whatever order they like: for example, the server could wait to receive all the client messages before writing its responses, or it could alternately read a message then write a message, or some other combination of reads and writes. The order of messages in each stream is preserved.</li> </ul> <pre><code>rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);\n</code></pre>"},{"location":"hidden/gRPC/#lifecycle","title":"Lifecycle","text":"<p>In this section, you\u2019ll take a closer look at what happens when a gRPC client calls a gRPC server method. For complete implementation details, see the language-specific pages.</p>"},{"location":"hidden/gRPC/#unary-rpc","title":"Unary RPC","text":"<p>First consider the simplest type of RPC where the client sends a single request and gets back a single response.</p> <ol> <li>Once the client calls a stub method, the server is notified that the RPC has been invoked with the client\u2019s\u2003metadata\u2003for this call, the method name, and the specified\u2003deadline\u2003if applicable.</li> <li>The server can then either send back its own initial metadata (which must be sent before any response) straight away, or wait for the client\u2019s request message. Which happens first, is application-specific.</li> <li>Once the server has the client\u2019s request message, it does whatever work is necessary to create and populate a response. The response is then returned (if successful) to the client together with status details (status code and optional status message) and optional trailing metadata.</li> <li>If the response status is OK, then the client gets the response, which completes the call on the client side.</li> </ol>"},{"location":"hidden/gRPC/#server-streaming-rpc","title":"Server streaming RPC","text":"<p>A server-streaming RPC is similar to a unary RPC, except that the server returns a stream of messages in response to a client\u2019s request. After sending all its messages, the server\u2019s status details (status code and optional status message) and optional trailing metadata are sent to the client. This completes processing on the server side. The client completes once it has all the server\u2019s messages.</p>"},{"location":"hidden/gRPC/#client-streaming-rpc","title":"Client streaming RPC","text":"<p>A client-streaming RPC is similar to a unary RPC, except that the client sends a stream of messages to the server instead of a single message. The server responds with a single message (along with its status details and optional trailing metadata), typically but not necessarily after it has received all the client\u2019s messages.</p>"},{"location":"hidden/gRPC/#bidirectional-streaming-rpc","title":"Bidirectional streaming RPC","text":"<p>In a bidirectional streaming RPC, the call is initiated by the client invoking the method and the server receiving the client metadata, method name, and deadline. The server can choose to send back its initial metadata or wait for the client to start streaming messages.</p> <p>Client- and server-side stream processing is application specific. Since the two streams are independent, the client and server can read and write messages in any order. For example, a server can wait until it has received all of a client\u2019s messages before writing its messages, or the server and client can play \u201cping-pong\u201d \u2013 the server gets a request, then sends back a response, then the client sends another request based on the response, and so on.</p>"},{"location":"hidden/gRPC/#deadlinestimeouts","title":"Deadlines/Timeouts","text":"<p>gRPC allows clients to specify how long they are willing to wait for an RPC to complete before the RPC is terminated with a\u2003<code>DEADLINE_EXCEEDED</code>\u2003error. On the server side, the server can query to see if a particular RPC has timed out, or how much time is left to complete the RPC.</p> <p>Specifying a deadline or timeout is language specific: some language APIs work in terms of timeouts (durations of time), and some language APIs work in terms of a deadline (a fixed point in time) and may or may not have a default deadline.</p>"},{"location":"hidden/gRPC/#rpc-termination","title":"RPC termination","text":"<p>In gRPC, both the client and server make independent and local determinations of the success of the call, and their conclusions may not match. This means that, for example, you could have an RPC that finishes successfully on the server side (\u201cI have sent all my responses!\u201d) but fails on the client side (\u201cThe responses arrived after my deadline!\u201d). It\u2019s also possible for a server to decide to complete before a client has sent all its requests.</p>"},{"location":"hidden/gRPC/#cancelling-an-rpc","title":"Cancelling an RPC","text":"<p>Either the client or the server can cancel an RPC at any time. A cancellation terminates the RPC immediately so that no further work is done.</p>"},{"location":"hidden/gRPC/#warning","title":"Warning","text":"<p>Changes made before a cancellation are not rolled back.</p>"},{"location":"hidden/gRPC/#metadata","title":"Metadata","text":"<p>Metadata is information about a particular RPC call (such as\u2003authentication details) in the form of a list of key-value pairs, where the keys are strings and the values are typically strings, but can be binary data.</p> <p>Keys are case insensitive and consist of ASCII letters, digits, and special characters\u2003<code>-</code>,\u2003<code>_</code>,\u2003<code>.</code>\u2003and must not start with\u2003<code>grpc-</code>\u2003(which is reserved for gRPC itself). Binary-valued keys end in\u2003<code>-bin</code>\u2003while ASCII-valued keys do not.</p> <p>User-defined metadata is not used by gRPC, which allows the client to provide information associated with the call to the server and vice versa.</p> <p>Access to metadata is language dependent.</p>"},{"location":"hidden/gRPC/#channels","title":"Channels","text":"<p>A gRPC channel provides a connection to a gRPC server on a specified host and port. It is used when creating a client stub. Clients can specify channel arguments to modify gRPC\u2019s default behavior, such as switching message compression on or off. A channel has state, including\u2003<code>connected</code>\u2003and\u2003<code>idle</code>.</p> <p>How gRPC deals with closing a channel is language dependent. Some languages also permit querying channel state.</p>"},{"location":"hidden/tags/","title":"Tags","text":""},{"location":"hidden/tags/#tags","title":"Tags","text":""},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#tags","title":"Tags","text":""},{"location":"tags/#digitalgarden","title":"DigitalGarden","text":"<ul> <li>Home</li> <li>Index</li> </ul>"},{"location":"tags/#pasta","title":"Pasta","text":"<ul> <li>Spinatnudeln</li> <li>Spinatnudeln</li> </ul>"},{"location":"tags/#cheat","title":"cheat","text":"<ul> <li>Rider Shortcuts (IntelliJ IDEA)</li> <li>Rider Shortcuts (IntelliJ IDEA)</li> </ul>"},{"location":"tags/#ci","title":"ci","text":"<ul> <li>GitVersion</li> <li>GitVersion</li> </ul>"},{"location":"tags/#cleancode","title":"cleancode","text":"<ul> <li>Clean Code</li> <li>Integration Tests</li> <li>Robert C. Martin</li> <li>SOLID</li> <li>Unit Test</li> <li>Clean Code Developer</li> <li>Blauer Grad</li> <li>Gelber Grad</li> <li>Gr\u00fcner Grad</li> <li>Orangener Grad</li> <li>Roter Grad</li> <li>Wei\u00dfer Grad</li> <li>Automated Integrationtests</li> <li>Automated Unit Tests</li> <li>Boy Scout Rule</li> <li>Code Coverage Analysis</li> <li>Code Reviews</li> <li>Complex Refactorings</li> <li>Component Orientation</li> <li>Continuous Delivery</li> <li>Continuous Integration</li> <li>Daily Reflection</li> <li>Design before Implementation</li> <li>Error Measurement</li> <li>Incremental Development</li> <li>Inversion of Control Container</li> <li>Issue Tracking</li> <li>Iterative Development</li> <li>Mockups</li> <li>Partizipation in Professional Events</li> <li>Read, Read, Read</li> <li>Root Cause Anaysis</li> <li>Share Experience</li> <li>Simple Refactorings</li> <li>Statical Code Analysis</li> <li>Tell, don\u2019t ask</li> <li>Test First</li> <li>Version Control System</li> <li>Beware of Premature Optimization</li> <li>Don\u2019t Repeat Yourself (DRY)</li> <li>Dependency Inversion Principle (DIP)</li> <li>Design and Implementation Don\u2019t Overlapp</li> <li>Favour Composition over Inheritance (FCoI)</li> <li>Implementation Reflects Design</li> <li>Information Hiding Principle</li> <li>Integration Operation Segregation Principle (IOSP)</li> <li>Interface Segregation Principle (ISP)</li> <li>Keep it simple, stupid (KISS)</li> <li>Law of Demeter</li> <li>Liskov Substitution Principle</li> <li>Open Closed Principle (OCP)</li> <li>Principle of Least Astonishment</li> <li>Separation of Concerns (SoC)</li> <li>Single Level of Abstraction (SLA)</li> <li>Single Responsibility Principle (SRP)</li> <li>Source Code Conventions</li> <li>You Ain\u2019t Gonna Need It</li> <li>Automated Integrationtests</li> <li>Automated Unit Tests</li> <li>Beware of Premature Optimization</li> <li>Blauer Grad</li> <li>Boy Scout Rule</li> <li>Clean Code Developer</li> <li>Clean Code</li> <li>Code Coverage Analysis</li> <li>Code Reviews</li> <li>Complex Refactorings</li> <li>Component Orientation</li> <li>Continuous Delivery</li> <li>Continuous Integration</li> <li>Don\u2019t Repeat Yourself (DRY)</li> <li>Daily Reflection</li> <li>Dependency Inversion Principle (DIP)</li> <li>Design and Implementation Don\u2019t Overlapp</li> <li>Design before Implementation</li> <li>Error Measurement</li> <li>Favour Composition over Inheritance (FCoI)</li> <li>Gelber Grad</li> <li>Gr\u00fcner Grad</li> <li>Implementation Reflects Design</li> <li>Incremental Development</li> <li>Information Hiding Principle</li> <li>Integration Operation Segregation Principle (IOSP)</li> <li>Integration Tests</li> <li>Interface Segregation Principle (ISP)</li> <li>Inversion of Control Container</li> <li>Issue Tracking</li> <li>Iterative Development</li> <li>Keep it simple, stupid (KISS)</li> <li>Law of Demeter</li> <li>Liskov Substitution Principle</li> <li>Mockups</li> <li>Open Closed Principle (OCP)</li> <li>Orangener Grad</li> <li>Partizipation in Professional Events</li> <li>Principle of Least Astonishment</li> <li>Read, Read, Read</li> <li>Robert C. Martin</li> <li>Root Cause Anaysis</li> <li>Roter Grad</li> <li>SOLID</li> <li>Separation of Concerns (SoC)</li> <li>Share Experience</li> <li>Simple Refactorings</li> <li>Single Level of Abstraction (SLA)</li> <li>Single Responsibility Principle (SRP)</li> <li>Source Code Conventions</li> <li>Statical Code Analysis</li> <li>Tell, don\u2019t ask</li> <li>Test First</li> <li>Unit Test</li> <li>Version Control System</li> <li>Wei\u00dfer Grad</li> <li>You Ain\u2019t Gonna Need It</li> </ul>"},{"location":"tags/#cleancode_designpatterns","title":"cleancode_designpatterns","text":"<ul> <li>Design Patterns</li> <li>Abstract Factory</li> <li>Adapter</li> <li>Bridge</li> <li>Builder</li> <li>Chain of Responsibility</li> <li>Command</li> <li>Composite</li> <li>Decorator</li> <li>Facade</li> <li>Factory</li> <li>Flyweight</li> <li>Iterator</li> <li>Mediator</li> <li>Memento</li> <li>Observer</li> <li>Prototype</li> <li>Proxy</li> <li>Singleton</li> <li>State</li> <li>Strategy</li> <li>Template Method</li> <li>Visitor</li> <li>Abstract Factory</li> <li>Adapter</li> <li>Bridge</li> <li>Builder</li> <li>Chain of Responsibility</li> <li>Command</li> <li>Composite</li> <li>Decorator</li> <li>Design Patterns</li> <li>Facade</li> <li>Factory</li> <li>Flyweight</li> <li>Iterator</li> <li>Mediator</li> <li>Memento</li> <li>Observer</li> <li>Prototype</li> <li>Proxy</li> <li>Singleton</li> <li>State</li> <li>Strategy</li> <li>Template Method</li> <li>Visitor</li> </ul>"},{"location":"tags/#cleancode_refactoring","title":"cleancode_refactoring","text":"<ul> <li>Legacy Code</li> <li>Refaktorisieren</li> <li>Design Patterns</li> <li>Design Patterns</li> <li>Legacy Code</li> <li>Refaktorisieren</li> </ul>"},{"location":"tags/#cooking","title":"cooking","text":"<ul> <li>Baghali Polo</li> <li>Chili Con Carne</li> <li>Kichererbsen Wrap</li> <li>Penne all arrabbiata</li> <li>Baghali Polo</li> <li>Chili Con Carne</li> <li>Kichererbsen Wrap</li> <li>Penne all arrabbiata</li> </ul>"},{"location":"tags/#git","title":"git","text":"<ul> <li>GitVersion</li> <li>GitVersion</li> </ul>"},{"location":"tags/#is","title":"is","text":"<ul> <li>Entwurfsprinzipien</li> <li>Abbruch und R\u00fcckg\u00e4ngigmachen von Aktionen</li> <li>Adaptierbarkeit der Schnittstelle</li> <li>Angemessene R\u00fcckkopplung</li> <li>Ber\u00fccksichtigung von Fehlern</li> <li>Chunking</li> <li>Erwartungskonformes Verhalten</li> <li>Kenntnis potenzieller Benutzer und ihrer Aufgaben</li> <li>Kombination visueller und textueller Elemente</li> <li>Konsistenz</li> <li>Reduktion der kognitiven Belastung</li> <li>Sichtbarkeit von Systemzust\u00e4nden und m\u00f6glichen Aktionen</li> <li>Strukturierung der Benutzungsschnittstelle</li> <li>Terminologie der Benutzer verwenden</li> <li>Unterst\u00fctzung beim Aufbau mentaler Modelle</li> <li>Abbruch und R\u00fcckg\u00e4ngigmachen von Aktionen</li> <li>Adaptierbarkeit der Schnittstelle</li> <li>Angemessene R\u00fcckkopplung</li> <li>Ber\u00fccksichtigung von Fehlern</li> <li>Chunking</li> <li>Entwurfsprinzipien</li> <li>Erwartungskonformes Verhalten</li> <li>Kenntnis potenzieller Benutzer und ihrer Aufgaben</li> <li>Kombination visueller und textueller Elemente</li> <li>Konsistenz</li> <li>Reduktion der kognitiven Belastung</li> <li>Sichtbarkeit von Systemzust\u00e4nden und m\u00f6glichen Aktionen</li> <li>Strukturierung der Benutzungsschnittstelle</li> <li>Terminologie der Benutzer verwenden</li> <li>Unterst\u00fctzung beim Aufbau mentaler Modelle</li> </ul>"},{"location":"tags/#italian","title":"italian","text":"<ul> <li>Penne all arrabbiata</li> <li>Spinatnudeln</li> <li>Penne all arrabbiata</li> <li>Spinatnudeln</li> </ul>"},{"location":"tags/#keymap","title":"keymap","text":"<ul> <li>Rider Shortcuts (IntelliJ IDEA)</li> <li>Rider Shortcuts (IntelliJ IDEA)</li> </ul>"},{"location":"tags/#mexican","title":"mexican","text":"<ul> <li>Chili Con Carne</li> <li>Kichererbsen Wrap</li> <li>Chili Con Carne</li> <li>Kichererbsen Wrap</li> </ul>"},{"location":"tags/#persian","title":"persian","text":"<ul> <li>Baghali Polo</li> <li>Baghali Polo</li> </ul>"},{"location":"tags/#refactoring","title":"refactoring","text":"<ul> <li>Rider Shortcuts (IntelliJ IDEA)</li> <li>Rider Shortcuts (IntelliJ IDEA)</li> </ul>"},{"location":"tags/#rider","title":"rider","text":"<ul> <li>Rider Shortcuts (IntelliJ IDEA)</li> <li>Rider Shortcuts (IntelliJ IDEA)</li> </ul>"},{"location":"tags/#shortcuts","title":"shortcuts","text":"<ul> <li>Rider Shortcuts (IntelliJ IDEA)</li> <li>Rider Shortcuts (IntelliJ IDEA)</li> </ul>"},{"location":"tags/#versioning","title":"versioning","text":"<ul> <li>GitVersion</li> <li>GitVersion</li> </ul>"}]}